# 第6章 I/O复用：select和poll函数

## 6.1 概述

在5.12节中，我们看到TCP客户同时处理两个输入：标准输入和TCP套接字。我们遇到的问题是就在客户阻塞于（标准输入上的）fgets调用期间，服务器进程会被杀死。服务器TCP虽然正确地给客户TCP发送了一个FIN，但是既然客户进程正阻塞于从标准输入读入的过程，它将看不到这个EOF，直到从套接字读时为止（可能已过了很长时间）。这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这个能力称为I/O复用（I/O multiplexing），是由select和poll这两个函数支持的。我们还介绍前者较新的称为pselect的POSIX变种。

> 有些系统提供了更为先进的让进程在一串事件上等待的机制。轮询设备（poll device）就是这样的机制之一，不过不同厂家提供的方式不尽相同。我们将在第14章中阐述这种机制。

I/O复用典型使用在下列网络应用场合。

- 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。这时我们早先讲述过的场合。
- 一个客户同时处理多个套接字是可能的，不过比较少见。我们将在16.5节中结合一个Web客户的上下文给出这种场合使用select的例子。
- 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复用，如6.8节所述。
- 如果一个服务器即要处理TCP，又要处理UDP，一般就要使用I/O复用。我们将在8.15节给出这种场合的一个例子。
- 如果一个服务器要处理多个服务或者多个协议（例如我们将在13.5节讲述的inetd守护进程），一般就要使用I/O复用。

I/O复用并非只限于网络编程，许多重要的应用程序也需要使用这项技术。

## 6.2 I/O模型

在介绍select和poll这两个函数之前，我们需要回顾整体，查看Unix下可用的5种I/O模型的基本区别：

- 阻塞式I/O；
- 非阻塞式I/O；
- I/O复用（select和poll）；
- 信号驱动式I/O（SIGIO）；
- 异步I/O（POSIX的aio_系列函数）。

首次阅读本书时，你可以略读本节，在碰到以后各章节中详细介绍的各种I/O模型时再回头细读。

正如我们将在本节给出的所有例子所示，一个输入操作通常包括两个不同的阶段：

（1）等待数据准备好；

（2）从内核向进程复制数据。

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

### 6.2.1 阻塞式I/O模型

