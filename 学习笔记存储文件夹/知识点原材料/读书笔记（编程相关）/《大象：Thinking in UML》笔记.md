# 大象希形

UML，简单来说只有元素、视图与模型，但水平高低之间，绝不在于谁能在视图之上画出各种元素堆积的模型，而是在于谁能够借助UML提供的这些工具，灵活自如地为复杂项目的开发提供一个成熟的、统一的、系统的、广泛适用的系统分析涉及与建模方法，即软件的统一过程。

说到统一过程，不能不提一下RUP，正是由于RUP和UML师出同门，造就了RUP在软件统一过程中的霸主地位。

有句俗话叫吃水不忘挖井人，说起UML，不能忘记Ivar，James，Grady这三个UML的创始人——三位方法学大师，在软件领域，他们是教父级人物。

# 第一部分 准备篇——需要了解

# 第1章 为什么需要UML

## 1.1 面向过程还是面向对象

在很多人看来，面向过程和面向对象都是一种软件技术。例如把面向过程归纳为结构化程序设计、DFD图、ER模型、UC矩阵等，而面向对象则被归纳为继承、封装、多态、复用等具体的技术。事实上，上述的技术都只是人们在采用不同方法来认识和描述这个世界时所采用的工具，它们都只是表征而不是本征。我们先来看看公认的面向对象大师，也是UML创始人之一的Grady Booch在2004年IBM Developer Works Live！大会的访谈中讲过的一段流传甚广的话：

> 我对面向对象的目标从来就不是复用。相反，对我来说，对象提供了一种处理复杂性问题的方式。这个问题可以追溯到亚里士多德：您把这个世界视为过程还是对象？在面向对象兴起运动之前，编程以过程为中心，例如结构化设计方法。然而，系统已经达到了超越其处理能力的复杂性极点。有了对象，我们能够通过提升抽象级别来构建更大的、更复杂的系统——我认为，这才是面向对象编程运动的真正胜利。

正如Booch讲到的一样，从本质上来说面向过程和面向对象是一个古已有之的认识论的问题。之所以面向对象方法会兴起，是因为这种认识论能够帮助我们构造更为复杂的系统来解释越来越复杂的现实世界。认识到这一点，我们应该知道比掌握具体的技术更重要的是掌握认识论所采用的方法和分析过程。只有掌握了方法才能自如地使用工具。

### 1.1.1 面向过程方法

如果我们要分析这个世界，并用计算机来模拟它，首要的工作是将这个过程描绘出来，把它们的因果关系都定义出来；再通过结构化的设计方法，将这些过程进行细化，形成可以控制的、范围较小的部分。通常，面向过程的分析方法是找到过程的起点，然后顺藤摸瓜，分析每一个部分，直至达到过程的终点。这个过程中的每一部分都是过程链上不可分割的一环。

为了能很好地分析这样地过程，DFD图（Data Flow Diagram）被广泛应用。DFD图表达了“（从上一步）输入数据-->（在这一步）功能计算-->（向下一步）输出数据”这样一个基础单元。

由于数据是如此重要，因此数据的正确性和完备性对系统成功与否至关重要。为了更好地管理数据，不至于让系统运行紊乱，人们通过定义主键、外键等手段将数据之间地关系描绘出来，结构化地组织它们，利用关系理论，即数据库的三大范式来保证它们的完备性和一致性。在面向过程成为主要的软件方法之后，关系型数据库得到了极大的发展，针对数据的分析方法ER模型也深入人心，被极为广泛地使用。

然而随着需求越来越复杂，系统越来越庞大，功能点越来越多，一份数据经常被多个过程共享，这些过程对同一份数据的创建和读取要求越来越趋于复杂和多样，经常出现相矛盾的数据需求，因此分析和设计也变得越来越困难。为了解决这个问题，IBM在20世纪70年代提出了UC矩阵的方法来求解功能和数据之间的依赖问题。这个方法将功能点和数据分别作为横纵坐标来组成一个二维矩阵，在横纵坐标的每个交叉点上标记功能点对数据的要求，即U（Use）和C（Create）。标记完成后，对功能点位置和数据位置在各自坐标系上进行调整，调整的目标是尽量将C放在整个矩阵的对角线上，这时，各个功能点对数据的交叉依赖是最小的。最后，再把相邻的一些功能点分组，由此来获得数据交叉依赖性最小，功能聚合最紧密的子系统。

尽管UC矩阵是一个非常管用的方法，但面向过程的困难并没有从根本上解决。本质的问题出在认识方法上。我们这个世界从来都不是一成不变的，尤其到了信息化时代，一切都无时无刻不在发生着变化，系统所依赖的因果关系变得越来越弱。如今，SOA已经提上日程，IBM也提出了著名的口号：On-Demand Business(随需应变的商务)，面向过程已经面临了太多的困难，世界的复杂性和频繁变革已经不是面向过程可以轻易应付的了。

### 1.1.2 面向过程的困难

对以数据为中心的面向过程方法来说，数据的变化不但过于频繁，而且常常是结构性的颠覆。以数据为分析基础的面向过程方法该如何保持程序的稳定呢？

我们可以看到，面向过程的困难，本质上是因为面向过程方法将世界看作是过程化的，一个个紧密相连的小系统，构成这个系统的各个部分之间有着密不可分的因果关系。这种分析方法在需求复杂度低的时候非常管用，然而这个世界系统是如此的复杂和不可捉摸。

其实并非面向过程的方法不正确，只是因为构成一个系统的因素太多，要把所有可能的因素都考虑到，把所有因素的因果关系都分析清楚，再把这个过程模拟出来实在是太困难了。

### 1.1.3 面向对象方法

面向对象（Object Oriented，简称OO）方法将世界看作一个个相互独立的对象，相互之间并无因果关系，它们平时是“鸡犬之声相闻，老死不相往来”的。只有在某个外部力量的驱动下，对象之间才会依据某种规律相互传递信息。这些交互构成了这个生动世界的一个“过程”。在没有外力的情况下，对象则保持着“静止”的状态。

从微观角度来说，这些独立的对象有着一系列奇妙的特性。例如，对象有着坚硬的外壳，从外部看来，除了它用来与外界交互的信息通道之外，对象内部就是一个黑匣子，什么也看不到，这被称为封装；再例如对象可以结合在一起形成新的对象，结合后的对象具有前两者特性的总和，这称为聚合；对象可以繁育，产下的孩子将拥有父辈全部的本领，这称为继承；对象都是多面派，它会根据不同的要求展现其中的一个面，这就是接口；多个对象可能长着相同的脸，而这张脸背后却有着不同的行为，这就是多态……

从宏观角度说，对象是“短视”的，它不知道它身处的整个世界是怎么回事，也不知道它的行为是如何贡献给这个世界的。它只知道与它有着联系的身边的一小群伙伴（这称为依赖），并与伙伴间保持着信息交流的关系（这称为耦合）。同时对象也是“自私”的，即便在伙伴之间，每个对象也仍然顽固地保护着自己的领地，只允许其他人通过它打开的小小窗口（这称为方法）进行交流，从不会向对方敞开心扉。

可以发现一个特点，每个对象都只与有限的其他对象有关系。每个对象不再需要从整个系统的角度来分析，需要关心的只是与它有关系的那几个对象。这使得我们在分析对象的时候需要考虑的信息量大大减少，自然的，这也简化了我们所面对的复杂度。

另一个重要的信息是，只要符合规则要求，这些标准零件就可以替换！这给我们带来了极大的灵活性和扩展能力。

再扩展一下我们的视野。面向对象的另一个非常重要的特性：抽象层次。

抽象层次的好处是不论在哪一个层次上，我们都只需要面对有限的复杂度和有限的对象结构，从而可以专心地了解这个层次上的对象是如何工作的；抽象层次的另一个更重要的好处是低层次的零件更换不会影响高层次的功能。

 面向对象方法与面向过程方法根本的不同，就是不再把世界看作是一个紧密关联的系统，而是看作一些互相独立的小零件，这些零件依据某种规则组织起来，完成一个特定的功能。原来，过程并非这个世界的本源，过程是由通过特定规则组织起来的一些对象“表现”出来的。面向对象和面向过程的这个差别导致了整个分析设计方法的革命。分析设计从过程分析变成了对象获取，从数据结构变成了对象结构。

### 1.1.4 面向对象的困难

在实际的工作中，我们常常设计出许多类来满足某个需求。但是如果问一问为什么要这样设计，为什么是五个类而不是七个类？为什么是十个方法而不是十二个？能很好回答这个问题的人并不多，绝大部分人的回答是凭经验。

尽管不情愿，还是得承认很多时候我们只能通过不断测试来证明我们设计出来的那些类的确实现了需求，这往往需要在项目后期投入大量的返工成本，却不能清楚地在设计阶段就证明这些类已经满足了实际需求。许多设计师在被要求验证他的设计的确满足要求的时候，常常听到的回答是我的这个设计应用了某某设计模式，这个结构很灵活，扩展性很强，它肯定能满足需求……空谈了许多却无法拿出一个实实在在的推导过程。

而同时许多程序员，一手拿着设计师设计出来的结果，一手拿着系统分析员编写的需求说明书，苦思冥想，就是无法把两者对上号；既搞不清楚到底设计是如何映射到需求的，也找不到两者之间的关系；他们脑子里常常盘旋着的问题是：这个类是表达了什么意思？为什么是这样的？

如果您被上面的这些问题困扰着，请您不要怀疑是否面向对象错了。我们把世界看作是由很多对象组成的这并没有错，只是现实世界和对象世界之间存在着一道鸿沟，这道鸿沟的名字就叫做抽象。抽象是面向对象的精髓所在，同时也是面向对象的困难所在。实际上，要想跨越这道鸿沟，我们需要：

- 一种把现实世界映射到对象世界的方法。
- 一种以对象世界描述现实世界的方法。
- 一种验证对象世界行为是否正确反映了现实世界的方法。

幸运的是，UML，准确的说是UML背后所代表的面向对象分析设计方法，正好架起了跨越这道鸿沟的桥梁。

## 1.2 UML带来了什么

### 1.2.1 什么是UML

面向对象的兴起是从编程领域开始的。第一种面向对象语言Smalltalk的诞生宣告了面向对象开始进入软件领域。最初，人们只是为了改进开发效率，编写更容易管理、能够重用的代码，在编程语言中加入了封装、继承、多态等概念，以求得代码的优化。但分析和设计仍然是以结构化的面向过程方法为主。

一批面向对象的设计方法（OOD方法）开始出现，例如Booch86、GOOD（通用面向对象开发）、HOOD（层次化面向对象设计）、OOSE（面向对象结构设计）等。

OOA（面向对象分析）方法开始走上了舞台，其中最为重要的方法便是UML的前身，即：由Booch创造的Booch方法，由Jacobson创造的OOSE、Martin/Odell 方法和Rumbaugh创造的OMT、Shlaer/Mellor方法。这些方法虽然各不相同，但它们的共同理念却是非常相似的。于是三位面向对象大师决定将他们各自的方法统一起来，在1995年10月推出了第一个版本，称为“统一方法”（Unified Method 0.8）。随后又以“统一建模语言”（Unified Modeling Language）UML 1.0的正式名称提交到OMG（对象管理组织），在1997年1月正式成为一种标准建模语言。之所以改名，是因为UML本身并没有包含软件方法，而仅是一种语言，我们将在1.3节统一过程简介中解释语言和方法的关系。

如上所述UML是一种建模用的语言，而所有的语言都是由基本词汇和语法两个部分构成的，UML也不例外。UML定义了一些建立模型所需要的、表达某种特定含义的基本元素；这些元素称为元模型，相当于语言中的基本词汇，例如用例、类等。另外，UML还定义了这些元模型互相之间关系的规则，以及如何用这些元素和规则绘制图形以建立模型来映射现实世界；这些规则和图形称为表示法或视图（View），相当于语言中的语法。

学会用UML建模本身更重要的是要理解UML语言背后所隐含的最佳实践。

### 1.2.2 统一语言

目前，随着软件工程的不断成熟，软件开发越来越朝着专业化和横向分工化发展。

软件开发工作中这种将角色细分，将职责明确的做法，在提高专业化和资源效率的同时也带来了严重的沟通问题。一种好方法就是大家都使用统一的或者说标准化的语言。UML统一建模语言的意义也在于此，它试图用统一的语言来覆盖整个软件过程，让不同团队操着同一个口音顺畅地沟通。

统一语言的另一个意义是要让人和机器都能读懂。

### 1.2.3 可视化

可视化的含义是指，UML通过它的元模型和表示法，把那些通过文字或其他表达方法很难表达清楚的，隐晦的潜台词用简单直观的图形表达和暴露出来，准确而直观地描述复杂的含义。

>注：以下描述的解决面向对象的过程采用了RUP方法，实际上UML本身并不是一定要采用RUP方法的。关于这一点，在统一过程简介一章中会详细阐述语言和方法的关系。

### 1.2.4 从现实世界到业务模型

第一，UML采用被称之为参与者（actor）的元模型作为信息来源提供者，参与者代表了现实世界的”人“。参与者是模型信息来源的提供者，也是第一驱动者。换句话说，要建立的模型的意义完全被参与者决定，所建立的模型也是完全为参与者服务的，参与者是整个建模过程的中心。

第二，UML采用被称之为用例（use case）的一种元模型来表示驱动者的业务目标，也就是参与者想要做什么并且获得什么。这个业务目标就是现实世界中的“事”。而这件事是怎么做的，依据什么规则，则通过被称之为业务场景（business scenario）和用例场景（use case scenario）的UML视图来描绘的，这些场景便是现实世界中的“规则”。最后，UML通过被称之为业务对象模型（business object model）的视图来说明在达成这些业务目标的过程中涉及到的事物，用逻辑概念来表示它们，并定义它们之间的关系。业务对象模型则代表了现实世界中的“物”。

### 1.2.5 从业务模型到概念模型

虽然上一节中现实世界被业务模型映射并且记录下来，但这只是原始需求信息，距离可执行的代码还很遥远，必须把这些内容再替换成一种可以指导开发的表达方式。UML通过被称之为概念化的过程（Conceptual）来建立适合计算机理解和实现的模型，这个模型称为分析模型（Analysis Model）。分析模型介于原始需求和计算机实现之间，是一种过渡模型。

事实上分析模型在整个分析设计过程中承担了很大的职责，起到了非常重要的作用。绘制分析模型最主要的元模型有：

- 边界类（boundary）。边界是面向对象分析的一个非常重要的观点。狭义上说，边界就是大家熟悉的界面，所有对计算机的操作都要通过界面进行。从广义上说，任何一件事务都分为里面和外面，外面的事物与里面的事务之间任何交互都需要有一个边界。
- 实体类（entity）。原始需求中领域模型中业务实体映射了现实世界中参与者完成业务目标时所涉及的事物，UML采用实体类来重新表达业务实体。
- 控制类（control）。边界和实体都是静态的，本身并不会动作。UML采用控制类来表述原始需求中的动态信息，即业务或用例场景中的步骤和活动。从UML的观点看来，边界类和实体类之间，边界类和边界类之间，实体类和实体类之间不能够直接互相访问，它们需要通过控制类来代理访问要求。

### 1.2.6 从概念模型到设计模型

在设计模型中，概念模型中的边界类可以被转化为操作界面或者系统接口；控制类可以被转化为计算程序或控制程序，例如工作流、算法体等；实体类可以转化为数据库表、XML文档或者其他带有持久化特征的类。这个转化过程也是有章可循的，一般来说，可以遵循的规则有：

- 软件架构和框架。软件架构和框架规定了实现类必须实现的接口、必须继承的超类、必须遵守的编程规则等。例如当使用J2EE架构时，Home和Remote接口就是必需的。
- 编程语言。各类编程语言有不同的特点，例如在实现一个界面或者一个可持久化类时，采用C++还是Java作为开发语言会有不同的设计要求。
- 规范或中间件。如果决定采用某个规范或采用某个中间件时，实现类还有遵循规范或中间件规定的那些必需特性。

### 1.2.7 面向对象的困难解决了吗

#### 1.2.7.1 从现实世界到业务模型

#### 1.2.7.2 从业务模型到概念模型

#### 1.2.7.3 从概念模型到设计模型

## 1.3 统一过程简介

谈到UML不能不谈到统一过程，即RUP。UML和RUP师出同门，尽管目前仍有许多其他的建模方法，不过RUP仍然是其中对UML使用最为全面的，同时也是最为复杂的。本书的中心是UML，不能够深入讨论RUP，本节只介绍RUP和UML有关的基本知识以帮助理解本书的内容。

### 1.3.1 RUP是什么

严格说起来UML并不是一个方法，而只是一种语言。UML定义了基本元素，定义了语法，但是如果要做一个软件项目，还需要有方法的指导。UML也需要有方法的指导来完成一个软件项目。RUP无疑是目前与UML集成和应用最好、最完整的软件方法。

RUP(Rational Unified Process)译为统一过程。统一过程并非是因为UML才诞生的，也不是最近才出来的软件方法，而是有着很长时间的发展，有着很深的根源。

统一过程归纳和集成了软件开发活动中的最佳实践，它定义了软件开发过程中最重要的阶段和工作（四个阶段和九个核心工作流），定义了参与软件开发过程的各种角色和他们的职责，还定义了软件生产过程中产生的工件，并提供了模板。最后，采用演进式软件生命周期（迭代）将工作、角色和成果物串在一起，形成了统一过程。

> 工件：工件也称为成果物或者制品（Artifact），这与可交付物（Deliverable）是有一些差别的。当某一个或某一些工作是最终产品的一部分需要交付出去时，才被称为可交付物。而在软件生产过程中任何留下记录的事物，都可以称为工件。

~~~
四个阶段：先启、精化、构建、产品化
九个核心工作流：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境
~~~

### 1.3.2 RUP与UML

