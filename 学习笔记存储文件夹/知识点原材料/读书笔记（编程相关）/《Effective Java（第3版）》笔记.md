# Effective Java（第三版）笔记

## 第1章 引言

Java语言支持四种类型：接口（包括注释）、类（包括enum）、数组和基本类型。前三种类型通常被称为引用类型（reference type），类实例和数组是对象（object），而基本类型的值不是对象。

本书不再使用“接口继承”这种说法，而是简单地说，一个类实现（implement）了一个接口，或者一个接口扩展（extend）了另一个接口。

## 第2章 创建和销毁对象

### 第1条 用静态工厂方法代替构造器

对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有的构造器。还有一种方法，也应该在每个程序员的工具箱中占有一席之地。类可以提供一个共有的静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。下面是一个来自Boolean（基本类型boolean的装箱类）的简单示例。这个方法将boolean基本类型值转换成了一个Boolean对象引用：

~~~java
public static Boolean valueOf(boolean b){
    return b? Boolean.TRUE: Boolean.FALSE;
}
~~~

注意，静态工厂方法与设计模式中的工厂方法（Factory Method）模式不同。本条目中所指的静态工厂方法并不直接对应于设计模式（Pattern Design）中的工厂方法。

如果不通过共有的构造器，或者说除了共有的构造器外，类还可以给它的客户端提供静态工厂方法。提供静态工厂方法而不是公有的构造器，这样做既有优势，也有劣势。

**静态工厂方法与构造器不同的第一大优势在于，它们有名称。** 如果构造器的参数本身没有确切地描述正被返回的对象，那么具有恰当名称的静态工厂会更容易使用，产生的客户端代码也更易阅读。例如，构造器BigInteger(int, int, Random)返回的BigInteger可能为素数，如果用名叫BigInteger.probablePrime的静态工厂方法来表示，显然更为清楚。（Java4版本中增加了这个方法。）

一个类只能有一个带有指定签名的构造器。编程人员通常知道如何避开这一限制：通过提供两个构造器，它们的参数列表只在参数类型的顺序上有所不同。实际上这并不是个好主意。面对这样的API，用户永远也记不住该用哪个构造器，结果常常会调用错误的构造器。并且在读到使用了这些构造器的代码时，如果没有参考类的文档，往往不知所云。

由于静态工厂方法有名称，所以它们不受上述限制。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且仔细地选择名称以便突出静态工厂方法之间的区别。