# 第1章 JavaScript简介

## 1.1 JavaScript简史

欧洲计算机制造商协会（ECMA，European Computer Manufacturers Association）

# 第2章 在HTML中使用JavaScript

## 2.4 noscript元素

用以在不支持JavaScript的浏览器中显示替代的内容。

# 第3章 基本概念

## 3.5 操作符

### 3.5.2 位操作符

ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。

### 3.5.3 布尔操作符

！！与Boolean()函数效果相同

### 3.5.7 相等操作符

相等(\=\=)和不相等(!\=)——先转换再比较

全等(\=\=\=)和不全等(!\==)——仅比较而不转换

```
相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。
```



### 3.5.10 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作。

逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。

## 3.6 语句

### 3.6.8 with语句

with语句的作用是将代码的作用域设置到一个特定的对象中。

严格模式下不允许使用with语句，否则将视为语法错误。

```
由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。
```



## 3.7 函数

### 3.7.1 理解参数

ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型。	之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。

其实arguments对象只是与数组类似（它并不是Array的实例），因为可以使用方括号语法访问它的每一个元素，使用length属性来确定传递进来多少个参数。

arguments对象中的值会自动反映到对应的命名参数，所以修改arguments[1]，也就修改了num2。	不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。但这种影响是单向的：修改命名参数并不会改变arguments中对应的值。

严格模式对如何使用arguments对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把arguments[1]设置为10，num2的值仍然还是undefined。其次，重写arguments的值会导致语法错误。

```
ECMAScript中所有参数传递都是值，不可能通过引用传递参数。
```

### 3.7.2 没有重载

如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。

通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。

# 第4章 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

5种基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

```
很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。
```

### 4.1.4 检测类型

```
使用typeof操作符检测函数时，该操作符会返回“function”。在Safari 5及之前版本和Chrome 7及之前版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。
IE和Firefox中，对正则表达式应用typeof会返回“object”。
```

## 4.2 执行环境及作用域

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。

### 4.2.1 延长作用域链

- try-catch语句的catch块；
- with语句。

### 4.2.2 没有块级作用域

## 4.3 垃圾收集

### 4.3.1 标记清除

JavaScript中最常用的垃圾收集方式是标记清除。

### 4.3.2 引用计数

BOM和DOM中的对象就是使用C++的COM（Component Object Model，组件对象模型）对象形式实现的	JavaScript访问的COM对象依然是基于引用计数策略的。

### 4.3.4 管理内存

确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（deferencing）。

# 第5章 引用类型

## 5.1 Object类型

创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数。

另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。

```java
在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox 2 及更早版本会调用Object构造函数；但Firefox 3 之后就不会了）。
```

JavaScript也可以使用方括号表示法来访问对象的属性。

通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

## 5.2 Array类型

ECMAScript数组的每一项可以保存任何类型的数据。	而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

在使用Array构造函数时也可以省略new操作符。

创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。

数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。

### 5.2.1 检测数组

instanceof

Array.isArray()

### 5.2.2 转换方法

toLocalString()调用了数组每一项的toLocalString()方法

数组继承的toLocalString()，toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。

### 5.2.3 栈方法

push() pop()

### 5.2.4 队列方法

shift(),它能够移除数组中的第一个项并返回该项，同时将数组长度减1.

unshift()方法，顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。

### 5.2.5 重排序方法

reverse()方法会对反转数组项的顺序。

sort()方法。默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。

比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

### 5.2.6 操作方法

concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

splice()的主要用途是向数组的中部插入项，但使用这种方法的形式则有如下3种。

- 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。

### 5.2.7 位置方法

indexOf() 和 lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。

这两个方法都返回查找的项在数组中的位置，或者在没找到的情况下返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符

### 5.2.8 迭代方法

ECMAScript 5 为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法的函数会接收三个参数：数组项的值、该值在数组中的位置和数组对象本身。

- every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
- filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
- forEach(): 对数组的每一项运行给定函数。这个方法没有返回值。
- map(): 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some(): 对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

### 5.2.9 缩小方法

reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。

这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

## 5.3 Date类型

在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。

Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。

不支持Date.now()的浏览器中，使用+操作符把Date对象转换成字符串，也可以达到同样目的。

`var start = +new Date();`

### 5.3.2 日期格式化方法

- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的UTC日期。

### 5.3.3 日期/时间组件方法

## 5.4 RegExp类型

正则表达式的匹配模式支持下列3个标志。

- g: 表示全局（global）模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i: 表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：

`( [ { \ ^ $ | ) ? * + . ] }`

前面签的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义

`var pattern1 = /[bc]at/i;`

`var pattern2 = new RegExp("[bc]at","i");`

传递给RegExp构造函数的两个参数都是字符串。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。

### 5.4.1 RegExp实例属性

- global：布尔值，表示是否设置了g标志。
- ignoreCase：布尔值，表示是否设置了i标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
- multiline：布尔值，表示是否设置了m标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

### 5.4.2 RegExp实例方法

exec()，该方法是专门为捕获组而设计的。

test(), 它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。

## 5.5 Function类型

`function sum(num1, num2){return num1+num2;}`

`var sum = function(num1,num2){return num1+num2};`

`var sum = new Function("num1","num2","return num1+num2");//不推荐`

### 5.5.3 作为值的函数

callSomeFunction()函数

### 5.5.4 函数内部属性

callee

caller

当函数在严格模式下运行时，访问arguments.callee会导致错误。

### 5.5.5 函数属性和方法

length和prototype

apply()和call()

bind()

## 5.6 基本包装类型

### 5.6.2 Number类型

toFixed()

toExponential()

toPrecision()

### 5.6.3 String类型

length属性

charAt()和charCodeAt()

方括号加数字索引来访问字符串中的特定字符

concat()

slice()、substr() 和 substring()

indexOf() 和 lastIndexOf()

trim()

toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()

match()	search()	replace()	split()

localeCompare()

fromCharCode()

## 5.7 单体内置对象

### 5.7.1 Global对象

encodeURI() 和 encodeURIComponent()

decodeURI() 和 decodeURIComponent()

eval()

### 5.7.2 Math对象

min() max()

舍入方法：Math.ceil()、Math.floor()和Math.round()。

random()

# 第6章 面向对象的程序设计

## 6.2 创建对象

### 6.2.3 原型模式

isPrototypeOf()

getPrototypeOf()

hasOwnProperty()

