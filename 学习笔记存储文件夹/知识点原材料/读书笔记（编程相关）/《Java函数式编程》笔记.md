# 序言

大多数命令式程序无法被证明是正确的。测试只允许我们在测试失败时证明程序不正确。成功的测试说明不了什么问题。你无法证明发布的程序是不正确的。就单线程程序而言，大量的测试也许能够说明你的代码大部分是正确的。但是对于多线程应用程序，条件组合的数量使测试成为不可能。显然，我们需要另一种不同的方式来编写程序。在理想情况下，这种方法将允许我们证明程序是正确的。因为这一般不是完全可能的，所以一个很好的折中是明确分离程序中可以被证明为正确的部分和不能证明为正确的部分。这就函数式编程技术所能提供的。

可以采用许多种技术来实现这一目标。使用不可变数据虽然不仅限于函数式编程，但却是这样一种技术。如果数据不能更改，你将不会有任何（不良的）意外，数据不会过期或损坏，没有竞争条件，无须锁住并发访问，也不会有死锁的风险。可以毫无风险地共享不可变数据。你不需要生成防御性副本，那就没有了忘记这样做的风险。另一种技术是抽象控制结构，因此你不必冒着混淆循环索引和退出条件的风险一次又一次地编写相同的结构。完全删除使用 null 引用（无论是隐式还是显式）将把你从臭名昭著的 NPE （空指针异常， NullPointerException ）中解放出来。通过所有这些技术（还有更多），你可以确信：如果程序通过编译，那它就是正确的（也就是说，它的实现没有 bug ）。虽然这样做并不能消除所有可能的 bug 但它更加安全。

在 Java 中使用函数式编程技术往往会导致你反对所谓的“最佳实践”。实际上，这些实践中有许多都没有用，有些还确实是非常糟糕的做法。从不捕获错误就是其中之一。 作为 Java 程序员，你可能已经了解到不应该捕获 OOME （内存不足的错误Out Of Memory Error ）或是你无法处理的其他类型错误。 也许你甚至知道不应该捕NPE （空指针异常， NullPointerExceptions ），因为它们表示有 bug ，你应该让应用程序崩溃并修复它。不幸的是， OOME 和 NPE 都不会使应用程序崩溃。它们只会使所在的线程崩渍，并留下处于某种不确定状态的应用程序。即使它们发生在线程中，如果某些非后台线程正在运行，它们也可能无法使应用程序崩憬。当所有的应用程序都是单线程时，这种“最佳实践”是正确的。而现在它是一个非常糟糕的实践。你应该捕获所有的异常，尽管可能不在一个 try... catch 块中。函数式编程的真言是“始终捕获，绝不抛出”。

# 1 什么是函数式编程

并不是所有人都在函数式编程（functional programming，即FP）的定义上达成了共识。一般来说，函数式编程是用函数来编程的一种编程范式。但这个定义并不能解释最重要的一点： 函数式编程和其他编程范式的区别，以及究竟是什么让它（可能）成为编程的更佳方式。在 1990 年出版的 *Why Functional Programming Matters* 一书中， John Hughes 写道：

> 函数式编程中没有赋值语句，因此变量一旦有了值，就不会再改变了。更通俗地说，函数式编程完全没有副作用。除了计算结果，调用函数没有别的作用。这样便消除了 bug 的一个主要来源，也使得执行顺序变得无关紧要一一因为没有能够改变表达式值的副作用，可以在任何时候对它求值。这样便把程序员从处理控制流程的负担中解脱出来。由于能够在任何时候对表达式求佳，所以可以用变量的值来自由替换表达式，反之亦然一一即程序是“引用透明”的。这样的自由度让函数式的程序比它们的一般对手在数学上更易驾驭。

在本章的其余内容中，我会简要地展示引用透明和代换模型的概念，还有函数式编程的其他精华概念。你将会在其他章节中多次应用这些概念。

## 1.1 函数式编程是什么

理解事物是什么与不是什么往往都很重要。如果函数式编程是一种编程范式，那么显然还会有其他不同的编程范式。与一些人预料的可能相反，函数式编程与面向对象编程（OOP）并不是非此即彼。有些函数式编程语言是面向对象的，有些不是。

函数式编程有时被认为是一系列可以补充或替代其他编程范式的技术，例如

- 函数是一等公民
- 匿名函数
- 闭包
- 柯里化
- 惰性求值
- 参数多态
- 代数数据类型

尽管大部分的函数式编程语言确实使用了一些这样的技术，但是对于每一种技术，你也都可以找到函数式编程语言不支持的例子。同样的，非函数式编程语言也会支持一些这样的技术。你会看到在本书中学习这些技术的时候，让程序更加函数化的并非是编程语言，而是你写代码的方式。话虽如此，有些语言会对函数更加友好一些。

与函数式编程相对的应该算是命令式编程范式。在命令式编程的风格里，程序由“做”事情的要素构成。“做”事情意味着一个初始状态、 一个转换过程和一个终止状态。有时这被称为**状态改变**（ state mutation ）。传统的命令式风格的程序通常描述了一系列由条件判断区分的改变。

另一方面，函数式编程由“是”什么的元素组成，而不是“做”什么。a与b的和并不会“造”出一个结果。例如2与3的和，并不会造出5。它就是5。

在求和的例子里，你可以清楚地看到这两个变量被程序破坏掉了。这就是程序除了返回一个结果以外的作用， 因而被称为副作用 。（发生在 Java 方法中的计算还不太一样，因为变量 a 和 b 可能是传进来的值，仅在当前作用域里发生变化，在方法外面并不可见。）

命令式编程和函数式编程的一个最大的不同是，函数式编程没有副作用。这意味着其中

- 没有变量改变。
- 没有打印到控制台或其他设备。
- 没有写入文件、数据库、网络或其他什么。
- 没有抛出异常。

当我说“没有副作用”的时候，我是指没有可观测到的副作用。函数式的程序是由接收参数并返回值的函数复合而成的，仅此而己。你并不关心函数内部发生了什么，因为在理论上，什么都没有发生。但是在实际上，程序是为完全不函数式的计算机而编写的。所有的计算机都基于相同的命令式范式，所以函数就是如下黑盒：

- 接收一个参数（一个单独的参数，一会儿你就会看到）。
- 内部做一些神秘的事情，例如改变变量的值，还有许多命令式风格的东西，但是在外界来看并没有什么作用。
- 返回一个（单独的）值。

这只是理论。实际上，函数不可能完全没有副作用。函数会在某个时候返回一个值，而这个值可能是变化的。这就是一个副作用。它可能会造成一个内存耗尽的错误，或者是堆栈溢出的错误，导致应用程序崩惯，这在某种意义上就是一个可观测到的副作用 。并且它还会造成写内存、寄存器变化、加载线程、上下文切换和其他确实会影响外界观测的这类事情。

所以函数式编程其实是编写非故意的副作用的程序，我的意思是，副作用是程序预期结果的一部分。非故意的副作用也应该越少越好。

## 1.2 编写没有副作用的程序

你可能想知道如何才能编写出既没有副作用又有用的程序。显然这不太可能。函数式编程并非关于编写没有可观测结果的程序。它是关于编写除了返回值以外没有可观测结果的程序。但如果这就是程序能做的全部，那就没有多大的用处。最后，函数式编程需要有可观测的作用，例如把结果显示在屏幕上，写到文件或数据库里，或者通过网络发送出去。与外界的这种交互不会发生在计算过程中，而只会发生在计算完成后。换句话说，将会推迟副作用并单独应用。

以图1.1的加法为例。虽然描述的是命令式的风格，但程序也可能是函数式的，取决于如何实现。想象一下用 Java 实现的以下代码：

~~~java
public static int add(int a, int b) {
    while (b > 0) {
        a++;
        b--;
    }
    return a;
}
~~~

这段程序是彻头彻尾的函数式。它接收一对整型a和b为参，并返回一个值，完全没有其他可观测的作用。它改变了变量，但事实上与需求并不矛盾，因为 Java 的参数是值传递的，所以参数的变化在外界不可见。接下来你就可以选择应用一个作用，例如显示结果或是用结果做其他运算。

请注意，虽然结果可能不正确（在溢出的情况下），但是与没有副作用并不矛盾。如果a和b太大了，程序可能默默地溢出并返回一个错误的结果，但是这仍然是函数式的。另一方面，以下程序就不是函数式的：

~~~java
public static int div(int a, int b){
    return a / b;
}
~~~

虽然这段程序并不改变任何变量，但是当b等于0的时候，它会抛出异常。抛出异常就是一个副作用。与此相反，接下来的实现虽然有一点笨拙，但它却是函数式的：

~~~java
public static int div(int a, int b){
    return (int)(a / (float)b);
}
~~~

即使b为0，这样的实现也不会抛出异常，但是它会返回一个特殊的值。由你自行决定你的函数用返回特殊值来代表除数为零的做法是否可行。（很可能不行！）

无论抛异常是有意为之或是无意的，它终归是一个副作用 。 尽管在命令式编程
里，副作用一般正是我们想要的。最简单的形式可能看起来如下：  

~~~java
public static void add(int a, int b) {
    while(b > 0) {
        a++;
        b--;
    }
    System.out.println(a);
}
~~~

这段程序并不返回值，而是把它打印到了控制台上。这就是期望的副作用。

请注意如下程序，既返回了值又有意加上了副作用：  

~~~java
public static void add(int a, int b) {
    log(String.format("Adding %s and %s", a, b));
    while(b > 0) {
        a++;
        b--;
    }
    log(String.format("Returning %s", a));
    return a;
}
~~~

由于日志的副作用，上面这段代码并不是函数式的。

## 1.3 引用透明如何让程序更安全

没有副作用（所以并不会改变外界的什么）并不足以让程序变成函数式的。同样，函数式编程也不能被外界所影响。换句话说，函数式程序的输出只能取决于自己的参数。这就意味着函数式代码不能从控制台、文件、远程 URL、数据库甚至是系统里读取数据。不被外界所影响的代码就是引用透明的。  

引用透明的代码有一些性质对程序员而言很有意思：

- 它是独立的。它并不依赖于任何外部的设备来工作。你可以在任何上下文中使用它——你需要做的一切就是提供一个有效的参数。
- 它是确定的，意味着相同的参数总是返回相同的结果 。在 引用透明的代码中，不会有意外发生。它可能返回一个错误的结果，可至少结果对于相同的参数而言是绝对不会变化的。
- 它绝对不会抛出任何种类的 Exception。它可能抛出错误，例如 OOME( out-of-memory error ， 即内存耗尽）或是 SOE (stack-overflow error，即堆栈溢出），但是这些错误表示代码有 bug，并不是作为程序员的你或是你 API 的用户应该处理的（除了让应用程序崩溃井最终修复 bug）。
- 任何时候它都不会导致其他代码意外失败。例如，它不会改变参数或是外界的数据 ， 从而导致调用者发现自己的数据过期或者并发访问异常。  
- 它不会由于外部设备（数据库、文件系统或网络）不可用、太慢或坏掉而崩溃 。  

一个引用透明的程序除了获取输入参数和输出结果以外，并不会影响外界。它的结果只是取决于参数。

一个非引用透明的程序可能会从外界读写数据、写日志、改变外界对象、读取键盘输入、输出到屏幕等。结果是不可预测的。

## 1.4 函数式编程的优势

从我刚刚说的那些，你应该可以猜到函数式编程的诸多优势 ：  

- 函数式程序更加易于推断，因为它们是确定性（ deterministic ）的 。 对于一个特定的输入总会给出相同的输出。在许多情况下，你都可以证明程序是正确的，而不是在大量的测试后仍然不确定程序是否会在意外的情况下出错。  
- 函数式程序更加易于测试。因为没有副作用，所以你不需要那些经常用于在测试里隔离程序及外界的 mock。
- 函数式程序更加模块化，因为它们是由只有输入和输出的函数构建的。我们不必处理副作用，不必捕获异常，不必处理上下文变化，不必共享变化的状态，也没有并发的修改。
- 函数式编程让复合和重新复合更加简单。为了编写函数式程序，你需要开始编写各种必要的基础函数，并把它们复合为更高级别的函数，重复这个过程直到你拥有了一个与你打算构建的程序一致的函数。因为所有的函数都是引用透明的，它们无须修改便可以为其他程序所重用。  

函数式的程序天生就是线程安全的，因为它们防止了共享状态的变化。再重复一遍，这并不意味着所有数据都需要不可变 ， 只有共享的数据才需要。但是函数式程序员很快就会认识到不可变的数据总是更安全的，即使在外界观测不到这种变化。  

## 1.5 用代换模型来推断程序

请记住一个函数什么事情都不做。它只是有一值，依赖于参数而已。因此，永远都可以用其值来替换一个函数调用或是任何引用透明的表达式。

当应用函数时，代换模型允许你将任何函数调用替换为它的返回值。思考如下代码：

~~~java
public static void main(String[] args) {
    int x = add(mult(2, 3), mult(4, 5));
}
public static int add(int a, int b) {
    log(String.format("Returning %s as the result of %s + %s", a + b, a, b));
    return a + b;
}
public static int mult(int a, int b) {
    return a * b;
}
public static void log(String m) {
    System.out.println(m);
}
~~~

将mult(2, 3) 和 mult(4, 5) 替换为它们各自的返回值并不会改变程序的含义。

~~~java
int x = add(6, 20);
~~~

相比之下，将调用add函数替换为返回值就改变了程序的含义，因为log方法将不再被调用，从而不会记录任何日志。这可能很重要，可也能不是。总而言之，它改变了程序的结果。

## 1.6 将函数式原则应用于一个简单的例子

