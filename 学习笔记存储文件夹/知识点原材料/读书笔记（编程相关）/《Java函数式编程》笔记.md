# 序言

大多数命令式程序无法被证明是正确的。测试只允许我们在测试失败时证明程序不正确。成功的测试说明不了什么问题。你无法证明发布的程序是不正确的。就单线程程序而言，大量的测试也许能够说明你的代码大部分是正确的。但是对于多线程应用程序，条件组合的数量使测试成为不可能。显然，我们需要另一种不同的方式来编写程序。在理想情况下，这种方法将允许我们证明程序是正确的。因为这一般不是完全可能的，所以一个很好的折中是明确分离程序中可以被证明为正确的部分和不能证明为正确的部分。这就函数式编程技术所能提供的。

可以采用许多种技术来实现这一目标。使用不可变数据虽然不仅限于函数式编程，但却是这样一种技术。如果数据不能更改，你将不会有任何（不良的）意外，数据不会过期或损坏，没有竞争条件，无须锁住并发访问，也不会有死锁的风险。可以毫无风险地共享不可变数据。你不需要生成防御性副本，那就没有了忘记这样做的风险。另一种技术是抽象控制结构，因此你不必冒着混淆循环索引和退出条件的风险一次又一次地编写相同的结构。完全删除使用 null 引用（无论是隐式还是显式）将把你从臭名昭著的 NPE （空指针异常， NullPointerException ）中解放出来。通过所有这些技术（还有更多），你可以确信：如果程序通过编译，那它就是正确的（也就是说，它的实现没有 bug ）。虽然这样做并不能消除所有可能的 bug 但它更加安全。

在 Java 中使用函数式编程技术往往会导致你反对所谓的“最佳实践”。实际上，这些实践中有许多都没有用，有些还确实是非常糟糕的做法。从不捕获错误就是其中之一。 作为 Java 程序员，你可能已经了解到不应该捕获 OOME （内存不足的错误Out Of Memory Error ）或是你无法处理的其他类型错误。 也许你甚至知道不应该捕NPE （空指针异常， NullPointerExceptions ），因为它们表示有 bug ，你应该让应用程序崩溃并修复它。不幸的是， OOME 和 NPE 都不会使应用程序崩溃。它们只会使所在的线程崩渍，并留下处于某种不确定状态的应用程序。即使它们发生在线程中，如果某些非后台线程正在运行，它们也可能无法使应用程序崩憬。当所有的应用程序都是单线程时，这种“最佳实践”是正确的。而现在它是一个非常糟糕的实践。你应该捕获所有的异常，尽管可能不在一个 try... catch 块中。函数式编程的真言是“始终捕获，绝不抛出”。

# 1 什么是函数式编程

并不是所有人都在函数式编程（functional programming，即FP）的定义上达成了共识。一般来说，函数式编程是用函数来编程的一种编程范式。但这个定义并不能解释最重要的一点： 函数式编程和其他编程范式的区别，以及究竟是什么让它（可能）成为编程的更佳方式。在 1990 年出版的 *Why Functional Programming Matters* 一书中， John Hughes 写道：

> 函数式编程中没有赋值语句，因此变量一旦有了值，就不会再改变了。更通俗地说，函数式编程完全没有副作用。除了计算结果，调用函数没有别的作用。这样便消除了 bug 的一个主要来源，也使得执行顺序变得无关紧要一一因为没有能够改变表达式值的副作用，可以在任何时候对它求值。这样便把程序员从处理控制流程的负担中解脱出来。由于能够在任何时候对表达式求佳，所以可以用变量的值来自由替换表达式，反之亦然一一即程序是“引用透明”的。这样的自由度让函数式的程序比它们的一般对手在数学上更易驾驭。

在本章的其余内容中，我会简要地展示引用透明和代换模型的概念，还有函数式编程的其他精华概念。你将会在其他章节中多次应用这些概念。

## 1.1 函数式编程是什么

理解事物是什么与不是什么往往都很重要。如果函数式编程是一种编程范式，那么显然还会有其他不同的编程范式。与一些人预料的可能相反，函数式编程与面向对象编程（OOP）并不是非此即彼。有些函数式编程语言是面向对象的，有些不是。

函数式编程有时被认为是一系列可以补充或替代其他编程范式的技术，例如

- 函数是一等公民
- 匿名函数
- 闭包
- 柯里化
- 惰性求值
- 参数多态
- 代数数据类型

尽管大部分的函数式编程语言确实使用了一些这样的技术，但是对于每一种技术，你也都可以找到函数式编程语言不支持的例子。同样的，非函数式编程语言也会支持一些这样的技术。你会看到在本书中学习这些技术的时候，让程序更加函数化的并非是编程语言，而是你写代码的方式。话虽如此，有些语言会对函数更加友好一些。

与函数式编程相对的应该算是命令式编程范式。在命令式编程的风格里，程序由“做”事情的要素构成。“做”事情意味着一个初始状态、 一个转换过程和一个终止状态。有时这被称为**状态改变**（ state mutation ）。传统的命令式风格的程序通常描述了一系列由条件判断区分的改变。

另一方面，函数式编程由“是”什么的元素组成，而不是“做”什么。a与b的和并不会“造”出一个结果。例如2与3的和，并不会造出5。它就是5。

在求和的例子里，你可以清楚地看到这两个变量被程序破坏掉了。这就是程序除了返回一个结果以外的作用， 因而被称为副作用 。（发生在 Java 方法中的计算还不太一样，因为变量 a 和 b 可能是传进来的值，仅在当前作用域里发生变化，在方法外面并不可见。）

命令式编程和函数式编程的一个最大的不同是，函数式编程没有副作用。这意味着其中

- 没有变量改变。
- 没有打印到控制台或其他设备。
- 没有写入文件、数据库、网络或其他什么。
- 没有抛出异常。

当我说“没有副作用”的时候，我是指没有可观测到的副作用。函数式的程序是由接收参数并返回值的函数复合而成的，仅此而己。你并不关心函数内部发生了什么，因为在理论上，什么都没有发生。但是在实际上，程序是为完全不函数式的计算机而编写的。所有的计算机都基于相同的命令式范式，所以函数就是如下黑盒：

- 接收一个参数（一个单独的参数，一会儿你就会看到）。
- 内部做一些神秘的事情，例如改变变量的值，还有许多命令式风格的东西，但是在外界来看并没有什么作用。
- 返回一个（单独的）值。

这只是理论。实际上，函数不可能完全没有副作用。函数会在某个时候返回一个值，而这个值可能是变化的。这就是一个副作用。它可能会造成一个内存耗尽的错误，或者是堆栈溢出的错误，导致应用程序崩惯，这在某种意义上就是一个可观测到的副作用 。并且它还会造成写内存、寄存器变化、加载线程、上下文切换和其他确实会影响外界观测的这类事情。

所以函数式编程其实是编写非故意的副作用的程序，我的意思是，副作用是程序预期结果的一部分。非故意的副作用也应该越少越好。

## 1.2 编写没有副作用的程序

你可能想知道如何才能编写出既没有副作用又有用的程序。显然这不太可能。函数式编程并非关于编写没有可观测结果的程序。它是关于编写除了返回值以外没有可观测结果的程序。但如果这就是程序能做的全部，那就没有多大的用处。最后，函数式编程需要有可观测的作用，例如把结果显示在屏幕上，写到文件或数据库里，或者通过网络发送出去。与外界的这种交互不会发生在计算过程中，而只会发生在计算完成后。换句话说，将会推迟副作用并单独应用。

以图1.1的加法为例。虽然描述的是命令式的风格，但程序也可能是函数式的，取决于如何实现。想象一下用 Java 实现的以下代码：

~~~java
public static int add(int a, int b) {
    while (b > 0) {
        a++;
        b--;
    }
    return a;
}
~~~

这段程序是彻头彻尾的函数式。它接收一对整型a和b为参，并返回一个值，完全没有其他可观测的作用。它改变了变量，但事实上与需求并不矛盾，因为 Java 的参数是值传递的，所以参数的变化在外界不可见。接下来你就可以选择应用一个作用，例如显示结果或是用结果做其他运算。

请注意，虽然结果可能不正确（在溢出的情况下），但是与没有副作用并不矛盾。如果a和b太大了，程序可能默默地溢出并返回一个错误的结果，但是这仍然是函数式的。另一方面，以下程序就不是函数式的：

~~~java
public static int div(int a, int b){
    return a / b;
}
~~~

虽然这段程序并不改变任何变量，但是当b等于0的时候，它会抛出异常。抛出异常就是一个副作用。与此相反，接下来的实现虽然有一点笨拙，但它却是函数式的：

~~~java
public static int div(int a, int b){
    return (int)(a / (float)b);
}
~~~

即使b为0，这样的实现也不会抛出异常，但是它会返回一个特殊的值。由你自行决定你的函数用返回特殊值来代表除数为零的做法是否可行。（很可能不行！）

