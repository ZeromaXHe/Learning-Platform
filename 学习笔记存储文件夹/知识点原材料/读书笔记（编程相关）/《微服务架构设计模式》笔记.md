# 第1章 逃离单体地狱

## 1.4 拯救之道：微服务架构

### 1.4.1 扩展立方体和服务

X轴扩展：在多个实例之间实现请求的负载均衡

Z轴扩展：根据请求的属性路由请求

Y轴扩展：根据功能把应用拆分为服务

### 1.4.5 微服务架构与SOA的异同

某些针对微服务架构的批评声称它其实就是SOA，并没有新鲜的内容。在某些层面，它们的确有些相似。SOA和微服务架构都是特定的架构风格，它们都以一系列服务的方式来把一个系统组织在一起。但如果深入研究，你就会发现微服务和SOA之间巨大的差异，如表1-1所示。

|                | SOA                                                          | 微服务                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 服务间通信     | 智能管道，例如Enterprise Service Bus（ESB），往往采用重量级协议，例如SOAP或其他WS*标准 | 使用哑管道，例如消息代理，或者服务之间点对点通信，使用例如REST或gRPC类的轻量级协议 |
| 数据管理       | 全局数据模型并分享数据库                                     | 每个服务都有自己的数据模型和数据库                           |
| 典型服务的规模 | 较大的单体应用                                               | 较小的服务                                                   |

## 1.5 微服务架构的好处和弊端

### 1.5.1 微服务架构的好处

微服务架构有如下好处：

- 使大型的复杂应用程序可以持续交付和持续部署。
  - 它拥有持续交付和持续部署所需要的可测试性。
  - 它拥有持续交付和持续部署所需要的可部署性。
  - 它使开发团队能够自主且松散耦合。
- 每个服务都相对较小并容易维护。
- 服务可以独立部署。
- 服务可以独立扩展。
- 微服务架构可以实现团队的自治。
- 更容易实验和采纳新的技术。
- 更好的容错性。

### 1.5.2 微服务架构的弊端

微服务架构的主要弊端和问题如下：

- 服务的拆分和定义是一项挑战。
- 分布式系统带来的各种复杂性，使开发、测试和部署变得更困难。
- 当部署跨越多个服务的功能时需要谨慎地协调更多开发团队。
- 开发者需要思考到底应该在应用地什么阶段使用微服务架构。

# 第2章 服务的拆分策略

## 2.1 微服务架构到底是什么

### 2.1.1 软件架构是什么，为什么它如此重要

> 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。
>
> ——Bass等著《Documenting Software Architectures: Views and Beyond》

这显然是一个非常抽象的定义。但其实质是应用程序的架构是将软件分解为元素（element）和这些元素之间的关系（relation）。

### 2.1.2 什么是架构的风格

#### 分层式架构风格

架构的典型例子是分层架构。**分层架构**将软件元素按“层”的方法组织。每个层都有明确定义的职责。分层架构还限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层（如果严格分层）或其下面的任何层。

可以将分层架构应用于前面讨论的四个视图中的任何一个。流行的三层架构是应用于逻辑视图的分层架构。它将应用程序的类组织到以下层中：

- **表现层**：包含实现用户界面或外部API的代码。
- **业务逻辑层**：包含业务逻辑。
- **数据持久化层**：实现与数据库交互的逻辑。

分层架构是架构风格的一个很好的例子，但它确实有一些明显的弊端：

- **单个表现层**：它无法展现应用程序可能不仅仅由单个系统调用的事实。
- **单一数据持久化层**：它无法展现应用程序可能与多个数据库进行交互的事实。
- **将业务逻辑层定义为依赖于数据持久化层**：理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑。

此外，分层架构错误地表示了精心设计的应用程序中的依赖关系。业务逻辑通常定义数据访问方法的接口或接口库。数据持久化层则定义了实现存储库接口的DAO类。换句话说，依赖关系与分层架构所描述的相反。

让我们看一下克服这些弊端的替代架构：六边形架构。

#### 关于架构风格的六边形

**六边形架构**是分层架构风格的替代品。六边形架构风格选择以业务逻辑为中心的方式组织逻辑视图。应用程序具有一个或多个**入站适配器**，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。同样，应用程序具有一个或多个**出站适配器**，而不是数据持久化层，这些出站适配器由业务逻辑调用并调用外部应用程序。此架构的一个关键特性和优点是业务逻辑不依赖于适配器。相反，各种适配器都依赖业务逻辑。

业务逻辑具有一个或多个端口（port）。**端口**定义了一组操作，关于业务逻辑如何与外部交互。例如，在Java中，端口通常是Java接口。有两种端口：入站和出站端口。

入站端口是业务逻辑公开的API，它使外部应用程序可以调用它。入站端口的一个实例是服务接口，它定义服务的公共方法。

出站端口是业务逻辑调用外部系统的方式。出站端口的实例是存储器接口，它定义数据访问操作的集合。

业务逻辑的周围是适配器。与端口一样，有两种类型的适配器：入站和出站。入站适配器通过调用入站端口来处理外部世界的请求。入站适配器的一个实例是Spring MVC Controller，它实现一组REST接口（endpoint）或一组Web页面。另一个实例是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。

出站适配器实现出站端口，并通过调用外部应用程序或服务处理来自业务逻辑的请求。出站适配器的一个实例是实现访问数据库的操作的**数据访问对象**（DAO）类。另一个实例是调用远程服务的代理类。出站适配器也可以发布事件。

六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开来。业务逻辑不依赖于表示层逻辑或数据访问层逻辑。



分层架构和六边形架构都是架构风格的实例。每个都定义了架构的构建块（元素），并对它们之间的关系施加了约束。六边形架构和分层架构（三层架构）构成了软件的逻辑视图。

### 2.1.3 微服务架构是一种架构风格

微服务架构也是一种架构风格。它的实现视图由多个组件构成：一组可执行文件或WAR文件。它的组件是服务，连接器是使这些服务能够协作的通信协议。每个服务都有自己的逻辑视图架构，通常也是六边形架构。

#### 什么是服务

**服务**是一个单一的、可独立部署的软件组件，它实现了一些有用的功能。服务具有API，为其客户端提供对功能的访问。有两种类型的操作：命令和查询。API由命令、查询和事件组成。

服务的API封装了其内部的实现。

#### 什么是松耦合

微服务架构的最核心特性是服务之间的松耦合性。服务之间的交互采用API完成，这样做就封装了服务的实现细节。这允许服务在不影响客户端的情况下，对实现方式做出修改。松耦合服务是改善开发效率、提升可维护性和可测试性的关键。

#### 共享类库的角色

#### 服务的大小并不重要

## 2.2 为应用程序定义微服务架构

本节我们将介绍一种定义应用程序架构的三步式流程

- 应用程序是用来处理客户端请求的，因此定义其架构的第一步是将应用程序的需求提炼为各种关键请求。**系统操作**（system operation）是应用程序必须处理的请求的一种抽象描述。
- 该流程的第二步是确定如何分解服务。
- 定义应用程序架构的第三步是确定每个服务的API。



服务的分解有几个障碍需要克服。

- 首先是网络延迟。
- 分解的另一个障碍是服务之间的同步通信降低了可用性。
- 第三个障碍是需要维护跨服务的数据一致性。
- 分解的第四个也是最后一个障碍是所谓的上帝类（God Class），它广泛应用在整个应用程序中。

### 2.2.1 识别系统操作

定义应用程序架构的第一步是定义系统操作。起点是应用程序的需求，包括用户故事及其相关的用户场景。使用图2-6中所示的两步式流程识别和定义系统操作。第一步创建由关键类组成的抽象领域模型，这些关键类提供用于描述系统操作的词汇表。第二步确定系统操作，并根据领域模型描述每个系统操作的行为。

#### 创建抽象领域模型

#### 定义系统操作

有以下两种类型的系统操作。

- **命令型**：创建、更新或删除数据的系统操作。
- **查询型**：查询和读取数据的系统操作。

### 2.2.2 根据业务能力进行服务拆分

### 2.2.3 根据子域进行服务拆分

Eric Evans在他的经典著作中提出的领域驱动设计是构建复杂软件的方法论，这些软件通常都以面向对象和领域模型为核心。**领域模型**以解决具体问题的方式包含了一个领域内的知识。它定义了当前领域相关团队的词汇表，DDD也称之为**通用语言**（Ubiquitous language）。

领域模型会被紧密地映射到应用的设计和实现环节。在微服务架构的设计层面，DDD有两个特别重要的概念，子域和限量上下文。

领域驱动为每一个子域定义单独的领域模型。子域是**领域**的一部分，领域是DDD中用来描述应用程序问题域的一个术语。识别子域的方式跟识别业务能力一样：分析业务并识别业务的不同专业领域，分析产出的子域定义结果也会跟业务能力非常接近。

DDD把领域模型的边界称为**限界上下文**（bounded context）。限界上下文包括实现这个模型的代码集合。当使用微服务架构时，每一个限界上下文对应一个或者一组服务。

换一种说法，我们可以通过DDD的方式定义子域，并把子域对应为每一个服务，这样就完成了微服务架构的设计工作。



DDD和微服务架构简直就是天生一对。DDD的子域和限界上下文的概念，可以很好地跟微服务架构中地服务进行匹配。而且，微服务架构中的自治化团队负责服务开发的概念，也跟DDD中每个领域模型都由一个独立团队负责开发的概念吻合。更有趣的是，子域用于它自己的领域模型这个概念，为消除上帝类和优化服务拆分提供了好办法。

按子域分解和按业务能力分解是定义应用程序的微服务架构的两种主要模式。但是，也有一些有用的拆分指导原则源于面向对象的设计。我们来详细讨论这些原则。

### 2.2.4 拆分的指导原则

第一个原则就是定义类的职责时，应该遵循单一职责原则（Single Responsibility Principle，SRP）。第二个原则是把类组成包时，应该遵循闭包原则（Common Closure Principle，CCP）。

#### 单一职责原则

软件架构和设计的主要目标之一是确定每个软件元素的职责。单一职责原则如下：

> 改变一个类应该只有一个理由。 ——Robert C. Martin

遵照SRP原则，你所定义的每一个类都应该只有一个职责，因此也就只有一个理由对它进行修改。

#### 闭包原则

另外一个有用的原则是闭包原则（CCP）：

> 在包中包含的所有类应该是对同类的变化的一个集合，也就是说，如果对包做出修改，需要调整的类应该都在这个包之内。
>
> ——Robert C. Martin

在微服务架构下采用CCP原则，这样我们就能把根据同样原因进行变化的服务放在一个组件内。这样做可以控制服务的数量，当需求发生变化时，变更和部署也更加容易。理想情况下，一个变更只会影响一个团队和一个服务。CCP是解决分布式单体这种可怕的反模式的法宝。



单一职责原则和闭包原则是Bob Martin制定的十一项原则中的两项。它们在开发微服务架构时特别有用。在设计类和包时可以使用其余的九个原则。

### 2.2.5 拆分单体应用为服务的难点

你可能会遇到几个障碍：

- 网络延迟
- 同步进程间通信导致可用性降低
- 在服务之间维持数据一致性
- 获取一致的数据视图
- 上帝类阻碍了拆分

# 第3章 微服务架构中的进程间通信

## 3.1 微服务架构中的进程间通信概述

有很多进程间通信技术可供开发者选择。服务可以使用基于同步请求/响应的通信机制，例如HTTP REST或gRPC。另外，也可以使用异步的基于消息的通信机制，比如AMQP或STOMP。消息的格式也不尽相同。服务可以使用具备可读性的格式，比如基于文本的JSON或XML。也可以使用更加高效的、基于二进制的Avro或Protocol Buffer格式。

### 3.1.1 交互方式

有多种客户端与服务的交互方式。如表3-1所示，它们可以分为两个维度。第一个维度关注的是一对一和一对多。

- **一对一**：每个客户端请求由一个服务实例来处理。
- **一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

- **同步模式**：客户端请求需要服务端实时响应，客户端等待响应时可能导致堵塞。
- **异步模式**：客户端请求不会阻塞进程，服务端的响应可以是非实时的。

|          | 一对一                      | 一对多                       |
| -------- | --------------------------- | ---------------------------- |
| 同步模式 | 请求/响应                   | 无                           |
| 异步模式 | 异步请求/响应<br />单向通知 | 发布/订阅<br />发布/异步响应 |

### 3.1.2 在微服务架构中定义API

API或接口是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能同时隐藏实现的细节。因此，这些实现的细节可以被修改，而接口保持不变，这样就不会对客户端产生影响。

无论选择哪种进程间通信机制，使用某种**接口定义语言**（IDL）精确定义服务的API都很重要。

### 3.1.3 API的演化

#### 语义化版本控制

语义化版本控制规范为API版本控制提供了有用的指导。它是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。语义化版本控制最初的目的是软件包的版本控制，但你可以将其用在分布式系统中对API进行版本控制。

语义化版本控制规范（Semvers）要求版本号由三部分组成：MAJOR、MINOR、PATCH。必须按如下方式递增版本号：

- MAJOR：当你对API进行不兼容的更改时。
- MINOR：当你对API进行向后兼容的增强时。
- PATCH：当你进行向后兼容的错误修复时。

#### 进行次要并且向后兼容的改变

理想情况下，你应该努力只进行向后兼容的更改。向后兼容的更改是对API的附加更改或功能增强：

- 添加可选属性。
- 向响应添加属性。
- 添加新操作。

#### 进行主要并且不向后兼容的改变

如果你使用的是基于HTTP的进程间通信机制，例如REST，则一种方法是在URL中嵌入主要版本号。例如，版本1路径以`/v1/...`为前缀，而版本2路径以`/v2/...`为前缀。

另一种选择是使用HTTP的内容协商机制，并在MIME类型中包含版本号。

### 3.1.4 消息的格式

消息的格式可以分为两大类：文本和二进制。我们来逐一分析。

#### 基于文本的消息格式

第一类是JSON和XML这样的基于文本的格式。这类消息格式的好处在于，它们的可读性很高，同时也是自描述的。JSON消息是命名属性的集合。相似地，XML消息也是命名元素和值的集合。这样的格式允许消息的接收方只挑选他们感兴趣的值，而忽略掉其他。

使用基于文本格式消息的弊端主要是消息往往过度冗长，特别是XML。消息的每一次传递都必须反复包含除了值以外的属性名称，这样会造成额外的开销。另一个弊端是解析文本引入的额外开销，尤其是在消息较大的时候。因此，在对效率和性能敏感的场景下，你可能需要考虑基于二进制格式的消息。

#### 二进制消息格式

有几种不同的二进制格式可供选择。常用的包括Protocol Buffers和Avro。这两种格式都提供了一个强类型定义的IDL（接口描述文件），用于定义消息的格式。编译器会自动根据这些格式生成序列化和反序列化的代码。

## 3.2 基于同步远程过程调用模式的通信

图3-1显示了远程过程调用的工作原理。客户端中的业务逻辑调用**代理接口**，这个接口由**远程过程调用代理**适配器类实现。**远程过程调用代理**向服务发出请求。该请求由**远程过程调用服务器**适配器类处理，该类通过接口调用服务的业务逻辑。然后它将回复发送回**远程过程调用代理**，该代理将结果返回给客户端的业务逻辑。

**代理接口**通常封装底层通信协议。有很多协议可供选择。在本节中，我将介绍REST和gRPC。

### 3.2.1 使用REST

REST是一种（总是）使用HTTP协议的进程间通信机制，REST之父Roy Fielding曾经说过：

> REST提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。

REST中的一个关键概念是**资源**，它通常表示单个业务对象，例如客户或产品，或业务对象的集合。REST使用HTTP动词来操作资源，使用URL引用这些资源。

#### REST成熟度模型

Leonard Richardson为REST定义了一个成熟度模型，具体包含以下四个层次。

- Level 0：Level 0层级服务的客户端只是向服务端点发起HTTP POST请求，进行服务调用。每个请求都指明了需要执行的操作、这个操作针对的目标（例如，业务对象）和必要的参数。
- Level 1：Level 1层级的服务引入了资源的概念。要执行对资源的操作，客户端需要发出指定要执行的操作和包含任何参数的POST请求。
- Level 2：Level 2层级的服务使用HTTP动词来执行操作，譬如GET表示获取、POST表示创建、PUT表示更新。请求查询参数和主体（如果有的话）指定操作的参数。这让服务能够借助Web基础设施服务，例如通过CDN来缓存GET请求。
- Level 3：Level 3层级的服务基于HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是在由GET请求返回的资源信息中包含链接，这些链接能够执行该资源允许的操作。HATEOAS的优点包括无须在客户端代码中写入硬链接的URL。此外，由于资源信息中包含可允许操作的链接，客户端无须猜测在资源的当前状态下执行何种操作。

#### 定义REST API

如前面3.1节所述，你必须使用接口定义语言（IDL）定义API。与旧的通信协议（如CORBA和SOAP）不同，REST最初没有IDL。幸运的是，开发者社区重新发现了RESTful API的IDL价值。最流行的REST IDL是Open API规范，它是从Swagger开源项目发展而来的。Swagger项目是一组用于开发和记录REST API的工具。它包括从接口定义到生成客户端桩（stub，存根）和服务器骨架的一整套工具。

#### 在一个请求中获取多个资源的挑战

此问题的一个解决方案是API允许客户端在获取资源时检索相关资源。

#### 把操作映射为HTTP动词的挑战

另一个常见的REST API设计问题是如何将要在业务对象上执行的操作映射到HTTP动词。REST API应该使用PUT进行更新，但可能有多种方法来更新订单，包括取消订单、修改订单等。此外，更新可能不是幂等的，但这却是使用PUT的要求。一种解决方案是定义用于更新资源的特定方面的子资源。另一种解决方案是将动词指定为URL的查询参数。可惜的是，这两种解决方案都不是特别符合RESTful的要求。

映射操作到HTTP动词的这个问题导致了REST替代方案的日益普及，例如gRPC，我将在3.2.2节中讨论这项技术。

#### REST 的好处和弊端

REST有如下好处：

- 它非常简单，并且大家都很熟悉。
- 可以使用浏览器扩展（比如Postman插件）或者curl之类的命令行（假设使用的是JSON或其他文本格式）来测试HTTP API。
- 直接支持请求/响应方式的通信。
- HTTP对防火墙友好。
- 不需要中间代理，简化了系统结构。

它也存在一些弊端：

- 它只支持请求/响应方式的通信。
- 可能导致可用性降低。由于客户端和服务直接通信而没有代理来缓冲消息，因此它们必须在REST API调用期间都保持在线。
- 客户端必须知道服务实例的位置（URL）。如3.2.4节所述，这是现代应用程序中的一个重要问题。客户端必须使用所谓的**服务发现机制**来定位服务实例。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到HTTP动词。

### 3.2.2 使用gRPC

如上一节所述，使用REST的一个挑战是，由于HTTP仅提供有限数量的动词，因此设计支持多个更新操作的REST API并不总是很容易。避免此问题的进程间通信技术是gRPC，这是一个用于编写跨语言客户端和服务端的框架。gRPC是一种基于二进制消息的协议，你不得不采用API优先的方法来进行服务设计。你可以使用基于Protocol Buffer的IDL定义gRPC API，这是谷歌公司用于序列化结构化数据的一套语言中立机制。

gRPC API由一个或多个服务和请求/响应消息定义组成。**服务定义**类似于Java接口，是强类型方法的集合。除了支持简单的请求/响应RPC之外，gRPC还支持流式RPC。服务器可以使用消息流回复客户端。客户端也可以向服务器发送消息流。

gRPC使用Protocol Buffers作为消息格式。

gRPC有几个好处：

- 设计具有复杂更新操作的API非常简单。
- 它具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和信息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种语言编写的服务端之间的互操作性。

gRPC也有几个弊端：

- 与基于REST/JSON的API机制相比，JavaScript客户端使用基于gRPC的API需要做更多的工作。
- 旧式防火墙可能不支持HTTP/2。

gRPC是REST的一个引人注目的替代品，但与REST一样，它是一种同步通信机制，因此它也存在局部故障的问题。

### 3.2.3 使用断路器模式处理局部故障

分布式系统中，当服务试图向另一个服务发送同步请求时，永远都面临着局部故障的风险。因为客户端和服务端是独立的进程，服务端很有可能无法在有限的时间内对客户端的请求做出响应。服务端可能因为故障或维护的原因而暂停。或者，服务端也可能因为过载而对请求的响应变得极其缓慢。

客户端等待响应而被阻塞，这可能带来的麻烦是在其他客户端甚至使用服务的第三方应用之间传导，并导致服务中断。

要通过合理地设计服务来防止在整个应用程序中故障的传导和扩散，这是至关重要的。解决这个问题分为两部分：

- 必须让远程过程调用代理有正确处理无响应服务的能力。
- 需要决定如何从失败的远程服务中恢复。

#### 开发可靠的远程过程调用代理

每当一个服务同步调用另一个服务时，它应该使用Netflix描述的方法来保护自己。这种方法包括以下机制的组合。

- **网络超时**：在等待针对请求的响应时，一定不要做成无限阻塞，而是要设定一个超时。使用超时可以保证不会一直在无响应的请求上浪费资源。
- **限制客户端向服务器发出请求的数量**：把客户端能够向特定服务发起的请求设置一个上限，如果请求达到了这样的上限，很有可能发起更多的请求也无济于事，这时就应该让请求立刻失败。
- **断路器模式**：监控客户端发出请求的成功和失败数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失效。如果大量的请求都以失败而告终，这说明被调服务不可用，这样即使发起更多的调用也是无济于事。在经过一定的时间后，客户端应该继续尝试，如果调用成功，则解除断路器。

#### 从服务失效故障中恢复

使用诸如Hystrix之类的库只是解决方案的一部分。你还必须根据具体情况决定如何从无响应的远程服务中恢复你的服务。一种选择是服务只是向其客户端返回错误。

在其他情况下，返回备用值（fallback value，例如默认值或缓存响应）可能会有意义。

### 3.2.4 使用服务发现

服务实例具有动态分配的网络位置。此外，由于自动扩展、故障和升级，服务实例集会动态更改。因此，你的客户端代码必须使用服务发现。

#### 什么是服务发现

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。（我将在第12章中详细讨论这一点。）

#### 应用层服务发现模式

实现服务发现的一种方法是应用程序的服务及其客户端与服务注册表进行交互。服务实例使用服务注册表注册其网络位置。客户端首先通过查询服务注册表获取服务实例来调用服务，然后它向其中一个实例发送请求。

这种服务发现方法是两种模式的组合。第一种模式是自注册模式。服务实例调用服务注册表的注册API来注册其网络位置。它还可以提供运行状态检查URL，在第11章中有更详细的描述。**运行状态检查**URL是一个API端点，服务注册表会定期调用该端点来验证服务实例是否正常且可用于处理请求。服务注册表还可能要求服务实例调用“心跳”API以防止其注册过期。

> **模式：自注册**
>
> 服务实例向服务注册表注册自己。

第二章模式是客户端发现模式。当客户端想要调用服务时，它会查询服务注册表以获取服务实例的列表。为了提高性能，客户端可能会缓存服务实例。然后，客户端使用负载平衡算法（例如循环或随机）来选择服务实例。然后它向选择的服务实例发出请求。

> **模式：客户端发现**
>
> 客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载平衡。

Netflix和Pivotal在应用层服务发现方面做了大量普及工作。Netflix开发并开源了几个组件，包括：Eureka，这是一个高可用的服务注册表；Eureka Java 客户端；Ribbon，这是一个支持Eureka客户端的复杂HTTP客户端。Pivotal开发了Spring Cloud，这是一个基于Spring的框架，使得Netflix组件的使用非常简单。基于Spring Cloud的服务自动向Eureka注册，基于Spring Cloud的客户端因此可以自动使用Eureka进行服务发现。

应用层服务发现的一个好处是它可以处理多平台部署的问题（服务发现机制与具体的部署平台无关）。

应用层服务发现的一个弊端是：你需要为你使用的每种编程语言（可能还有框架）提高服务发现库。Spring Cloud只能帮助Spring开发人员。如果你正在使用其他Java框架或非JVM语言（如Node.js或GoLang），则必须找到其他一些服务发现框架。

应用层服务发现的另一个弊端是开发者负责设置和管理服务注册表，这会分散一定的精力。因此，最好使用部署基础设施提供的服务发现机制。

#### 平台层服务发现模式

在第12章中，你将了解许多现代部署平台（如Docker和Kubernetes）都具有内置的服务注册表和服务发现机制。部署平台为每个服务提供DNS名称、虚拟IP（VIP）地址和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此，服务注册、服务发现和请求路由完全由部署平台处理。

部署平台包括一个服务注册表，用于跟踪已部署服务的IP地址。

这种方法是一下两种模式的组合：

- **第三方注册模式**：由第三方负责（称为**注册服务器**，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。
- **服务端发现模式**：客户端不再需要查询服务注册表，而是向DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。

> **模式：第三方注册**
>
> 服务实例由第三方自动注册到服务注册表。
>
> **模式：服务端发现**
>
> 客户端向路由器发出请求，路由器负责服务发现。

由平台提供服务发现机制的主要好处是服务发现的所有方面都完全由部署平台处理。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。

平台提供服务发现机制的一个弊端是它仅限于支持使用该平台部署的服务。例如，如前所述，在描述应用程序级别发现时，基于Kubernetes的发现仅适用于在Kubernetes上运行的服务。尽管存在此限制，我建议尽可能使用平台提供的服务发现。

## 3.3 基于异步消息模式的通信

使用消息机制时，服务之间的通信采用异步交换信息的方式完成。基于消息机制的应用程序通常使用**消息代理**，它充当服务之间的中介。另一种选择是使用无代理架构，通过直接向服务发送消息来执行服务请求。服务客户端通过向服务发送消息来发出请求。如果希望服务实例回复，服务将通过向客户端发送单独的消息的方式来实现。由于通信是异步的，因此客户端不会堵塞和等待回复。相反，客户端都假定回复不会马上就收到。

> **模式：消息**
>
> 客户端使用异步消息调用服务。

### 3.3.1 什么是消息传递

Gregor Hohpe和Bobby Woolf在《Enterprise Integration Patterns》一书中定义了一种有用的消息传递模型。在此模型中，消息通过消息通道进行交换。发送方（应用程序或服务）将消息写入通道，接收方（应用程序或服务）从通道读取消息。

#### 关于消息

消息由消息头部和消息主体组成。**标题**是名称与值对的集合，描述正在发送的数据的元数据。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息，例如发件人或消息传递基础设施生成的**唯一消息ID**，以及可选的**返回地址**，该地址指定发送回复的消息通道。消息**正文**是以文本或二进制格式发送的数据。

有以下几种不同类型的消息。

- **文档**：仅包含数据的通用信息。接收者决定如何解释它。对命令式消息的回复是文档消息的一种使用场景。
- **命令**：一条等同于RPC请求的消息。它指定要调用的操作及其参数。
- **事件**：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象的状态更改。

在本书描述的微服务架构实践中大量使用了命令式消息和事件式消息。

#### 关于消息通道

消息通过消息通道进行交换。发送方中的业务逻辑调用**发送端**接口，该接口封装底层通信机制。**发送端**由**消息发送**适配器类实现，该消息发送适配器类通过消息通道向接受器发送消息。**消息通道**是消息传递基础设施的抽象。调用接收器中的**消息处理程序**适配器类来处理消息。它调用接收方业务逻辑实现的**接收端接口**。任意数量的发送方都可以向通道发送消息。类似地，任意数量的接收方都可以从通道接收消息。

有以下两种类型的消息通道：点对点和发布-订阅。

- **点对点通道**向正在从通道读取的一个消息者传递消息。服务使用点对点通道来实现前面描述的一对一交互方式。例如，命令式消息通常通过点对点通道发送。
- **发布-订阅**通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多交互方式。例如，事件式消息通常通过发布-订阅通道发送。

### 3.3.2 使用消息机制实现交互方式

消息机制的一个有价值的特性是它足够灵活，可以支持3.1.1节描述的所有交互方式。一些交互方式通过消息机制直接实现。其他必须在消息机制之上实现。

#### 实现请求/响应和异步请求/响应

#### 实现单向通知

#### 实现发布/订阅

#### 实现发布/异步响应

### 3.3.3 为基于消息机制的服务API创建API规范

### 3.3.4 使用消息代理

#### 无代理消息

ZeroMQ

无代理的架构有以下一些好处：

- 运行更轻的网络流量和更低的延迟，因为消息直接从发送方发送到接收方，而不必从发送方到消息代理，再从代理转发到接收方。
- 消除了消息代理可能成为性能瓶颈或单点故障的可能性。
- 具有较低的操作复杂性，因为不需要设置的维护消息代理。

尽管这些好处看起来很吸引人，但无代理的消息具有以下明显的弊端：

- 服务需要了解彼此的位置，因此必须使用3.2.4节中描述的服务发现机制。
- 会导致可用性降低，因为在交换消息时，消息的发送方和接收方都必须同时在线。
- 在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。

#### 基于代理的消息

Apache ActiveMQ

RabbitMQ

Apache Kafka

还有基于云的消息服务，例如AWS kinesis和AWS SQS。

选择消息代理时，你需要考虑以下各种因素：

- **支持的编程语言**：你选择的消息代理应该支持尽可能多的编程语言。
- **支持的消息标准**：消息代理是否支持多种消息标准，比如AMQP和STOMP，还是它仅支持专用的消息标准？
- **消息排序**：消息代理是否能够保留消息的排序？
- **投递保证**：消息代理提供什么样的消息投递保证？
- **持久性**：消息是否持久化保存到磁盘并且能够在代理崩溃时恢复？
- **耐久性**：如果接收方重新连接到消息代理，它是否会收到断开连接时发送的消息？
- **可扩展性**：消息代理的可扩展性如何？
- **延迟**：端到端是否有较大延迟？
- **竞争性（并发）接收方**：消息代理是否支持竞争性接收方？

#### 使用消息代理实现消息通道

每个消息代理都用自己与众不同的概念来实现消息通道。如表3-2所示，ActiveMQ等JMS消息代理具有队列和主题。基于AMQP的消息代理（如RabbitMQ）具有交换和队列。Apache Kafka有主题，AWS Kinesis有流，AWS SQS有队列。更重要的是，一些消息代理提供了比本章中描述的信息和通道更灵活的消息机制。

| 消息代理                   | 点对点通道 | 发布-订阅通道            |
| -------------------------- | ---------- | ------------------------ |
| JMS                        | 队列       | 主题                     |
| Apache Kafka               | 主题       | 主题                     |
| 基于AMQP的代理，如RabbitMQ | 交换+队列  | 组播式交换和每客户端队列 |
| AWS Kinesis                | 流         | 流                       |
| AWS SQS                    | 队列       | /                        |

这里描述的几乎所有消息代理都支持点对点和发布-订阅通道。唯一的例外是AWS SQS，它仅支持点对点通道。

#### 基于代理的消息的好处和弊端

使用消息由以下很多好处。

- **松耦合**：客户端发起请求时只要发送给特定的通道即可，客户端完全不需要感知服务实例的情况，客户端不需要使用服务发现机制去获得服务实例的网络位置。
- **消息缓存**：消息代理可以在消息被处理之前一直缓存消息。像HTTP这样的同步请求/响应协议，在交换数据时，发送方和接收方必须同时在线。然而，在使用消息机制的情况下，消息会在队列中缓存，直到它们被接收方处理。
- **灵活的通信**：消息机制支持前面提到的所有交互方式。
- **明确的进程间通信**：基于RPC的机制总是企图让远程服务调用跟本地调用看上去没有什么区别（在客户端和服务端同时使用远程调用代理）。然而，因为物理定律（如服务器不可预计的硬件失败）和可能的局部故障，远程和本地调用还是大相径庭的。消息机制让这些差异变得很明确，这样程序员不会陷入一种“太平盛世”的错觉。

然而，消息机制也有如下一些弊端。

- **潜在的性能瓶颈**：消息代理可能存在性能瓶颈。幸运的是，许多现代消息代理都支持高度的横向扩展。
- **潜在的单点故障**：消息代理的高可用性至关重要，否则系统整体的可靠性将受到影响。幸运的是，大多数现代消息代理都是高可用的。
- **额外的操作复杂性**：消息系统是一个必须独立安装、配置和运维的系统组件。

### 3.3.5 处理并发和消息顺序

