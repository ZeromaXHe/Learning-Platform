# 第1章 对象导论

面向程序设计（Object-oriented Programming，OOP）

## 1.1 抽象过程

汇编语言是对底层机器的轻微抽象。

接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。这些语言在汇编语言基础上有了大幅的改进，但是它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。

另一种对机器建模的方式就是对待解问题建模。早期的编程语言，如LISP和APL，都选择考虑世界的某些特定视图（分别对应于“所有问题最终都是列表”或者“所有问题都是算法格式的”）。PROLOG则将所有问题都转换成决策链。此外还产生了基于约束条件编程的语言和专门通过对图形符号操作来实现编程的语言（后者被证明限制性过强）。这些方式对于它们所要解决的特定类型的问题都是不错的解决方案，但是一旦超出其特定领域，它们就力不从心了。

面向对象方式通过向程序员提供表示问题空间的元素的工具而更进了一步。这种表示方式十分通用，使得程序员不会受限于任何特定类型的问题。我们将问题空间中的元素及其在解空间的表示称为“对象”。（你还需要一些无法类比为问题空间元素的对象。）这种思想的实质是：程序可以通过添加新类型的对象使自身适用于某个特定问题。

Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于语言之一的**Smalltalk**的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：

**1）万物皆为对象**。

**2）程序是对象的集合，它们通过发送消息来告知彼此所要做的。**要想请求一个对象，就必须对该对象发送一条消息。更具体的说，可以把消息想象为对某个特定对象的方法的调用请求。

**3）每一个对象都有自己的由其他对象所构成的存储。**换句话说，可以创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。

**4）每个对象都拥有其类型。**按照通用的说法，“每个对象都是某个**类（class）**的一个**实例（instance）**”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”。

**5）某一特定类型的所有对象都可以接受同样的消息。**这是一句意味深长的表述，你在稍后便会看到。因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种**可替代性（substitutability）**是OOP中最强有力的概念之一。



Booch对对象提出了一个更加简洁的描述：*对象具有状态、行为和标识*。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。

## 1.2 每一个对象都有一个接口

所有的对象都是唯一的，但同时也是具有相同特性和行为的对象所归属的类的一部分。这种思想被直接应用于第一个面向对象语言Simula-67，它在程序中使用基本关键字class来引入新的类型。

**simula**，是为了开发诸如经典的“银行出纳员问题”（bank teller problem）这样的仿真程序而创建的。

在程序执行期间具有不同状态而其他方面都相似的对象会被分组到对象的类中，这就是关键字class的由来。创建抽象数据类型（类）是面向对象程序设计的基本概念之一。

因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型，例如所有浮点型数字具有相同的特性和行为集合。**二者差异**在于。程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。



每个对象都只能满足某些请求，这些请求由对象的**接口（interface）**所定义，决定接口的便是类型。

接口确定了对某一特定对象所能发出的**请求**。但是，在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了**实现**。

![1555222418639](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1555222418639.png)

UML（United Modeling Language，统一建模语言）

## 1.3 每一个对象都提供服务

当正在试图开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者”。程序本身将向用户提供服务，它将通过其他对象提供的服务来实现这一目的。你的目的就是去创建（或者最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。

将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。**高内聚**是软件设计的基本质量要求之一：这意味着一个软件构件（例如一个对象，当然它也有可能是指一个方法或一个对象库）的各个方面“组合”得很好。

## 1.4 被隐藏的具体实现

将程序开发人员按照角色分为**类创建者**（那些创建新数据类型的程序员）和**客户端程序员**（那些在其应用中使用数据类型的类消费者）是大有裨益的。客户端程序员的目标是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。

访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分——这部分对数据类型的内部操作是必需的，但并不是用户解决特定问题所需的接口的一部分。

访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。

Java用三个关键字在类的内部设定边界：**public、private、protected**。这些**访问指定词（access specifier）**决定了紧跟其后被定义的东西可以被谁使用。**public**表示紧随其后的元素对任何人都是可用的，而**private**这个关键字表示除类型创建者和类型内部方法之外任何人都不能访问的元素。**protected**关键字与private相当，差别仅在于继承的类可以访问protected成员，但是不能访问private成员。

Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为**包访问权限**，因为在这种权限下，类可以访问在同一个包（库构件）中的其他类的成员，但是在包之外，这些成员就如图制定了private一样。

## 1.5 复用具体实现

最简单的复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为**“创建一个成员对象”**。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为**组合（composition）**，如果组合是动态发生的，那么它通常被称为**聚合（aggregation）**。组合经常被视为“has-a”（拥有）关系，就像我们常说的“汽车拥有引擎”一样。

![1555222344824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1555222344824.png)

组合带来了极大的灵活性。新类的成员对象通常都被声明为private，使得使用新类的客户端程序员不能访问它们。这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员。也可以在运行时修改这些成员对象，以实现动态修改程序的行为。下面将要讨论的继承并不具备这样的灵活性，因为编译器必须对通过继承而创建的类施加编译时的限制。

实际上，在建立新类时，应该首先考虑组合，因为它更加简单灵活。如果采用这种方式，设计会变得更加清晰。一旦有了一些经验后，便能看出必须使用继承的场合了。

## 1.6 继承

如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好多了。通过**继承**便可以达到这样的效果，不过也有例外，当源类（被称为**基类**、**超类**或**父类**）发生变动时，被修改的“副本”（被称为**导出类**、**继承类**或**子类**）也会反映出这些变动。

![1555222360399](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1555222360399.png)

类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性，并且可以处理更多的信息（或以不同的方式来处理消息）。继承使用基类型和导出类型的概念表示了这种类型之间的相似性。一个基类型包含其所有导出类型所共享的特性和行为。

当继承现有类型时，也就创造了新的类型。这个新类型不仅包括现有类型的所有成员（尽管private成员被隐藏了起来，而且不可访问），而且更重要的是它复制了基类的接口。所以这也就意味着导出类**与基类具有相同的类型**。

有两种方法可以使基类与导出类产生差异。第一种方法非常直接：直接在导出类中添加新方法。这些新方法不是基类接口的一部分。

虽然继承有时可能意味着在接口中添加新方法（尤其是在以extends关键字表示继承的Java中），但并非总需如此。第二种也是更重要的一种是改变现有基类的方法的行为，这被称之为**覆盖（overriding）**那个方法。

### 1.6.1 “是一个”与“像是一个”关系

对于继承可能会引发某种争论：继承应该只覆盖基类的方法（而并不添加在基类中没有的新方法）吗？如果这样做，就意味着导出类和基类是完全相同的类型，因为它们具有完全相同的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为**纯粹替代**，通常称之为**替代原则**。在某种意义上，这是一种处理继承的理想方式。我们将这种情况下的基类与导出类之间的关系成为**is-a（是一个）关系**。判断是否继承，就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。

有时必须在导出类型中添加新的接口元素，这样也就扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况我们可以描述为**is-like-a（像是一个）关系**。新类型具有旧类型的接口，但是它还包含其他方法，所以不能说它们完全相同。

当你看到替代原则时，很容易会认为这种方式（纯粹替代）是唯一可行的方式，而且事实上，用这种方式设计是很好的。但是你会时常发现，同样显然的是你必须在导出类的接口中添加新方法。只要仔细审视，两种方法的使用场合应该是相当明显的。

## 1.7 伴随多态的可互换对象

在处理类型的层次结构时，经常想把一个对象不当做它所属的特定类型来对待，而是将其当作其基类的对象来对待。这使得人们可以编写出不依赖于特定类型的代码。方法操作的都是**泛化（generic）**的形状。

这样的代码是不会受添加新类型影响的，而且添加新类型是扩展一个面向对象程序以便处理新情况的最常用方式。通过导出新的子类型而轻松扩展设计的能力是对改动进行封装的基本方式之一。这种能力可以极大地改善我们的射击，同时也降低软件维护的代价。

试图将导出类的对象当做其泛化基类型对象来看待时，仍然存在一个问题：如果某个方法要操作某个泛化的类，编译器无法精确地了解哪一段代码将被执行。

这个问题的答案，也就是面向对象程序设计的最重要的妙诀：编译器不可能产生传统意义上的函数调用。一个非面向对象编程的编译器产生的函数调用会引起所谓的**前期绑定**。这么做意味着编译器将产生一个具体函数名字的调用，而运行时将这个调用解析到将要执行代码的绝对地址。然而在OOP中，程序直到运行时才能够确定代码的地址，所以当消息发送到一个泛化对象时，必须采用其他的机制。

为了解决这个问题，面向对象程序设计语言使用了**后期绑定**的概念。当对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言被称为是弱类型的），但是并不知道将被执行的确切代码。

为了执行后期绑定，Java使用一小段特殊代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址（这个过程将在第8章中详述）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。

在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性（C++是使用**virtual**关键字来实现的）。在这些语言中，方法在默认情况下不是动态绑定的。而这Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。

把将导出类看作是它的基类的过程称为**向上转型（upcasting）**。**转型（cast）**这个名称的灵感来自于模型铸造的塑模动作；而**向上（up）**这个词来源于继承图的典型布局方式：通常基类在顶部，而导出类在其下部三开。因此，转型为一个基类就是在继承图中向上移动，即“向上转型”。

一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。

## 1.8 单根继承结构

在OOP中，自C++面世以来就已变得非常瞩目的一个问题就是，是否所有的类最终都继承自单一的基类。在Java中（事实上还包括除C++以外的所有OOP语言），答案是yes，这个终极基类的名字就是Object。事实证明，单根继承结构带来了很多好处。

在单根继承结构中的所有对象都具有一个公共接口，所以它们归根到底都是相同的基本类型。另一种（C++所提供的）结构是无法确保所有对象都属于同一个基本类型。从向后兼容的角度看，这么做能够更好地适应C模型，而且受限较少，但是当要进行完全的面向对象程序设计时，则必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在所获得的任何新类库中，总会用到些不兼容的接口，需要花力气（有可能要通过多重继承）来使新接口融入你的设计之中。这么做来换取C++额外的灵活性是否值得呢？如果需要的话——如果在C上面投资巨大，这么做就很有价值。如果是刚刚从头开始，那么像Java这样的选择通常会有更高的生产率。

单根继承结构保证所有对象都具备某些功能。因此你知道，在你的系统中你可以在每一个对象上执行某些基本操作。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。

单根继承结构使垃圾回收器的实现变得容易得多，而垃圾回收器正是Java相对C++的重要改进之一。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。

## 1.9 容器

通常说来，如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢？答案是你不可能知道，因为这类信息只有在运行时才能获得。

对于面向对象射击中的大多数问题而言，这个问题的解决方案似乎过于轻率：创建另一种对象类型。这种新的对象类型持有对其他对象的引用。当然，你可以用在大多数语言中都有的数组类型来实现相同的功能。但是这个通常被称为**容器**（也称为**集合**，不过Java类库以不同的含义使用“集合”这个术语，所以本书将使用“容器”这个词）的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。

幸运的是，好的OOP语言都有一组容器，它们作为开发包的一部分。在C++中，容器是标准C++类库的一部分，经常被称为**标准模板库（Standard Template Library, STL）**。Object Pascal在其**可视化构件库（Visual Component Library, VCL）**中有容器；Smalltalk提供了一个非常完备的容器集；Java在其标准类库中也包含有大量的容器。在某些类库中，一两个通用容器足够满足所有的需要；但是在其他类库（例如Java）中，具有满足不同需要的各种类型的容器，例如List（用于存储序列），Map（也被称为关联数组，用来建立对象之间的关联），Set（每种对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件。

需要对容器有所选择，这有两个原因。第一，不同容器提供了不同类型的接口和外部行为。堆栈相比于队列就具备不同的接口和行为，也不同于集合和列表的接口和行为。它们之中的某种容器提供的解决方案可能比其他容器要灵活得多。第二，不同的容器对于某些操作具有不同的效率。最好的例子就是两种List的比较：ArrayList和LinkedList。它们都是具有相同接口和外部行为的简单的序列，但是它们对某些操作所花费的代价却有天壤之别。接口List所带来的抽象，把在容器之间进行转换时对代码的影响降到最小限度。

### 1.9.1 参数化类型

在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西（它们不能持有基本类型，但是Java SE5 的自动包装功能使得这项限制几乎不成什么问题了）。这使得容器很容易被复用。

怎样才能将向上转型成Object的对象便会先前置入容器中时的具有实用接口的对象呢？

这里再度用到了转型，向下转型为更具体的类型，这种转型的方式称为**向下转型**。除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的。当从容器中取出对象引用时，还是必须要以某种方式记住这些对象究竟是什么类型，这样才能执行正确的向下转型。

创建这样的容器，它知道自己所保存的对象的类型，从而不需要向下转型以及消除犯错误的可能，这种解决方案被称为**参数化类型机制**。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如，通过使用参数化类型，编译器可以定制一个只接纳和取出Shape对象的容器。

Java SE5的重大变化之一就是增加了参数化类型，在Java中它称为**泛型**。一对尖括号，中间包含类型信息，通过这些特征就可以识别对泛型的使用。例如，可以用下面这样的语句来创建一个存储Shape的ArrayList：

```java
ArrayList<Shape> shapes = new ArrayList<Shape>();
```

## 1.10 对象的创建和生命期

对象数据位于何处？怎样控制对象的生命周期？C++认为效率控制是最重要的议题，所以给程序员提供了选择的权力。为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定，这可以通过将对象置于**堆栈**（它们有时被称为自动变量（automatic variable）或限域变量（scoped variable））或静态存储区域内来实现。这种方式将存储空间分配和释放置于优先考虑的位置，某些情况下这样的控制非常有价值。但是，也牺牲了灵活性，因为必须在编写程序时知道对象确切的数量、生命周期和类型。

第二种是在被称为**堆（heap）**的内存池中动态地创建对象。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们具体类型是什么。因为存储空间是在运行时动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈中创建存储空间和释放存储空间通常各需要一条汇编指令即可，分别对应将堆栈指针向下移动和将栈顶指针向上移动。而创建堆存储空间的时间依赖于存储机制的射击。

动态方式有一个一般性的逻辑假设：对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。动态方式所带来的更大的灵活性正是解决一般化编程问题的要点所在。

Java完全采用了动态内存分配方式。每当想要创建新对象时，就要使用new关键字来构建此对象的动态实例。

还有一个议题，就是对象的生命周期。对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁它。然而，如果是在堆上创建对象，编译器就会对它的生命周期一无所知。在像C++这样的语言中，必须通过编程方式来确定何时销毁对象，这可能会因为不能正确处理而导致内存泄露。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，继而销毁它。垃圾回收器非常有用，因为它减少了所必须考虑的议题和必须编写的代码。更重要的是，垃圾回收器提供了更高层的保障，可以避免暗藏的内存泄露问题，这个问题已经使许多C++项目折戟沉沙。

Java的垃圾回收器被设计用来处理内存释放问题（尽管它不包括清理对象的其他方面）。垃圾回收器“知道”对象何时不再被使用，并自动释放对象占用的内存。这一点同所有对象都是继承自单根基类Object以及只能以一种方式创建对象（在堆上创建）这两个特性结合起来，使得用Java编程的过程较之用C++编程要简单得多。

## 1.11 异常处理：处理错误

异常处理将错误处理直接置于编程语言中，有时甚至置于操作系统中。异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”，不需要被迫定期检查错误。异常不能被忽略，所以它保证一定会在某处得到处理。异常提供了一种从错误状况进行可靠恢复的途径。

Java的异常处理在众多的编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它。

值得注意的是，异常处理不是面向对象的特征——尽管在面向对象语言中异常常被表示成为一个对象。异常处理在面向对象语言出现之前就已经存在了。

## 1.12 并发编程

想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立的部分称之为线程，上述概念被称为“并发”。

Java的并发是内置于语言中的。

## 1.13 Java与Internet

### 1.13.1 Web是什么

#### 1. 客户/服务器计算技术

客户/服务器（C/S）系统的核心思想是：系统具有一个中央信息存储池（central repository of information），用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。客户/服务器概念的关键在于信息存储池的位置集中于中央。信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为**服务器**。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为**客户机**的用户机器上。

**事务处理**

**中间件**

#### 2. Web就是一台巨型服务器

为了解决浏览器只是一个观察器而不能执行最简单的计算任务这个问题，首先，图形标准得到了增强，使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引入在客户端浏览器中运行程序的能力就可以解决。这被称为“客户端编程”。

### 1.13.2 客户端编程

HTML（HyperText Markup Language，超文本标记语言）

通用网关接口（common gateway interface，CGI）

Perl已经成为编写服务器中名为“cgi-bin”的目录下的程序的最常见的选择，因为它被设计用来处理文本，而且是解释型语言，因此无论服务器的处理器和操作系统如何，它都适用于安装。然而，Python已对其产生了重大的冲击，因为它更强大且更简单。

图形交互格式（graphic interchange format, GIF）

#### 1. 插件

插件（plug-in）

后门

#### 2. 脚本语言

脚本语言（scripting language）

一种脚本语言在Web浏览器不需要任何插件的情况下就可以得到支持：JavaScript（它和Java之间只存在表面上的相似，要想使用它，你必须在额外的学习曲线上攀爬。它之所以被这样命名只是因为想赶上Java潮流）。

图形化用户界面（graphic user interface,GUI）

#### 3. java

如果脚本语言可以解决客户端百分之八十的问题的话，剩下那百分之二十的难啃的硬骨头最流行的解决方案就是Java。Java不仅是一种功能强大的、安全的、跨平台的、国际化的编程语言，而且它还在不断地被扩展，以提供更多的语言功能和类库，能够优雅地处理在传统编程语言中很难解决的问题，例如并发、数据库访问、网络编程和分布式计算。Java是通过applet以及使用Java Web Start来进行客户端编程的。

**applet**是只在Web浏览器中运行的小程序，它是作为网页的一部分而自动下载的（就像网页中的图片被自动下载一样）。

#### 4. 备选方案

#### 5. .NET和C#

#### 6. Internet与Intranet

Intranet（企业内部网）

### 1.13.3 服务器端编程

Java编写被称为servlet的程序来实现服务器端编程

# 第2章 一切都是对象

尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。

C++和Java都是混合/杂合型语言。但是Java的设计者认为这种杂合性并不像C++中那么重要。杂合型语言允许多种编程风格。

## 2.1 用引用操纵对象

每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操纵对象？

所有这一切在Java里都得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操纵的标识符实际上是对象的一个“引用”（reference）（这可能会引起争论。有人认为：“很明显，它是指针”但是这种说法是基于底层实现的某种假设。并且，Java中的引用，在语法上更接近C++的引用而不是指针。）。

## 2.2 必须由你创建所有对象

### 2.2.1 存储到什么地方

有五个不同的地方可以存储数据：

1）寄存器

2）堆栈。某些java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。

3）堆

4）常量存储

5）非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序任何控制，在程序没有运行时也可以存在。其中两个基本的例子是**流对象**和**持久化对象**。在流对象中，对象转化成字节流，通常被发送给另一台机器。在“持久化对象”中，对象被存放于磁盘上。Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。

### 2.2.2 特例：基本类型

new将对象存储在“堆”里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。

| 基本类型 | 大小 |  最小值   |     最大值     | 包装器类型 |
| :------: | :--: | :-------: | :------------: | :--------: |
| boolean  |  -   |     -     |       -        |  Boolean   |
|   char   |  16  | Unicode 0 | Unicode 2^16-1 | Character  |
|   byte   |  8   |   -128    |      127       |    Byte    |
|  short   |  16  |   -2^15   |     2^15-1     |   Short    |
|   int    |  32  |   -2^31   |     2^31-1     |  Integer   |
|   long   |  64  |   -2^63   |     2^63-1     |    Long    |
|  float   |  32  |  IEEE754  |    IEEE754     |   Float    |
|  double  |  64  |  IEEE754  |    IEEE754     |   Double   |
|   void   |  -   |     -     |       -        |    Void    |

所有数值类型都有正负号，所以不要去寻找无符号的数值类型。

基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。

Java SE5的自动包装功能能将自动地将基本类型转换为包装器类型，并可以反向转换。

**高精度数字**

Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于“包装器类”的范畴，但两者都没有对应的基本类型。

不过，这两个类包含的方法，提供的操作与对基本类型所能执行的操作相似。也就是说，能作用于int或float的操作，也同样能作用于BigInteger或BigDecimal。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。（速度换取精度）

BigInteger支持任意精度的整数。

BigDecimal支持任何精度的定点数，例如，可以用它进行精确的货币计算。

### 2.2.3 Java中的数组

C和C++中使用数组是很危险的，因为C和C++中的数组就是内存块。程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，都会产生难以预料的后果。

Java的主要目标之一是安全性，所以许多在C和C++里困扰程序员的问题在Java里不会再出现。Java确保数组会被初始化，而且不能在它的范围之外被访问。这种范围检查，是以每个数组上少量内存开销及运行时的下标检查为代价的。但由此换来的是安全性和效率的提高，因此付出的代价是值得的（并且Java有时可以优化这些操作）。

当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字**null**。一旦Java看到null，就知道这个引用还没有指向某个对象。在使用任何引用前，必须为其制定一个对象；如果识图使用一个还是null的引用，在运行时将会报错。因此，常犯的数组错误在Java中就可以避免。

还可以创建用来存放基本数据类型的数组。同样，编译器也能确保这种数组的初始化，因为它会将这种数组所占的内存全部置零。

## 2.3 永远不需要销毁对象

### 2.3.1 作用域

大多数过程型语言都有作用域（scope）的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和Java中，作用域由花括号的位置决定。

在作用域里定义的变量只可用于作用域结束之前。

缩排格式使Java代码更易于阅读。由于Java是一种自由格式（free-form）的语言，所以，空格、制表符、换行都不会影响程序的执行结果。

尽管以下代码在C和C++中是合法的，但是在Java中却不能这样书写：

```java
{
    int x=12;
    {
        int x=96;//Illegal
    }
}
```

编译器将会报告变量x已经定义过。所以，在C和C++里将一个较大作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。

### 2.3.2 对象的作用域

Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。所以加入你采用代码

```java
{
    String s = new String("a string");
}//End of scope
```

引用s在作用域终点就消失了。然而，s指向的String对象仍继续占据内存空间。在这一小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范围。在后续章节中，读者将会看到：在程序执行过程中，怎样传递和复制对象引用。

事实证明，由new创建的对象，只要你需要，就会一直保留下去。这样，许多C++编程问题在Java中就完全消失了。在C++中，你不仅必须要确保对象的保留时间与你需要这些对象的时间一样长，而且还必须在你使用完它们之后，将其销毁。

如果Java让对象继续存在，那么靠什么才能防止这些对象占满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题。这也是Java神奇之所在。Java有个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。

## 2.4 创建新的数据类型：类

### 2.4.1 字段和方法

一旦定义了一个类（在Java中你所作的全部工作就是定义类，产生那些类的对象，乙级发送消息给这些对象），就可以在类中设置两种类型的元素：**字段**（有时被称作**数据成员**）和**方法**（有时被称作**成员函数**）。字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型中的一种。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与一个实际的对象（如前所述，使用new来实现）相关联。

每个对象都有用来存储其字段的空间；普通字段不能在对象间共享。

**基本成员默认值**

若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值，如表所示：

| 基本类型 |     默认值     |
| :------: | :------------: |
| boolean  |     false      |
|   char   | '\u0000'(null) |
|   byte   |    (byte)0     |
|  short   |    (short)0    |
|   int    |       0        |
|   long   |       0L       |
|  float   |      0.0f      |
|  double  |      0.0d      |

当变量作为类的成员使用时，Java才确保给定其默认值，以确保那些是基本类型的成员变量得到初始化（C++没有此功能），防止产生程序错误。但是这些初试值对于你的程序来说，可能是不正确的，甚至是不合法的。所以最好明确地对变量进行初始化。

然而上述确保初始化的方法并不适用于“局部”变量（即非某个类的字段）。因此，如果在某个方法定义中有

```java
int x;
```

那么变量x得到的可能是任意值（与C和C++中一样），而不会被自动初始化为零。所以在使用x前，应先对其赋一个适当的值。如果忘记了这么做，Java会在编译时返回一个错误，告诉你此变量没有初始化，这正是Java优于C++的地方。（许多C++编译器会对未初始化变量给予警告，而Java则视为是错误）。

## 2.5 方法、参数和返回值

许多程序设计语言（像C和C++）用**函数**这个术语来描述命名子程序；而在Java里却常用**方法**这个术语来表示“做某些事情的方式”。实际上，继续把它看作是函数也无妨。尽管这只是用词上的差别，但本书将沿用Java的惯用法，即用术语“方法”而不是“函数”来描述。

Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数、返回值和方法体。

返回类型描述的是在调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表（它们合起来被称为“**方法签名**”）唯一地标识出某个方法。

Java中的方法只能作为类的一部分来创建。方法只有通过对象才能被调用（static它是针对类调用的，并不依赖于对象的存在），且这个对象必须能执行这个方法调用。

### 2.5.1 参数列表

因此，在参数列表中必须指定每个所传递对象的类型及名字。像Java中任何传递对象的场合一样，这里传递的实际上也是引用（对于前面所提到的特殊数据类型boolean，char，byte，short，int，long，float和double来说是个例外。通常，尽管传递的是对象，而实际上传递的是对象的引用。），并且引用的类型必须正确。

String s的length()方法被调用，它是String类提供的方法之一，会返回字符串包含的字符数。

return关键字

void关键字

## 2.6 构建一个Java程序

### 2.6.1  名字可见性

程序的某个模块里使用了一个名字，而其他人在这个程序的另一个模块里也使用了相同的名字，那么怎样才能区分这两个名字并防止两者互相冲突呢？这个问题在C语言中尤其严重，因为程序往往包含许多难以管理的名字。C++类（Java类基于此）将函数包于其内，从而避免了与其他类中的函数名相冲突。然而，C++仍允许全局数据和全局函数的存在，所以还是有可能发生冲突。为了解决这个问题，C++通过几个关键字引入了**名字空间**的概念。

Java采用了一种全新的方法来避免上述所有问题。为了给一个类库生成不会与其他名字混淆的名字，Java设计者希望程序员反过来使用自己的Internet域名，因为这样可以保证它们肯定是独一无二的。比如我的域名是MindView.net，所以我的各种奇奇怪怪的应用工具类库就被命名为net.mindview.utility.foibles。反转域名后，句点就用来代表子目录的划分。

这种机制意味着所有的文件能够自动存活于它们自己的名字空间内，而且同一个文件内的每个类都有唯一的标识符——Java语言本身已经解决了这个问题。

### 2.6.2 运用其他构件

如果想在自己的程序里使用预先定义好的类，那么编译器就必须知道怎么定位它们。当然，这个类可能就在发出调用的那个源文件中；在这种情况下，就可以直接使用这个类——即使这个类在文件的后面才会被定义（Java消除了所谓的“向前引用”问题）。

如果那个类位于其他文件中，又会怎样呢？为了解决这个问题，必须消除所有可能的混淆情况。为实现这个目的，可以使用关键字import来准确地告诉编译器你想要的类是什么。import指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括方法和数据；但是Java中所有的代码都必须写在类里）。

如果不想明确地逐一声明，那么你很容易使用通配符“*”来达到这个目的：

```java
import java.util.*
```

### 2.6.3 static关键字

有两种情形四new无法解决的：一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。

通过static关键字可以满足这两方面的需要。当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非static域和方法必须知道它们一起运作的特定对象。

有些面向对象语言采用**类数据**和**类方法**两个术语，代表那些数据和方法只是作为整个类，而不是类的某个特定对象而存在的。有时，一些Java文献里也用到这两个术语。

```java
class StaticTest{
    static int i = 47;
}
```

现在即使你创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i。

```java
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```

在这里，st1.i和st2.i指向同一存储空间，因此它们具有相同的值。

引用static变量有两种方法。如前例所示，可以通过一个对象去定位它，如st2.i；也可以通过其类名直接引用，而这对于非静态成员则不行。

```java
StaticTest.i++;
```

此时，st1.i和st2.i仍具有相同的值48.

类似逻辑也应用于静态方法。既可以像其他方法一样，通过一个对象来引用某个静态方法，也可以通过特殊的语法形式ClassName.method()加以引用。定义静态方法的方式也与定义静态变量的方式相似：

```java
class Incrementable{
    static void increment(){
        StaticTest.i++;
    }
}
```

可以看到，Incrementable的increment()方法通过++运算符将静态数据 i 递加。可以采用典型的方式，通过对象来调用increment();

```java
Incrementable sf = new Incrementable();
sf.increment();
```

或者，因为increment()是一个静态方法，所以也可以通过它的类直接调用：

Incrementable.increment();

尽管当static作用于某个字段时，肯定会改变数据创建的方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间），但是static作用于某个方法，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。正如我们将会看到的那样，这一点对定义main()方法很重要，这个方法是运行一个应用时的入口点。

和其他任何方法一样，static方法可以创建或使用与其类型相同的被命名对象，因此，static方法常常拿来做“牧羊人”的角色，负责看护与其隶属同一类型的实例群。

## 2.7 你的第一个Java程序

```java
//HelloDate.java
import java.util.*;

public class HelloDate{
    public static void main(String[] args){
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}
```

在每个程序文件的开头，必须声明import语句，以便引入在文件代码中需要用到的额外类。注意，在这里说它们“额外”，是因为有一个特定类会自动被导入到每一个Java文件中：java.lang。

system类有许多属性，其中out是一个静态PrintStream对象。因为是静态的，所以不需要创建任何东西，out对象便已经存在了，只须直接使用即可。

public关键字意指这是一个可由外部调用的方法。main()方法的参数是一个String对象的数组。在这个程序中并未用到args，但是Java编译器要求必须这样做，因为args要用来存储命令行参数。

### 2.7.1 编译和运行

## 2.8 注释和嵌入式文档

Java里有两种注释风格。一种是传统的C语言风格的注释——C++也继承了这种风格。此种注释以` /*`开始，随后是注释内容，并可跨越多行，最后以` */`结束。注意，许多程序员在连续的注释内容的每一行都以一个“*”开头。

第二种风格的注释也源于C++。这种注释是“单行注释”，以一个“//”起头，直到句末。这种风格的注释因为书写容易，所以更方便、更常用。

### 2.8.1 注释文档

javadoc便是用于提取注释的工具，它是JDK安装的一部分。它采用了Java编译器的某些技术，查找程序内的特殊注释标签。

javadoc输出的是一个HTML文件，可以用Web浏览器查看。

### 2.8.2 语法

所有的javadoc命令都只能在` “/**” `注释中出现，和通常一样，注释结束于` "*/" `。使用javadoc的方式主要有两种：嵌入HTML，或使用"文档标签"。**独立文档标签**是一些以"@"字符开头的命令，且要置于注释行的最前面（但是不算前导` "*" `之后的最前面）。而**"行内文档标签"**则可以出现在javadoc注释中的任何地方，它们也是以"@"字符开头，但要括在花括号内。

javadoc只能为public（公共）和protected（受保护）成员进行文档注释。private（私有）和包内可访问成员的注释会被忽略掉，所以输出结果中看不到它们（不过可以用-private进行标记，以便把private成员的注释也包括在内）。这样做是有道理的，因为只有public和protected成员才能在文件之外被使用，这是客户端程序员所期望的。

上述代码的输出结果是一个HTML文件，它与其他JAVA文档具有相同的标准格式。

### 2.8.3 嵌入式HTML

```java
//:object/Documentation2.java
/**
* <pre>
* System.out.println(new Date());
* </pre>
* / 
///:~
```

也可以像在其他Web文档中那样运用HTML，对普通文本按照你自己所描述的进行格式化：

```java
//:object/Documentation3.java
/**
* You can <em>even<em> insert a list:
*<ol>
*<li>Item one
*<li>Item two
*<li>Item three
*</ol>
*/
///:~
```

注意，在文档注释中，位于每一行开头的星号和前导空格都会被javadoc丢弃。javadoc会对所有内容重新格式化，使其与标准的文档外观一致。不要在嵌入式HTML中使用标题标签，例如` <hl> `或` <hr> `，因为javadoc会插入自己的标题，而你的标题可能同它们发生冲突。

所有类型的注释文档——类、域和方法——都支持嵌入式HTML。

### 2.8.4 一些标签示例

1.@see：引用其他类

@see标签允许用户引用其他类的文档。javadoc会在其生成的HTML文件中，通过@see标签链接到其他文档。格式如下：

```
@see classname
@see fully-qualified-classname
@see fully-qualified-classname#method-name
```

每种格式都会在生成的文档中加入一个具有超链接的"See Also"（参见）条目。但是javadoc不会检查你所提供的超链接是否有效。

2.｛@link package.class#member label｝

该标签与@see极其相似，只是它用于行内，并且是用"label"作为超链接文本而不用"See Also"。

3.｛@docRoot｝

该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。

4.{@inheritDoc}

该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。

5.@version

该标签的格式如下：

```
@version version-information
```

其中，"version-information"可以是任何你认为适合包含在版本说明中的重要信息。如果javadoc命令行使用了"-version"标记，那么就从生成的HTML文档中特别提取出版本信息。

6.@author

该标签的格式如下：

```
@author author-information
```

其中，author-information一看便知是你的姓名，但是也可以包括电子邮件地址或者其他任何适宜的信息。如果javadoc命令行使用了-author标记，那么就从生成的HTML文档中特别提取作者信息。

可以使用多个标签，以便列出所有作者，但是它们必须连续放置。全部作者信息会合并到同一段落，置于生成的HTML中。

7.@since

该标签允许你指定程序代码最早使用的版本，可以在HTML Java文档中看到它被用来指定所用的JDK版本的情况。

8.@param

该标签用于方法文档中，形式如下：

```
@param parameter-name description
```

其中，parameter-name是方法的参数列表中的标签符，description是可延续数行的文本，终止于新的文档标签出现之前。可以使用任意多个这种标签，大约每个参数都有一个这样的标签。

9.@return

该标签用于方法文档，格式如下：

```
@return description
```

其中，description用来描述返回值的含义，可以延续数行。

10.@throws

"异常"将在第9章论述。简言之，它们是由于某个方法调用失败而"抛出"的对象。尽管在调用一个方法时，只出现一个异常对象，但是某个特殊方法可能会产生任意多个不同类型的异常，所有这些异常都需要进行说明。所以，异常标签的格式如下：

```
@throws fully-qualified-class-name description
```

其中，fully-qualified-class-name给出一个异常类的无歧义的名字，而该异常类在别处定义。description（同样可以延续数行）告诉你为什么此特殊类型的异常会在方法调用中出现。

11.@deprecated

该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性，因为在不久的将来它们很可能会被删除。如果使用一个标记为@deprecated的方法，则会引起编译器发布警告。

在Java SE5中，Javadoc标签@deprecated已经被@Deprecated注解所替代

### 2.8.5 文档示例

```java
//:object/HelloDate.java
import java.util.*;
/** The first Thinking in Java example program.
* Displays a string and today's date.
* @author Bruce Eckel
* @author www.MindView.net
* @version 4.0
*/
public class HelloDate{
    /** Entry point to class & application.
    * @param args array of string arguments
    * @throws exceptions No exceptions thrown
    */
    public static void main(String[] args){
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}/* Output:(55% match)
Hello, it's:
Wed Oct 05 14:39:36 MDT 2005
*///:~
```

第一行采用我自己独特的方法，用一个"："作为特殊记号说明这是包含源文件的注释行。该行包含文件的路径信息（此时，object代表本章），随后是文件名。最后一行也是一行注释，这个“///:~”标志源代码清单的结束。自此，在通过编译器和执行检查后，文档就可以自动更新成本书的文本。

/*Output 标签表示输出的开始部分将由这个文件生成，通过这种形式，它会被自动地测试以验证其准确性。在本例中，（55% match）在向测试系统说明程序的每一次运行和下一次运行的输出存在着很大的差异，因此它们与这里列出的输出预期只有55%的相关性。

## 2.9 编码风格

驼峰风格。类名的首字母要大写；如果类名由几个单词构成，那么把它们并在一起（也就是说，不要用下划线来分隔名字），其中每个内部单词的首字母都采用大写形式。

几乎其他所有内容——方法、字段（成员变量）以及对象引用名称等，公认的风格与类方格一样，只是标识符的第一个字母采用小写。

# 第3章 操作符

在最底层，Java中的数据是通过使用操作符来操作的。

## 3.1 更简单的打印语句

在第6章中将介绍静态导入（static import）这个在Java SE5中新增加的概念，并将创建一个小类库来简化打印语句的编写。

## 3.2 使用Java操作符

操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。加号和一元的正好（+）、减号和一元的负号（-）、乘号（*）、除号（/）以及赋值（=）的用法与其他编程语言类似。

副作用：一些操作符可能会改变操作数自身的值

几乎所有的操作符都只能操作“基本类型”。例外的操作符是“=”、“==”和“！=”，这些操作符能操作所有的对象（这也是对象易令人糊涂的地方）。除此之外，String类支持“+”和“+=”。

## 3.3 优先级

请注意，System.out.println()语句中包含“+”操作符。在这种上下文环境中，“+”意味着“字符串连接”，并且如果必要，它还要执行“字符串转换”。当编译器观察到一个String后面紧跟一个“+”，而这个“+”的后面又紧跟一个非String类型的元素时，就会尝试着将这个非String类型的元素转换为String。正如在输出中所看到的，它成功地将a和b从int转换为String了。

## 3.4 赋值

赋值使用操作符“=”。它的意思是“取右边的值（即右值），把它复制给左边（即左值）”。右值可以是任何常数、变量或者是表达式（只要它能生成一个值就行）。但左值必须是一个明确的，已命名的变量。也就是说，必须有一个物理空间可以存储等号右边的值。举例来说，可将一个常数赋给一个变量，但是不能把任何东西赋给一个常数，常数不能作为左值。

对基本数据类型的赋值是很简单的。基本类型存储了实际的数值，而并非指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另一个地方。例如，对基本数据类型使用a=b，那么b的内容就复制给a。若接着又修改了a，而b根本不会受这种修改的影响。作为程序员，这正是大多数情况下我们所期望的。

但是在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是对对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着假若对对象使用c=d, 那么c和d都指向原本只有d指向的那个对象。下面这个例子将向大家阐示这一点。

这种特殊的现象通常称作“别名现象”，是Java操作对象的一种基本方式。在这个例子中，如果想避免别名问题应该怎么办呢？可以这样写：` t1.level=t2.level; `

这样便可以保证两个对象彼此独立，而不是将t1和t2绑定到相同的对象。但你很快就会意识到，直接操作对象内的域容易导致混乱，并且，违背了良好的面向对象程序设计的原则。这可不是一个小问题，所以从现在开始大家就应该留意，为对象赋值可能会产生意想不到的结果。

### 3.4.1 方法调用中的别名问题

```java
class Letter{
    char c;
}
static void f(Letter y){
    y.c ='z';
}
```

在许多编程语言中，方法f（）似乎要在它的作用域内复制其参数Letter y的一个副本，但实际上只是传递了一个引用。所以代码行 ` y.c='z'; `实际改变的是f()之外的对象。

## 3.5 算术操作符

通过Random类的对象，程序可生成许多不同类型的随机数字。做法很简单，只需调用方法nextInt()和nextFloat()即可（也可以调用nextLong()或者nextDouble()）。传递给nextInt()的参数设置了所产生的随机数的上限。

### 3.5.1 一元加、减操作符

编译器能正确识别下述语句：

`  x=a*-b`

但读者会被搞糊涂，所以有时更明确地写成：

` x=a*(-b) `

一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。

## 3.6 自动递增和递减

“--”和“++”各有两种使用方式，通常称为“前缀式”和“后缀式”。

对于前缀递增和前缀递减（如++a或--a），会先执行运算，再生成值。而对于后缀递增和后缀递减（如a++或a--）,会先生成值，再执行运算。

前缀形式，我们在执行完运算才得到值。但对于后缀形式，则是在运算执行前就得到值。它们是除那些涉及赋值的操作符以外，唯一具有“副作用”的操作符。也就是说，它们会改变操作数，而不仅仅是使用自己的值。

Bill Joy（Java创始人之一）声称“Java=c++--”

## 3.7 关系操作符

关系操作符生成的是一个boolean（布尔）结果，它们计算的是操作数的值之间的关系。关系操作符包括<,>,<=,>=,==以及!=。等于和不等于适用于所有的基本数据类型，而其他比较符不适用于boolean类型。因为boolean值只能为true或false，“大于”和“小于”没有实际意义。

### 3.7.1 测试对象的等价性

```java
Integer n1 = new Integer(47);
Integer n2 = new Integer(47);
System.out.println(n1==n2);
System.out.println(n1!=n2);
```



尽管对象的内容相同，然而对象的引用却是不同的，而==和！=比较的就是对象的引用。所以输出结果实际上先是false，再是true。这自然会使第一次接触关系操作符的人感到惊奇。

如果想比较两个对象的实际内容是否相同，又该如何操作呢？此时，必须使用所有对象都适用的特殊方法equals（）。但这个方法不适用于“基本类型”，基本类型直接使用==和！=即可。

equals()的默认行为是比较引用。所以除非在自己的新类中覆盖equals()方法，否则不可能表现出我们希望的行为。

大多数Java类库都实现了equals()方法，以便用来比较对象的内容，而非比较对象的引用。

## 3.8 逻辑操作符

逻辑操作符“与”（&&）、“或”（||）、“非”（!）能根据参数的逻辑关系，生成一个布尔值（true或false）。

“与”、“或”、“非”操作只可应用于布尔值。与在C及C++中不同的是：不可将一个非布尔值当作布尔值在逻辑表达式中使用。

注意，如果在应该使用String值的地方使用了布尔值，布尔值会自动转换成适当的文本形式。

### 3.8.1 短路

当使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算。

事实上，如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升。

## 3.9 直接常量

直接常量后面的后缀字符标志了它的类型。若为大写（或小写）的L，代表long（但是，使用小写字母l容易造成混淆，因为它看上去很像数字1）。大写（或小写）字母F，代表float；大写（或小写）字母D则代表double.

十六进制数适用于所有整数数据类型，以前缀0x（或0X），后面跟随0-9或小写（或大写）的a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值（无论这个值的数值形式如何），编译器都会向我们报告一条错误信息。char、byte以及short如果超出范围，编译器会将值自动转换成int型，并告诉我们需要对这次赋值进行“窄化转型”（转型将在本章稍后部分定义）。这样我们就可清楚地知道自己的操作是否越界了。

八进制数由前缀0以及后序的0~7的数字来表示。

在C、C++或者Java中，二进制数没有直接常量表示方法。但是在使用十六进制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类的静态方法toBinaryString()可以很容易地实现这一点。请注意，如果将比较小的类型传递给Integer.toBinaryString()方法，则该类型将自动被转换为int。

### 3.9.1 指数计数法

编译器通常会将指数作为双精度数（double）处理。

## 3.10 按位操作符

按位操作符来源于C语言面向底层的操作，Java的设计初衷是嵌入电视机机顶盒内，所以这种面向底层的操作仍被保留了下来。但是，人们可能不会过多的用到位操作符。

与（&）、或（|）、异或（^）、非（~）

按位操作符和逻辑操作符使用了同样的符号，因此我们能方便地记住它们的含义；由于位是非常“小”的，所以按位操作符仅使用了一个字符。

按位操作符可与等号（=）联合使用，以便合并运算和赋值：&=、！=和^=都是合法的（由于“~”是一元操作符，所以不可与“=”联合使用）。

我们将布尔类型作为一种单比特值对待，所以它多少有些独特。我们可对它执行按位“与”、按位“或”和按位“异或”运算，但不能执行按位“非”（大概是为了避免与逻辑NOT混淆）。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的按位运算为我们新增了一个“异或”逻辑操作符，它并未包括在“逻辑”操作符的列表中。在移位表达式中，不能使用布尔值运算，原因将在后面解释。

## 3.11 移位操作符

左移位操作符(<<)低位补0

“有符号”右移位操作符(>>)符号为正，高位补0；符号为负，高位补1。Java中增加了一种“无符号”右移位操作符(>>>)，它使用“零扩展”：无论正负，都在高位插入0.这一操作符是C/C++中没有的。

如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用。这样可放置我们移位超过int型值所具有的位数。（译注：因为2^5=32，而int型值只有32位。）若对一个long类型的数值进行处理，最后得到的结果也是long，此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数。

“移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题：如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果。它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

程序末尾调用了两个方法：printBinaryInt()和printBinaryLong().它们分别接受int或long型的参数，并用二进制格式输出，同时附有简要的说明文字。

## 3.12 三元操作符if-else

## 3.13 字符串操作符+和+=

这个操作符在Java中有一项特殊用途：连接不同的字符串。尽管与+和+=的传统使用方式不太一样，但我们还是很自然地使用这些操作符来做这件事情。

这项功能用在C++中似乎是个不错的注意，所以引入了**操作符重载（operator overloading）**机制，以便C++程序员可以为几乎所有操作符增加功能。与C++相比，尽管操作符重载在Java中更易实现（就像在C#语言中所展示的那样，它具有相当简单直接的操作符重载机制），但仍然过于复杂。所以Java程序员不像C++和C#程序员那样实现自己的重载操作符。

字符串操作有一些很有趣的行为。如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型（请记住，编译器会把双引号内的字符序列自动转成字符串）。

有时会看到一个空的String（""）后面跟随+和一个基本类型变量，以此作为不调用更加麻烦的显式方法（在本例中应该是Integer.toString()）而执行字符串转换的方式。

## 3.14 使用操作符时常犯的错误

使用操作符时一个常犯的错误就是，即使对表达式如何计算有点不确定，也不愿意使用括号。这个问题在Java中仍然存在。

在C和C++中，一个特别常见的错误如下：

```c
while(x=y){
	//……
}
```

程序员很明显是想测试是否“相等”（==），而不是进行赋值操作。在C和C++中，如果y是一个非零值，那么这种赋值的结果肯定是true，而这样便会得到一个无穷循环。在Java中，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值。由于Java不会自动地将int数值转换成布尔值，所以在编译时会抛出一个编译时错误，从而阻止我们进一步去运行程序。所以这种错误在Java中永远不会出现（唯一不会得到编译时错误的情况是x和y都为布尔值。在这种情况下，x=y属于合法表达式。而在前面的例子中，则可能是一个错误）。

Java中有一个与C和C++中类似的问题，即使用按位“与”和按位“或”代替逻辑“与”和逻辑“或”。按位“与”和按位“或”使用单字符（&或|），而逻辑“与”和逻辑“或”使用双字符（&&或||）。就像“=”和“==”一样，键入一个字符当然要比键入两个简单。Java编译器可防止这个错误发生，因为它不允许我们随便把一种类型当做另一种类型来用。

## 3.15 类型转换操作符

在适当的时候，Java会将一种数据类型自动转换成另一种。例如，假设我们为某浮点变量赋以一个整数值，编译器会将int自动转换成float。类型转换运算允许我们显式地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。

想要执行类型转换，需要将希望得到的数据类型置于圆括号内，放在要进行类型转换的值的左边。

在C和C++中，类型转换有时会让人头疼。但是在Java中，类型转换则是一种比较安全的操作。然而，如果要执行一种名为**窄化转换（narrowing conversion）**的操作（也就是说，将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型），就有可能面临信息丢失的危险。此时，编译器会强制我们进行类型转换。而对于**扩展转换（widening conversion）**,则不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。

Java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，后者根本不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换。为了将一种类转换成另一种，必须采用特殊的方法（本书后面会讲到，对象可以在其所属类型的类族之间可以进行类型转换；例如，“橡树”可转型为“树”；反之亦然。但不能把它转换成类族以外的类型，如“岩石”）。

### 3.15.1 截尾和舍入

在执行窄化转换时，必须注意截尾与舍入问题。

float或double转型为整型值时，总是对该数字执行截尾。若果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法；

round()是java.lang的一部分，因此在使用它时不需要额外地导入。

### 3.15.2 提升

如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char、byte或者short），那么在运算之前，这些值会自动转换成int。这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转换（既然把结果赋给了较小的类型，就可能出现信息丢失）。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float值与一个double值相乘，结果就是double;如果将一个int和一个long值相加，则结果为long。

## 3.16 Java没有sizeof

在C和C++中，需要sizeof()的最大原因是为了“移植”。

Java不需要sizeof()操作符，因为所有数据类型在所有机器中的大小都是相同的。我们不必考虑移植问题——它已经被设计在语言中了

## 3.17 操作符小结

|           | boolean |  char   |  byte   |  short   | int  | long | float | double |
| :-------: | :-----: | :-----: | :-----: | :------: | :--: | :--: | :---: | :----: |
|     *     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     /     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     %     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     +     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     -     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|    ++     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    --     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  +(一元)  |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
| -（一元） |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     >     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    >=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|     <     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    <=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    ==     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    !=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|     !     |    ✔    |         |         |          |      |      |       |        |
|    &&     |    ✔    |         |         |          |      |      |       |        |
|   \|\|    |    ✔    |         |         |          |      |      |       |        |
|     ~     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|     &     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    \|     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|     ^     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    <<     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    >>     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    >>>    |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    +=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    -=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    *=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    /=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    %=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    <<=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    >>=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|   >>>=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    &=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    ^=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    \|=    |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|  (char)   |         |    -    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  (byte)   |         |    ✔    |    -    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  (short)  |         |    ✔    |    ✔    |    -     |  ✔   |  ✔   |   ✔   |   ✔    |
|   (int)   |         |    ✔    |    ✔    |    ✔     |  -   |  ✔   |   ✔   |   ✔    |
|  (long)   |         |    ✔    |    ✔    |    ✔     |  ✔   |  -   |   ✔   |   ✔    |
|  (float)  |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   -   |   ✔    |
| (double)  |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   -    |
| (boolean) |    -    |         |         |          |      |      |       |        |

注意，能够对布尔型值进行的运算非常有限。我们只能赋予它true和false值，并测试它为真还是为假，而不能将布尔值相加，或对布尔值进行其他任何运算。

在char\byte和short中，我们可以看到使用算术操作符中数据类型提升的效果。对这些类型的任何一个进行算术运算，都会获得一个int结果，必须将其显式地类型转换回原来的类型（窄化转换可能会造成信息的丢失），以将值赋给原本的类型。但对于int值，却不必进行类型转化，因为所有数据都已经属于int类型。但对两个足够大的int值进行乘法运算，结果就会溢出，你不会从编译器那里收到出错或警告信息，运行时也不会出现异常。这说明Java虽然是好东西，但也没有那么好！

对于char\byte或者short，复合赋值并不需要类型转换。尽管它们执行类型提升，但也会获得与直接算术运算相同的结果。而在另一方面，省略类型转换可使代码更加简练。

可以看到，除boolean以外，任何一种基本类型都可通过类型转换变为其他基本类型。

# 第4章 控制执行流程

if-else, while, do-while, for, return, break以及选择语句switch。Java并不支持goto语句。在Java中，仍然可以进行类似goto那样的跳转，但比起典型的goto，有了很多限制。

## 4.1 true和false

Java不允许我们将一个数字作为布尔值使用。如果想在布尔测试中使用一个非布尔值，比如在if(a)中，那么首先必须用一个条件表达式将其转换成布尔值，例如if(a!=0)

## 4.2 if-else

## 4.3 迭代

while、do-while和for用来控制循环，有时将它们划分为**迭代语句（iteration statement）**。语句会重复执行，知道起控制作用的**布尔表达式（Boolean expression）**得到“假”的结果为止。

Math库里的static（静态）方法random()，该方法的作用是产生0和1之间（包括0，但不包括1)的一个double值。

### 4.3.1 do-while

while和do-while唯一的区别就是do-while中的语句至少会执行一次，即便表达式第一次就被计算为false。

### 4.3.2 for

**初始化（initialization）**表达式、**布尔表达式（Boolean-expression）**，或者**步进（step）**运算都可以为空。

java.lang.Character包装器类，这个类不但能把char基本类型的值包装进对象，还提供了一些别的有用的方法。这里用到了static isLowerCase()方法来检查问题中的字符是否为小写字母。

对于像C语言那样的传统的过程性语言，要求所有变量都在一个块的开头定义，以便编译器在创建这个块的时候，可以为那些变量分配空间。而在Java和C++中，则可在整个块的范围内分散变量声明，在真正需要的地方才加以定义。

### 4.3.3 逗号操作符

本章前面已经提到了逗号操作符（注意不是逗号分隔符，逗号用做分隔符时用来分隔函数的不同参数），Java里唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列的逗号分隔的语句；而且那些语句均会独立执行。

通过使用逗号操作符，可以在for语句内定义多个变量，但是它们必须具有相同的类型。

for语句中int的定义覆盖i和j，在初始化部分实际上可以拥有任意数量的具有相同类型的变量定义。在一个控制表达式中，定义多个变量的这种能力只限于for循环适用，在其他任何选择或迭代语句中都不能适用这种方式。

## 4.4 Foreach语法

Java SE5 引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对访问项构成的序列进行计数，foreach将自动产生每一项。

String类有一个方法toCharArray(),它返回一个char数组。

就像在11章所看到的，foreach还可以用于任何Iterable对象

## 4.5 return

return关键词有两方面的用途：一方面指定一个方法返回什么值（假设它没有void返回值），另一方面它会导致当前方法退出，并返回那个值。

如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return，因此在方法中并非总是必须要有一个return语句。但是，如果一个方法声明它将返回void以外的其他东西，那么必须确保每一条代码路径都将返回一个值。

## 4.6 break和continue

break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。

无穷循环：第一种while(true);第二种for(;;)

## 4.7 臭名昭著的goto

编程语言一开始就有goto关键词了。

goto语句是在源码级上的跳转，这使其招致了不好的声誉。真正问题并不在于使用goto，而在于goto的滥用；而且少数情况下，goto还是组织控制流程的最佳手段。

尽管goto仍是Java中的一个保留字，但在语言中并未使用它：Java没有goto.然而，Java也能完成一些类似于跳转的操作，这与break和continue这两个关键词有关。它们其实不是一个跳转，而是中断迭代语句的一种方法。之所以把它们纳入goto问题中一起讨论，是由于它们使用了相同的机制：标签。

标签是后面跟有冒号的标识符。

如：` label1: `

在Java中，标签起作用的唯一的地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任何语句都不好。而在迭代前设置标签的唯一理由是：我们希望在其中嵌套另一个迭代或者一个开关（你很快就会学习到它）。这是由于break和continue关键词通常只中断当前循环，但若随同标签一起使用，它们就会中断循环，直到标签所在的地方。

如` break label1; `和` continue label1; `

break本身只能中断最内层的循环（continue同样也是如此）。

同样的规则亦适用于while：

1）一般的continue会退回最内层循环的开头（顶部），并继续执行。

2）带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。

3）一般的break会中断并跳出当前循环。

4）带标签的break会中断并跳出标签所指的循环。

要记住的重点是：在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

## 4.8 switch

若省略break，会继续执行后面case语句，直到遇到一个break为止。注意最后的default语句没有break，因为执行流程移到了break的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default语句的末尾放置一个break，尽管它没有任何实际的用处。

switch语句是实现多路选择的一种干净利落的方法。但它要求使用一个选择因子，并且必须是int或char那样的整数值。对于非整数类型，则必须使用一系列if语句。在下一章的末尾，你将看到Java SE5的新特性enum，它可以帮助我们减弱这种限制，因为enum可以和switch协调工作。

# 第5章 初始化与清理

随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

**初始化和清理（cleanup）**正是涉及安全的两个问题。

C++引入了**构造器（constructor）**的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。

## 5.1 用构造器确保初始化

如何命名这个初始化方法。有两个问题：第一，所取的名字都可能与类的某个成员名称相冲突；第二，调用构造器是编译器的责任，所以必须让编译器知道应该调用哪个方法。C++语言中采取的解决方案看来是最简单且更符合逻辑，所以在Java中也采用了这种方案：即构造器采用与类相同的名称。考虑到在初始化期间要自动调用构造器，这种做法就顺利成章了。

现在，在创建带有构造器的类的对象时，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。

请注意，由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的编码风格并不适用于构造器。

不接受任何参数的构造器叫做**默认构造器**，Java文档中通常使用术语**无参构造器**，但是默认构造器在Java出现之前就已经使用许多年了，所以我仍旧倾向于使用它。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。

有了构造器形式参数，就可以在初始化对象时提供实际参数。

如果Tree（int）是Tree类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建Tree对象。

构造器有助于减少错误，并使代码更易于阅读。从概念上讲，“初始化”与“创建”是彼此独立的然而在上面的代码中，你却找不到对Initialize()方法的明确调用。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。

构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void）明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。构造器则不会返回任何东西，你别无选择（new表达式确实返回了对新建对象的引用，但是构造器本身并没有任何返回值）。假如构造器具有返回值，而且允许人们自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。

## 5.2 方法重载

任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给次对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，你可以引用所有对象和方法。

大多数程序设计语言（尤其是C）要求为每个方法（在这些语言中经常称为函数）都提供一个独一无二的标识符。所以绝不能用名为print()的函数显示了整数之后，又用一个名为print()的函数显示浮点数——每个函数都要有唯一的名称。

在Java（和C++）里构造器是强制重载方法名的另一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造器名。那么要想用多种方式创建一个对象，比如你要创建一个既可以用标准方式进行初始化、也可以从文件里读取信息来初始化的类。这就需要两个构造器：一个默认构造器，另一个取字符串作为形式参数——该字符串表示初始化对象所需的文件名称。由于都是构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载。同时，尽管方法重载是构造器所必需的，但它亦可用于其他方法，且用法同样方便。

### 5.2.1 区分重载方法

区分相同名字的方法，Java的判断规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表。

甚至参数顺序的不同也足以区分两个方法。不过，一般情况下别这么做，因为这会使代码难以维护。

### 5.2.2 涉及基本类型的重载

如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

如果传入的实际参数大于重载方法声明的形式参数，就得通过类型转换来执行窄化转换。

### 5.2.3 以返回值区分重载方法

能否用方法的返回值来区分呢？

只要编译器可以根据语境明确判断出语义，比如在int x=f()中，那么的确可以据此区分重载方法。不过，有时你不关心返回值，只想要方法调用的其他效果（这常被称为“为了副作用而调用”），比如 f();

此时Java如何才能判断该调用哪一个f()呢？因此，根据方法的返回值来区分重载方法是行不通的。

## 5.3 默认构造器

如前所述，默认构造器（又名“无参”构造器）时没有形式参数的——它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。

但是，如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。

## 5.4 this关键字

如果有同一类型的两个对象，分别是a和b。如何能让这两个对象都能调用peel()方法呢：

```java
//:initialization/BananaPeel.java
class Banana(void peel(int i)){/*……*/}
public class BananaPeel{
    public static void main(String[] args){
        Banana a = new Banana(), b = new Banana();
        a.peel(1);
        b.peel(2);
    }
}///:~
```

如果只有一个peel()方法，它如何知道是被a还是被b所调用的呢？

为了能用简便、面向对象的语法来编写代码——即“发送消息给对象”，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给peel()。所以上述两个方法的调用就变成了这样：

Banana.peel(a,1);

Banana.peel(b,2);

这是内部的表示形式。我们并不能这样书写代码，并试图通过编译。

假如你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this，this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一类中额其他方法。所以可以这样写代码：

```java
//:initialization/Apricot.java
public class Apricot{
    void pick(){/*...*/}
    void pit(){pick();/*...*/}
}///:~
```

在pit()内部，你可以写this.pick(),但无此必要。（有些人执意将this放在每一个方法调用和字段引用前，认为这样“更清楚明确”。但是，千万别这么做。我们使用高级语言的原因就是它们能帮我们做一些事情。人们期望只在必要处使用this。遵循一种一致而直观的编程风格能节省时间和金钱。）编译器能帮你自动添加。只有当需要明确指出对当前对象的引用时，才需要使用this关键字。

### 5.4.1 在构造器中调用构造器

可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用this关键字做到这一点。

通常写this的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确引用；这样，调用其他构造器就有了直接的途径。

尽管可以用this调用一个构造器，但不能调用两个。此外，必须将构造器调用置于最初始处，否则编译器会报错。

this的另一个用法：由于参数的名称可以与数据成员的名字相同，所以会产生歧义。(假如都是s) 使用this.s来代表数据成员就能解决这个问题。

除构造器之外，编译器禁止在任何其他方法中调用构造器。

### 5.4.2 static的含义

==static方法就是没有this的方法==。在static方法的内部不能调用非静态方法，反过来倒是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正式static方法的主要用途。它很像全局方法。Java禁止使用全局方法，但你在类中置入static方法就可以访问其他static方法和static域。

有些人认为static方法不是“面向对象”的，因为它们的确具有全局函数的语义；使用static方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来完成的。的确，要是在代码中出现了大量的static方法，就该重新考虑自己的射击了。然而，static的概念有其实用之处，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论把。事实上Smalltalk语言里的“类方法”就是与static方法相对应的。

## 5.5 清理：终结处理和垃圾回收

把一个对象用完后就“弃之不顾”的做法并非总是安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用了new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存。为了应对这种情况，Java允许在类中定义一个名叫finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。

这里有一个潜在的编程陷阱，因为有些程序员（特别是C++程序员）刚开始可能会误把finalize()当作C++中的**析构函数**（C++中销毁对象必须用到这个函数）。所以有必要明确区分一下：在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里的对象却并非总是被垃圾回收。换句话说：**1.对象可能不被垃圾回收。2.垃圾回收并不等于“析构”。**

牢记这些，就能远离困扰。这意味着在你不再需要某个对象之前，如果必须执行某些动作，那么你得自己去做。Java并未提供“析构函数”或类似的概念，要做类似的清理工作，必须自己动手创建一个执行清理工作的普通方法。例如，假设某个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在finalize()里加入某种擦除功能，当“垃圾回收”发生时（不能保证一定会发生），finalize()得到调用，图像就会被擦除。要是“垃圾回收”没有发生，图像就会一直保留下来。

也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。

### 5.5.1 finalize()的用途何在

finalize()不该用于通用的清理方法，其真正用途是什么呢？这引出了要记住的第三点：**3.垃圾回收只与内存有关。**

也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。

但这是否意味着要是对象中含有其他对象，finalize()就应该明确释放那些对象呢？不，无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。

看来之所以要有finalize()，是由于在分配内存时可能采用了类似C语言中的做法。而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下。**本地方法**是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用了free()函数，否则存储空间将得不到释放，从而造成内存泄露。当然，free()是C和C++中的函数，所以需要finalize()中用本地方法调用它。

总之，不要过多地使用finalize()

### 5.5.2 你必须实施清理

要清理一个对象，用户必须要清理的时刻调用执行清理动作的方法。但却与C++中的“析构函数”的概念稍有抵触。在C++中，所有对象都会被销毁，或者说，应该被销毁。如果在C++中创建了一个局部对象（也就是在堆栈上创建，这在Java中行不通），此时的销毁动作发生在以“右花括号”为边界的、此对象作用域的末尾处。如果对象使用new创建的（类似于Java中），那么当程序员调用C++的delete操作符时（Java没有这个命令），就会调用相应的析构函数。如果程序员忘记调用delete，那么永远不会调用析构函数，这样就会出现内存泄露，对象的其他部分也不会得到清理。这种缺陷很难追踪，这也是C++程序员转向Java的一个主要因素。

相反，Java不允许创建局部对象，必须使用new创建对象。在Java中，也没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。甚至可以肤浅地认为，正是由于垃圾收集机制的存在，使得Java没有析构函数。然而，随着学习的深入，读者会明白垃圾回收器的存在并不能完全代替析构函数。（而且绝对不能直接调用finalize(),所以这也不是一种解决方案。）如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的Java方法。这就等同于使用析构函数了，只是没有它方便。

记住，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

### 5.5.3 终结条件

通常，不能指望finalize()，必须创建其他的“清理”方法，并且明确地调用它们。看来，finalize()只能存在于程序员很难用到的一些晦涩用法里了。不过，finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。

当对某个对象不再感兴趣——也就是它可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全地释放。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。finalize()可以用来最终发现这种情况——尽管它并不总是会被调用。如果某次finalize()的动作使得缺陷被发现，那么就可据此找出问题所在——这才是人们真正关心的。

System.gc()用于强制进行终结动作。即使不这么做，通过重复地执行程序（假设程序将分配大量的存储空间而导致垃圾回收动作的执行），最终也能找出错误的Book对象。

你应该总是假设基类版本的finalize()也要做某些重要的事情，因此要使用super来调用它。它可能需要进行异常处理，而我们还没有介绍过这部分内容。

### 5.5.4 垃圾回收器如何工作

在以前所用过的程序语言中，在堆上分配对象的代价十分高昂，因此读者自然会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪——存储空间的释放竟然会影响存储空间的分配，但这确是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度可以与其他语言从堆栈上分配空间的速度相媲美。

通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。

要想更好地理解Java中的垃圾回收，先了解其他系统中的垃圾回收机制会很有帮助。**引用计数**是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接至对象时，引用计数加1.当引用离开作用域或被置为null时，引用计数减1。虽然管理引用计数的开销不大，但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间（但是，引用计数模式经常会在计数值变为0时立即释放对象）。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”的情况。对垃圾回收器而言，定位这样交互自引用的对象组所需的工作量极大。引用计数常用来说明垃圾收集的工作方式，但似乎从未被应用于任何一种Java虚拟机实现中。

在一些更快的模式中，垃圾回收器并非基于引用计数计数。它们依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。你所访问过的对象必须都是“活”的。注意，这就解决了“交互自引用的对象组”的问题——这种现象根本不会被发现，因此也就被自动回收了。

这种方式下，Java虚拟机将采用一种**自适应**的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的Java虚拟机实现。有一种做法名为**停止-复制（stop-and-copy）**。显然这意味着，先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以以新堆保持紧凑排列，然后就可以按前述方法简单、直接地分配新空间了。

当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成有个表格，将旧地址映射至新地址）。

对于这种所谓的“复制式回收器”而言，效率会变低。有这两个原因：首先，得有两个堆，然后得在这两个分离的堆之间来回倒腾，从而得维护比实际需要多一倍的空间。某些Java虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。

第二个问题在于复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制式回收器仍然会将所有内存自一处复制到另一处，这很浪费。为了避免这种情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种工作模式（即“自适应”）。这种模式称为**标记-清扫（mark-and-sweep）**，Sun公司早期版本的Java虚拟机使用了这种技术。对一般用途而言，“标记-清扫”方式速度相当慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾时，它的速度就很快了。

“标记-清扫”所依据的思路同样是从堆栈和静态存储区出发，遍历所有的应用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。

“停止-复制”的意思是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会被暂停。同样，“标记-清扫”工作也必须在程序暂停的情况下才能进行。

如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆，这将导致大量内存复制行为。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象了。每个块都用相应的**代数（generation count）**来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会被复制（只是其代数会增加），内含小型对象的那些块则被复制并整理。Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器效率降低的话，就切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就会切换回“停止-复制”方式。这就是“自适应”技术。

Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为“即时”（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得以提升。当需要装载某个类（通常是在为这个类创建第一个对象）时，编译器会先找到其`.class`文件，然后将该类的字节码装入内存，此时，有两种方案可供选择。一种是就让即时编译器编译所有代码。但这种方法有两个缺陷：这种加载动作散落在整个程序生命周期内，累加起来要花更多时间；并且会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度。另一种做法称为**惰性评估（lazy evaluation）**，意思是即时编译器只要在必要的时候才编译代码。这样，从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。

## 5.6 成员初始化

Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。

==要是类的数据成员（即字段）是基本类型，情况就会变得有些不同。正如在“一切都是对象”一章所看到的，类的每个基本类型数据成员保证都会有一个初始值。==

| 数据类型  | 初始值 |
| :-------: | :----: |
|  boolean  | false  |
|   char    |  [ ]   |
|   byte    |   0    |
|   short   |   0    |
|    int    |   0    |
|   long    |   0    |
|   float   |  0.0   |
|  double   |  0.0   |
| reference |  null  |

尽管数据成员的初值没有给出，但它们确实有初值（char值为0，所以显示为空白）。这样至少不会冒“未初始化变量”的风险了。

在类里定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊值null。

### 5.6.1 指定初始化

有一种很直接的办法，就是在定义类成员变量的地方为其赋值（注意在C++里不能这样做，尽管C++新手们总想这样做）。

也可以用同样的方法初始化非基本类型的对象。如果Depth是一个类，那么可以像下面这样创建一个对象并初始化它:

```java
//:initialization/Measurement.java
class Depth{}
public class Measurement{
    Depth d = new Depth();
    //...
}///:~
```

如果没为d指定初始值就尝试使用它，就会出现运行时错误，告诉你产生了一个异常（这在第12章中详述）

甚至可以通过调用某个方法来提供初值。这个方法可以是无参的，也可以带有参数，但这些参数必须是被初始化了的。

```java
//:initialization/MethodInit3.java
public class MethodInit3 {
    //! int j=g(i)//Illegal forward reference
    int i=f();
    int j=g(i);
    int f(){return 11;}
    int g(int n){return n*10;}
}///:~
```

## 5.7 构造器初始化

可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这为编程带来了更大的灵活性。但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。

### 5.7.1 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。

### 5.7.2 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null。

如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。

静态初始化只有在必要时刻才会进行。如果不创建Table对象，也不引用Table.b1或Table.b2，那么静态的Bowl b1和b2永远都不会被创建。只有第一个Table对象被创建（或者第一次访问静态数据）的时候，它们才会被初始化。此后，静态对象不会再次被初始化。

初始化的顺序是先静态对象（如果它们尚未因前面的对象创建过程而被初始化），而后是“非静态”对象。从输出结果中可以观察到这一点。要执行main()（静态方法），必须加载StaticInitialization类，然后其静态域table和cupboard被初始化，这将导致它们对应的类也被加载，并且由于它们也都包含静态的Bowl对象，因此Bowl随后也被加载。这样，在这个特殊的程序中的所有类在main()开始之前就都被加载了。实际情况通常并非如此，因为在典型的程序中，不会像在本例中所做的那样，将所有的事物都通过static联系起来。

总结一下对象的创建过程，假设有个名为Dog的类：

1. 即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
2. 然后载入Dog.class（后面会学到，这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
3. 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
4. 这块存储空间会被清零，这就自动地将Dog对象中所有基本类型数据都设置成了默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置成了null。
5. 执行所有出现于字段定义处的初始化动作。
6. 执行构造器，正如将在第7章所看到的，这可能会牵扯到很多动作，尤其是涉及继承的时候。

### 5.7.3 显式的静态初始化

Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时也叫做“静态块”）。就像下面代码一样：

```java
//:initialization/Spoon.java
public class Spoon{
    static int i;
    static{
        i=47;
    }
}///:~
```

尽管上面的代码看起来像个方法，但它实际只是一段跟在static关键字后面的代码。与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）

### 5.7.4 非静态实例初始化

Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。

看起来它与静态初始化子句一模一样，只不过少了static关键字。这种语法对于支持“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式构造器，某些操作都会发生。从输出中可以看到实例初始化子句是在两个构造器之前执行的。

## 5.8 数组初始化

数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符[ ]来定义和使用的。要定义一个数组，只需在类型名后加上一对方括号即可：

```java
int[] a1;
```

方括号也可以置于标识符后面：

```java
int a1[];
```

两种格式的含义是一样的，后一种格式符合C和C++程序员的习惯。不过，前一种格式或许更合理，毕竟它表明类型是“一个int型数组”。本书将采用这种格式。

编译器不允许指定数组的大小。现在拥有的只是对数组的一个引用（你已经为该引用分配了足够的内存空间），而且也没给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成的。这种情况下，存储空间的分配（等价于使用new）将由编译器负责。例如：

```java
int[] a1 = {1, 2, 3, 4, 5};
```

那么为什么还要在没有数组的时候定义一个数组引用呢？

在Java中可以将一个数组赋值给另一个数组，所以可以这样：

a2 = a1；

其实真正做的只是复制了一个引用。

所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员，可以通过它获知数组内包含了多少个元素，但不能对其修改。这个成员就是length。与C和C++类似，Java数组计数也是从第0个元素开始，所以能使用的最大下标数是length-1。要是超过这个边界，C和C++会“默默”地接受，并允许你访问所有内存，许多声名狼藉的程序错误由此而生。Java则能保护你免受这一问题的困扰，一旦访问下标过界，就会出现运行时错误（即异常）。

Arrays.toString()方法属于java.util标准类库，它将产生一维数组的可打印版本。

数组也可以在定义的同时进行初始化：

```java
Random rand = new Random(47);
int[] a = new int[rand.nextInt(20)];
```

如果你创建了一个非基本类型的数组，那么你就创建了一个引用数组。以整形的包装器类Integer为例，它是一个类而不是基本类型

这里即使使用new创建数组之后：

```java
Integer[] a = new Integer[rand.nextInt(20)];
```

它还只是一个引用数组，并且直到通过创建新的Integer对象（在本例中是通过自动包装机制创建的），并把对象赋值给引用，初始化进程才算结束：

```java
a[i]=rand.nextInt(500);
```

如果忘记了创建对象，并且试图使用数组中的空引用，就会在运行时产生异常。

也可以用花括号括起来的列表来初始化对象数组。有两种形式：

```java
//:initialization/ArrayInit.java
//Array initialization
import java.util.*;
public class ArrayInit{
    public static void main(String[] args){
        Integer[] a = {
            new Integer(1),
            new Integer(2),
            3, //Autoboxing
        };
        Integer[] b = new Integer[]{
            new Integer(1),
            new Integer(2),
            3, //Autoboxing
        };
        System.out.println(Arrays.toString(a));
        System.out.println(Arrays.toString(b));
    }
}/* Output:
[1, 2, 3]
[1, 2, 3]
*///:~
```

在这两种形式中，初始化列表的最后一个逗号都是可选的（这一特性使维护长列表变得更容易）。

尽管第一种形式很有用，但是它也更加受限，因为它只能用于数组被定义之处。你可以在任何地方使用第二种和第三种形式，甚至是在方法调用的内部。例如，你可以创建一个String对象数组，将其传递给另一个main()方法，以提供参数，用来替换传递给该main()方法的命令行参数。

### 5.8.1 可变参数列表

第二种形式提供了一种方便的语法来创建并调用方法，以获得与C的可变参数列表（C通过把它简称为varargs）一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于Object类（随着本书的进展，读者会对此有更深入的认识），所以可以创建以Object数组为参数的方法，并像下面这样调用：

```java
//:initialization/VarArgs.java
//Using array syntax to create variable argument lists.
class A{}
public class VarArgs{
    static void printArray(Object[] args){
        for(Object obj:args)
            System.out.print(obj+" ");
        System.out.println();
    }
    public static void main(String[] args){
    	printArray(new Object[]{
       		new Integer(47), new Float(3.14), new Double(11.11) 
    	});
    	printArray(new Object[]{"one","two","three"});
    	printArray(new Object[]{new A(), new A(), new A()});
	}
}/*Output:(Sample)
47 3.14 11.11
one two three
A@la46e30 A@3e25a5 A@19821f
*///:~

```

默认行为（如果没有定义toString()方法的话，后面会讲这个方法的）就是打印类的名字和对象的地址。

你可能看到过像上面这样编写的Java SE5之前的代码，它们可以产生可变的参数列表。然而，在Java SE5中，这种盼望已久的特性终于添加了进来，因此你现在可以使用它们来定义可变参数列表了，就像在printArray()中看到的那样：

```java
//:initialization/NewVarArgs.java
//Using array syntax to create variable argument lists.

public class NewVarArgs{
    static void printArray(Object... args){
        for(Object obj:args)
            System.out.print(obj+" ");
        System.out.println();
    }
    public static void main(String[] args){
        //Can take individual elements:
    	printArray(new Integer(47), new Float(3.14), new Double(11.11) );
        printArray(47,3.14F,11.11);
    	printArray("one","two","three");
    	printArray(new A(), new A(), new A());
        //Or an array:
        printArray((Object[])new Integer[]{1,2,3,4});
        printArray();//Empty list is OK
	}
}/*Output:(75% match)
47 3.14 11.11
47 3.14 11.11
one two three
A@la46e30 A@3e25a5 A@19821f
1 2 3 4
*///:~
```

有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。你获取的仍旧是一个数组，这就是为什么print()可以使用foreach来迭代该数组的原因。但是，这不仅仅是从元素列表到数组的自动转换，请注意程序中倒数第二行，一个Integer数组（通过使用自动包装而创建的）被转型为一个Object数组（以便移除编译器警告信息），并且传递给了printArray(),很明显，编译器会发现它已经是一个数组了，所以不会在其上执行任何转换。因此，如果你有一组事物，可以把它们当成列表传递，而如果你已经有了一个数组，该方法可以把它们当作可变参数列表来接受。

该程序的最后一行表明将0个参数传递给可变参数是可行的，当具有可选的尾随参数时，这一特性就会很有用:

```java
//:initialization/OptionTrailingArguments.java
public class OptionalTrailingArguments{
    static void f(int required, String... trailing){
        System.out.print("required: "+required+" ");
        for(String s:trailing)
            System.out.print(s+" ");
        System.out.println();
    }
    public static void main(String[] args){
        f(1, "one");
        f(2, "two", "three");
        f(0);
    }
}/* Output:
required: 1 one
required: 2 two three
required: 0
*///:~
```

这个程序还展示了你如何使用具有Object之外类型的可变参数列表。这里所有的可变参数都必须是String对象。在可变参数列表中可以使用任何类型的参数，包括基本类型。下面的例子也展示了可变参数列表变为数组的情形，并且如果在该列表中没有任何元素，那么转变成数据的尺寸0：

```java
//:initialization/VarargType.java
public class VarargType{
    static void f(Character... args){
        System.out.print(args.getClass());
        System.out.println(" length "+args.length);
    }
    static void g(int... args){
        System.out.print(args.getClass());
        System.out.println(" length "+args.length);
    }
    public static void main(String[] args){
        f('a');
        f();
        g(1);
        g();
        System.out.println("int[]: "+new int[0].getClass());
    }
}/*Output:
Class [Ljava.lang.Character; length 1
Class [Ljava.lang.Character; length 0
Class [I length 1
Class [I length 0
int[]: class [I
*///:~
```



getClass()方法属于Object的一部分，我们将在第14章做全面介绍。它将产生对象的类，并且在打印该类时，可以看到表示该类类型的编码字符串。前导的“[”表示这是一个后面紧随的类型的数组，而紧随的“I”表示基本类型int。

然而，可变参数列表与自动包装机制可以和谐共处。例如：

```java
//:initialization/AutoboxingVarargs.java
public class AutoboxingVarargs{
    public static void f(Integer... args){
        for(Integer i:args)
            System.out.print(i + " ");
        System.out.println();
    }
    public static void main(String[] args){
        f(new Integer(1), new Integer(2));
        f(4,5,6,7,8,9);
        f(10, new Integer(11),12);
    }
}/*Output:
1 2
4 5 6 7 8 9
10 11 12
*///:~
```

请注意，你可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择地将int参数提升为Integer。

可变参数列表使得重载过程变得复杂了，尽管乍一看会显得足够安全：

```java
//:initialization/OverloadingVarargs.java
public class OverloadingVarargs{
    static void f(Character... args){
        System.out.print("first");
        for(Character c:args)
            System.out.print(" "+c);
        System.out.println();
    }
    static void f(Integer... args){
        System.out.print("second");
        for(Integer i:args)
            System.out.print(" "+i);
        System.out.println();
    }
    static void f(Long... args){
        System.out.println("third");
    }
    public static void main(String[] args){
        f('a', 'b', 'c');
        f(1);
        f(2,1);
        f(0);
        f(0L);
        //! f(); //Won't compile -- ambiguous
    }
}/*Output:
first a b c
second 1
second 2 1
second 0
third
*///:~
```



在每一种情况中，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。

但是在不使用参数调用f()时，编译器就无法知道应该调用哪一个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员大感意外.

你可能会通过在某个方法中增加一个非可变参数来解决该问题：

```java
//:initialization/OverloadingVarargs2.java
//(CompileTimeError){won't compile}
public class OverloadingVarargs2{
    static void f(float i, Character... args){
        System.out.println("first");
    }
    static void f(Character... args){
        System.out.print("second"；)
    }
    public static void main(String[] args){
        f(1, 'a');
        f('a','b');
    }
}///:~
```

{CompileTimeError}注释标签把文件排除在了本书的Ant构建之外。如果你手动编译它，就会得到下面的错误信息：

```
reference to f is ambiguous, both method f(float, java.lang.Character...)
in OverloadingVarargs2 and method f(java.lang.Character...) in
OverloadingVarargs2 match
```

如果你给两个方法都天际一个非可变参数，就可以解决问题了：

```java
//:initialization/OverloadingVarargs3.java

public class OverloadingVarargs3{
    static void f(float i, Character... args){
        System.out.println("first");
    }
    static void f(char c, Character... args){
        System.out.println("second"；)
    }
    public static void main(String[] args){
        f(1, 'a');
        f('a','b');
    }
}/*Output:
first
second
*///:~
```

你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它。

## 5.9 枚举类型

在Java SE5 中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。在此之前，你需要创建一个整型常量集，但是这些枚举值并不会必然地将其自身的取值限制在这个常量集的范围之内，因此它们显得更有风险，且更难以使用。枚举类型属于非常普遍的需求，C、C++和其他语言都已经拥有它了。在Java SE5之前，Java程序员在需要使用枚举类型时，必须了解很多细节并需要格外仔细，以正确地产生enum的效果。现在Java也有了enum，并且它的功能比C/C++中的枚举类型要完备得多。下面是一个简单的例子：

```java
//:initialization/Spiciness.java
public enum Spiciness{
    NOT, MILD, MEDIUM, HOT, FLAMING
}///:~
```

这里创建了一个名为Spiciness的枚举类型，它具有5个具名值。由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果在一个名字中有多个单词，用下划线将它们隔开）。

为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例：

```java
//:initialization/SimpleEnumUse.java
public class SimpleEnumUse{
    public static void main(String[] args){
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}/* Output:
MEDIUM
*///:~
```

在你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法，以便你可以很方便地显示某个enum实例的名字，这正是上面的打印语句如何产生其输出的答案。编译器还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组：

```java
//:initialization/EnumOrder.java
public class EnumOrder{
    public static void main(String[] args){
        for(Spiciness s : Spiciness.values())
            System.out.println(s+", ordinal "+s.ordinal());
    }
}/*Output:
NOT, ordinal 0
MILD, ordinal 1
MEDIUM, ordinal 2
HOT, ordinal 3
FLAMING, ordinal 5
*///:~
```

尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应的类时，产生了某些编译器行为，因此在很大程度上，你可以将enum当做其他任何类来处理。事实上，enum确实是类，并且具有自己的方法。

enum有一个特别使用的特性，即它可以在switch语句内使用。由于switch是要在优先的可能值集合中进行选择，因此它与enum正是绝佳的组合。请注意enum的名字是如何能够倍加清楚地表明程序意欲何为的。

大体上，你可以将enum用做另外一种创建数据类型的方式，然后直接将所得到的类型拿来使用。这正是关键所在，因此你不必过多地考虑它们。在Java SE5引进enum之前，你必须花费大量的经历去保证与其等价的枚举类型是安全可用的。

我们将在第19章更加深入地讨论enum。

# 第6章 访问权限控制

访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。

如果你把一个代码段放到了某个位置，等过一会儿回头再看时，有可能会发现有更好的方式去实现相同的功能。这正是重构的原动力之一，**重构**即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。

但你想改变改变代码，而消费者（客户端程序员）需要你的代码在某些方面保持不变。因此你想改变代码，而他们却想让代码保持不变。由此而产生了在面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”。

这对类库（library）而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，他们并不需要改写代码。从另一方面来说，类库的开发者必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。

这一目标可以通过约定来达到。例如，类库开发者必须同意在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端的代码。但是，与之相反的情况会更加棘手。在有域（即数据成员）存在的情况下，类库开发者要怎样才能知道究竟都有哪些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。

为了解决这一问题，Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。访问权限控制的等级，从大权限到最小权限依次为：public、protected、包访问权限（没有关键词）和private。根据前述内容，读者可能会认为，作为一名类库设计员，你会尽可能将一切方法都定为private，而仅向客户端程序员公开你愿意让他们使用的方法。这样做是完全正确的，尽管对于那些经常使用别的语言（特别是C语言）编写程序并在访问事物时不受任何限制的人而言，这与它们的直觉相违背。

不过，构件类库的概念以及对于谁有权取用该类库构件的控制问题都还是不完善的。其中仍旧存在着如何将构件捆绑到一个内聚的类库单元中的问题。对于这一点，Java用关键字package加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。为此，要开始学习本章，首先要学习如何将类库构件置于包中，然后就会理解访问权限修饰词的全部含义。

## 6.1 包：库单元

我们之所以要导入，就是要提供一个管理名字空间的机制。由于名字之间的潜在冲突，在Java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情。

书中大多数示例实际上已经位于包中了：即**未命名**包，或称为**默认包**。不过如果你正在准备编写对在同一台机器上共存的其他Java程序友好的类库或程序的话，就需要考虑如何防止类名称之间的冲突问题。

当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转移单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。

### 6.1.1 代码组织

当编译一个.java 文件时，在 .java 文件中的每个类都会有一个输出文件，而该输出文件的名称与.java文件中每个类的名称相同，只是多了一个后缀名.class。因此，在编译少量.java文件之后，会得到大量的.class文件。如果用编译型语言编写过程序，那么对于编译器产生一个中间文件（通常是一个obj文件），然后再与通过链接器（用以创建一个可执行文件）或类库产生器（librarian, 用以创建一个类库）产生的其他同类文件捆绑在一起的情况，可能早已司空见惯。但这并不是Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR, 使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。

类库实际上是一组类文件。其中每个文件都有一个public类，以及任意数量的非public类。因此每个文件都有一个构件。如果希望这些构件（每一个都有它们自己的独立的.java和.class文件）从属于同一个群组，就可以使用关键字package。

如果使用package语句，它必须是文件中除注释以外的第一句程序代码。在文件起始处写：

```java
package access;
```

就表示你在声明该编译单元是名为access的类库的一部分。或者换种说法，你在声明该编译单元中的public类名称是位于access名称的保护伞下。任何想要使用该名称的人都必须使用前面给出的选择，指定全名或者与access结合使用关键字import。（请注意，Java包的命名规则全部使用小写字母，包括中间的字也是如此。）

例如，假设文件的名称是MyClass.java,这就意味着在该文件中有且仅有一个public类，该类的名称必须是MyClass（注意大小写）：

```java
//:access/mypackage/MyClass.java
package access.mypackage;

public class MyClass{
    // ...
}///:~
```

现在，如果有人想用MyClass或者是access中的任何其他public类，就必须使用关键import来使access中的名称可用

。另一个选择是给出完整的名称：

```java
//:access/QualifiedMyClass.java
public class QualifiedMyClass{
    public static void main(String[] args){
        access.mypackage.MyClass m = new access.mypackage.MyClass();
    }
}///:~
```

关键字import可使之更加简洁：

```java
//:access/ImportedMyClass.java
import access.mypackage.*;

public class ImportedMyClass{
    public static void main(String[] args){
        MyClass m = new MyClass();
    }
}///:~
```

身为一名类库设计员，很有必要牢记：package和import关键字允许你做的，是做单一的全局名字空间分隔开，使得无论多少人使用Internet以及Java开始编写类，都不会出现名称冲突问题。

### 6.1.2 创建独一无二的包名

读者也许会发现，既然一个包从未真正将被打包的东西包装成单一的文件，并且一个包可以由许多.class文件构成，那么情况就有点复杂了。为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决这一问题。这是Java解决混乱问题的一种方式，读者还会在我们介绍jar工具的时候看到另一种方式。

将所有的文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称以及怎样查找有可能隐藏于目录结构中某处的类。这些任务是通过将.class文件所在的路径位置编码成域名。如果你遵照管理，Internet域名应是独一无二的，因此你的package名称也将是独一无二的，也就不会出现名称冲突的问题了（也就是说，只有在你将自己的域名给了别人，而他又以你曾经使用过的路径名称来编写Java程序代码时，才会出现冲突）。当然，如果你没有自己的域名，你就得构造一组不大可能与他人重复的组合（例如你的姓名），来创立独一无二的package名称。如果你打算发布你的Java程序代码，稍微花点力气去取得一个域名，还是很有必要的。

此技巧的第二部分是把package名称分解为你机器上的一个目录。所以当Java程序运行并且需要加载.class 文件的时候，它就可以确定.class文件在目录上所处的位置。

Java解释器的运行过程如下：首先，找出环境变量CLASSPATH（可以通过操作系统来设置，有时也可通过安装程序——用来在你的机器上安装Java或基于Java的工具——来设置）。CLASSPATH包含一个或多个目录，用做查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH根中产生一个路径名称（于是，package foo.bar.baz就变成为foo\bar\baz或foo/bar/baz或其他，这一切取决于操作系统）。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。（解释器还会去查找某些涉及Java解释器所在位置的标准目录。）

为了理解这一点，以我的域名MindView.net为例。把它的顺序倒过来，并且将其全部转换为小写，net.mindview就成了我所创建的类的独一无二的全局名称。（com、edu、org等扩展名先前在Java包中都是大写的，但在Java2中一切都已改观，包的整个名称全都变成了小写。）若我决定再创建一个名为simple的类库，我可以将该名称进一步细分，于是我可以得到一个包的名称如下：

```java
package net.mindview.simple;
```

现在，这个包名称就可以用做下面两个文件的名字空间保护伞了：

```java
//:net/mindview/simple/Vector.java
//Creating a package.
package net.mindview.simple;

public class Vector{
    public Vector(){
        System.out.println("net.mindview.simple.Vector");
    }
}///:~
```

如前所述，package语句必须是文件中的第一行非注释程序代码，第二个文件看起来也极其相似：

```java
//:net/mindview/simple/list.java
//Creating a package.
package net.mindview.simple;

public class List{
    public List(){
        System.out.println("net.mindview.simple.List");
    }
}///:~
```

如果沿文件的路径往回看，可以看到包的名称com.bruceekel.simple，但此路径的第一部分怎样办呢？它将由环境变量CLASSPATH关照，在我的机器上是：

```
CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT
```

可以看到，CLASSPATH可以包含多个可供选择的查询路径。

但在使用JAR文件时会有一点变化。必须在类路径中将JAR文件的实际名称写清楚，而不仅是指明它所在位置的目录。因此，对于一个名为grape.jar的JAR文件，类路径应包括：

```
CLASSPATH=.;D\JAVA\LIB;C:\flavors\grape.jar
```

一旦类路径得以正确建立，下面的文件就可以放于任何目录之下：

```java
//:access/LibTest.java
// Uses the library.
import net.mindview.simple.*;

public class LibTest{
    public static void main(String[] args){
        Vector v = new Vector();
        List l = new List();
    }
}/*Output:
net.mindview.simple.Vector
net.mindview.simple.List
*///:~
```

当编译器碰到simple库的import语句时，就开始在CLASSPATH所指定的目录中查找，查找子目录net\mindview\simple，然后从以编译的文件中找出名称相符者（对Vector而言是Vector.class，对List而言是List.class）。请注意，Vector和List中的类以及要使用的方法都必须是public的。

对于使用Java的新手而言，设立CLASSPATH是很麻烦的一件事（我当初使用时就是这样的），为此，Sun将Java2中的JDK改造得更聪明了一些。在安装后你会发现，即使你未设立CLASSPATH，你也可以编译并运行基本的Java程序。然而，要编译的运行本书的源码包，就得向你的CLASSPATH中添加本书程序代码树中的基目录了。

### 冲突

如果将两个含有相同名称的类库以“*”形式同时导入，将会出现什么情况呢？例如，假设某程序这样写：

```java
import net.mindview.simple.*;
import java.util.*;
```

由于java.util.*也含有一个Vector类，这就存在潜在的冲突。但是只要你不写那些导致冲突的程序代码，就不会有什么问题——这样很好，否则就得做很多的类型检查工作来防止那些根本不会出现的冲突。

如果现在要创建一个Vector类的话，就会产生冲突；

```java
Vector v = new Vector();
```

这行到底取用的是哪个Vector类？编译器不知道，读者同样也不知道。于是编译器提出错误信息，强制你明确指明。举例说明，如果想要一个标准的Java Vector类，就得这样写：

```java
java.util.Vector v =new java.util.Vector();
```

或者，可以使用单个类导入的形式来防止冲突，只要你在同一个程序中没有使用有冲突的名字（在使用了有冲突名字的情况下，必须返回到指定全名的方式）。

### 6.1.3 定制工具库

具备这些知识以后，现在就可以创建自己的工具库来减少或消除重复的程序代码了。例如，我们已经用到的System.out.println()的别名也可以减少输入负担，这种机制可以用于名为Print的类中，这样，我们在使用该类时可以用一个更具可读性的静态import语句来导入：

```java
//:net/mindview/util/print.java
//print methods that can be used without qualifiers.
//using Java SE5 static imports:
package net.mindview.util;
import java.io.*;

public class Print{
    //Print with a new line:
    public static void print(Object obj){
        System.out.println(obj);
    }
    //Print a newline by itself;
    public static void print(){
        System.out.println();
    }
    //Print with no line break;
    public static void printnb(Object obj){
        System.out.print(obj);
    }
    //The new Java SE5 printf()(from C):
    public static PrintStream
        printf(String format, Object... args){
        return System.out.printf(format, args);
    }
}///:~
```

可以使用打印便捷工具来打印String，无论是需要换行(print())还是不需要换行(printnb())。

可以猜到，这个文件的位置一定是在某个以一个CLASSPATH位置开始，然后接着是net/mindview的目录下。编译完之后，就可以用import static语句在你的系统上使用静态的print()和printnb()方法了。

这个类库的第二个构件可以是在第4章引入的range()方法，它使得foreach语法可以用于简单的整数序列：

```java
//:net/mindview/util/Range.java
//Array creation methods that can be used without qualifiers.
//using Java SE5 static imports:
package net.mindview.util;

public class Range{
    //Produce a sequence [0..n)
    public static int[] range(int n){
        int[] result = new int[n];
        for(int i=0;i<n;i++)
            result[i]=i;
        return result;
    }
    //Produce a sequence[start..end)
    public static int[] range(int start,int end){
        int sz = end - start;
        int[] result = new int[sz];
        for(int i=0;i<sz;i++)
            result[i] = start + i;
        return result;
    }
    //Produce a sequence [start..end) increamenting by step
    public static int[] range(int start, int end , int step){
        int sz=(end-start)/step;
        int[] result = new int[sz];
        for(int i=0;i<sz;i++)
            result[i] = start+(i*step);
        return result;
    }
}///:~
```

从现在开始，你无论何时创建了有用的新工具，都可以将其添加到你自己的类库中。你将看到在本书中还有更多的构件添加到了net.mindview.util类库中。

### 6.1.4 用import改变行为

Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能够切换开关并产生不同的行为。Java去掉此功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题的，即程序代码的不同部分是根据不同的平台来编译的。由于Java本身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。

条件编译还有其他一些有价值的用途。调试就是一个很常见的用途。调试功能在开发过程中是开启的，而在发布的产品中是禁用的。可以通过修改被导入的package的方法来实现这一目的，修改的方法是将你程序中用到的方法从调试版改为发布版。这一技术可以适用于任何种类的条件代码。

### 6.1.5 对使用包的忠告

务必记住，无论何时创建包，都已经在给定包的名称的时候隐含地指定了目录结构。这个包必须位于其名称所指定的目录之中，而该目录必须在以CLASSPATH开始的目录中可以查询到的。最初使用关键字package，有可能会有一点不顺，因为除非遵守“包的名称对应目录路径”的规则，否则将会收到许多出乎意料的运行时信息，告知无法找到特定的类，哪怕是这个类就位于同一个目录中。如果你收到类似信息，就用注释掉package语句的方法试一下，如果这样程序就能运行的话，你就可以知道问题出在哪里了。

注意，编译过的代码通常放置在与源代码的不同目录中，但是必须保证JVN使用CLASSPATH可以找到该路径。

## 6.2 Java访问权限修饰词

### 6.2.1 包访问权限

默认访问权限没有任何关键字，但通常是指包访问权限（有时也表示称为friendly）。由于一个编译单元（即一个文件），只能隶属于一个包，所以经由包访问权限，处于同一个编译单元中的所有类彼此之间都是自动可访问的。

取得对某成员的访问权的唯一途径是：

1. 使该成员成为public。
2. 通过不加访问权限修饰词并将其他类放置于同一个包内的方式给成员赋予包访问权。
3. 在第7章将会介绍继承技术，届时读者将会看到继承而来的类既可以访问public成员也可以访问protected成员。
4. 提供访问器（accessor）和变异器（mutator）方法（也称作get/set方法），以读取和改变数值。正如将在第22章中看到的，对OOP而言，这是最优雅的方式，而且这也是JavaBeans的基本原理。

### 6.2.2 public：接口访问权限

使用关键字public，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。

不要错误地认为Java总是将当前目录视作是查找行为的起点之一。如果你的CLASSPATH之中缺少一个“.”作为路径之一的话，Java就不会查找那里。

### 默认包

令人吃惊的是，下面的程序代码虽然看起来破坏了上述规则，但它仍可以编译：

```java
//:access/Cake.java
//Accesses a class in a separate compilation unit.

class Cake{
    public static void main(String[] args){
        Pie x = new Pie();
        x.f();
    }
}/* Output:
Pie.f()
*///:~
```

在第二个处于相同目录的文件中：

```java
//:access/Pie.java
//The other class.
class Pie{
    void f(){
        System.out.println("Pie.f()");
    }
}///:~
```

最初或许会认为两个文件毫不相关，但Cake却可以创建一个Pie对象并调用它的f()方法！通常会认为Pie和f()享有包访问权限，因而是不可以为Cake所用的。它们的确享有包访问权限，但这只是部分正确的。Cake.java 可以访问它们的原因是因为它们同处于相同的目录并且没有给自己设定任何包名称。Java将这样的文件自动看做是隶属于该目录的默认包之中，于是它们为该目录中所有的文件都提供了包访问权限。

### 6.2.3 private：你无法访问

关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于统一个包内的其他类是不以访问private成员的，因此这等于说是自己隔离了自己。从另一方面说，让许多人共同合作来创建一个包也是不大可能的，为此private就允许你随意改变该成员，而不必考虑这样做是否会影响到包内的其他的类。

默认的包访问权限通常已经提供了充足的隐藏措施。请记住，使用类的客户端程序员是无法访问包访问权限成员的。然而，事实很快就会证明，对private的使用多么的重要，在多线程环境下更是如此（正如将在第21章看到的）。

此处有一个使用private的示例。

```java
//:access/IceCream.java
//Demonstrates "private" keyword.
class Sundae{
    private Sundae(){}
    static Sundae makeASundae(){
        return new Sundae();
    }
    
}
public class IceCream{
    public static void main(String[] args){
        //!Sundae x = new Sundae();
        Sundae x = Sundae.makeASundae();
    }
}///:~
```

这是一个说明private终有其用武之地的示例：可能想控制如何创建对象，并组织别人直接访问某个特定的构造器（或全部构造器）。在上面的例子中，不能通过构造器来创建Sundae对象，而必须调用makeASundae()方法来达到此目的（此例还有一个效果：既然默认构造器是唯一定义的构造器，并且它是private的，那么它将阻碍对此类的继承（我们将在后面介绍这个问题））。

任何可以肯定只是该类的一个“助手”方法的方法，都可以把它指定为private，以确保不会在包内的其他地方误用到它，于是也就放置了你会去改变或删除这个方法。将方法指定为private确保了你有这种选择权。

这对于类中的private域同样使用。除非必须公开底层实现细目（此种情况很少见），否则就应该将所有的域指定为private。然而不能因为在类中某个对象的引用是private，就认为其他的对象无法拥有该对象的public引用（参见本书的在线补充材料以了解有关别名机制的话题）。

### 6.2.4 protected：继承访问权限

关键字protected处理的是继承的概念，通过继承可以利用一个现有类——我们将其称为基类，然后将新成员添加到该现有类中而不必碰该现有类。还可以改变该类的现有成员的行为。为了从现有类中继承，需要声明新类extends（扩展）了一个现有类，就像这样：

```java
class Foo extends Bar{
```

类定义中其他部分看起来都是一样的。

如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员。（当然，如果在统一个包内执行继承工作，就可以操纵所有的拥有包访问权限的成员。）有时，基类的创建者会希望有某个特定成员，把它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。protected也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。

## 6.3 接口和实现

访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称为是**封装**（然而，人们经常只单独将具体实现的隐藏称为封装）。其结果是一个同时带有特征和行为的数据类型。

出于两个很重要的原因，访问权限控制将权限的边界花在了数据类型的内部。第一个原因是要设定客户端程序员可以使用和不可以使用的界限。可以在结构中建立自己的内部机制，而不必担心客户端程序员会偶然地将内部机制当作是他们可以使用的接口的一部分。

这个原因直接引出了第二个原因，即将接口和具体实现进行分离。

为了清楚起见，可能会采用一种将public成员置于开头，后面跟着protected、包访问权限和private成员的创建类的形式。主要做的好处是类的使用者可以从头读起，首先阅读对他们而言最为重要的部分，等到遇见作为内部实现细节的非public成员时停止阅读。

这样做仅能使程序阅读起来稍微容易一些，因为接口和具体实现仍旧混在一起。也就是说，仍能看到源代码——实现部分，因为它就在类中。另外，javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给某个类的使用者实际上是类浏览器的任务。类浏览器是一种以非常有用的方式来查阅所有可用的类，并告诉你用它们可以做些什么（也就是显示出可用成员）的工具。在Java中，用Web浏览器浏览JDK文档可以得到使用类浏览器的相同效果。

## 6.4 类的访问权限

在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用于整个类的定义来达到目的。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。

为了控制某个类的访问权限，修饰词必须出现于关键字class之前。因此可以像下面这样声明：

```java
public class Widget{
```

现在如果库的名字是access，那么任何客户端程序员都可以通过下面的声明访问Widget；

```java
import access.Widget;
```

或

```java
import access.*;
```

然而，这里还有一些额外的限制：

1. 每个编译单元（文件）都只能有一个public类。这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出出错信息。
2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。
3. 虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。（尽管随意命名会使得人们在阅读和维护代码时产生混淆。）

在创建一个包访问权限的类时，仍旧是在将该类的域声明为private时才有意义——应尽可能地总是将域指定为私有的，但是通常来说，将与类（包访问权限）相同的访问权限赋予方法也是很合理的。既然一个有包访问权限的类通常只能被用于包内，那么如果对你有强制要求，在此种情况下，编译器会告诉你，你只需要将这样的类的方法设定为public就可以了。

请注意，类既不可以是private的（这样会使得除该类之外，其他任何类都不可以访问它），也不可以是protected的。（事实上，一个内部类可以是private或是protected的，但那是一个特例。这将在第10章中介绍到）所以对于类的访问权限，仅有两个选择：包访问权限或public。如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而组织任何人创建该类的对象，但有一个例外，就是你在该类的static成员内部可以创建。

如果把构造器指定为private，那么别人该如何使用这个类呢？1.创建一个static方法，它创建一个新的对象并返回一个对它的引用。2.用到了所谓的单例(singleton)设计模式，这是因为你始终只能创建它的一个对象。

如果包访问权限的类的某个static成员是public的话，则客户端程序员仍旧可以调用该static成员，尽管他们并不能生成该类的对象。

# 第7章 复用类

复用代码是Java众多引人注目的功能之一。但想要成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。

组合：只在新的类中产生现有类的对象。

继承：按照现有类的类型来创建新类。

## 7.1 组合语法

toString()很特殊。每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String而你却只有一个对象时，该方法便会被调用。

初始化引用，可以在代码中的下列位置进行：

1. 定义对象的地方。
2. 类的构造器中。
3. 就在正要使用这些对象之前，这种方式称为**惰性初始化**。
4. 使用实例初始化。

## 7.2 继承语法

除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。

extends关键字 自动得到基类中所有的域和方法。

可以为每个类都创建一个main()方法。这种在每个类中都设置一个main()方法的技术可使每个类的单元测试都变得简便易行。而且在完成单元测试之后，也无需剔除main(),可以将其留待下一次测试。

即使是一个程序含有多个类，也只有命令行调用的那个类的main()方法会被调用。即使一个类只具有包访问权限，其public main()仍然是可访问的。

Cleanser中的所有方法必须是public的。其他包中的某个类若要从Cleanser类中继承，则只能访问public成员。所以，为了继承，一般的规则是将所有数据成员都指定为private，将所有的方法指定为public（稍后将会学到，protected成员也可以借助导出类来访问）。

super关键字

### 7.2.1 初始化基类

构建过程是从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。

### 带参数的构造器

调用基类构造器必须是你在导出类构造器中要做的第一件事。

## 7.3 代理

第三种关系称为代理，Java并没有提供对它的直接支持。这是继承与组合的中庸之道，因为我们讲一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露该成员对象的所有方法（就像继承）。

## 7.4 结合使用组合和继承

虽然编译器强制你去初始化基类，而且要求你要在构造器起始处就要这么做，但是它并不监督你必须将成员对象也初始化，因此在这一点上你自己必须时刻注意。

### 7.4.1 确保正确清理

Java没有C++中析构函数的概念。

**保护区（guarded region）**，这意味着它需要被特殊处理。其中一项特殊处理就是无论try块是怎样退出的，保护区后面的finally子句中的代码总是要被执行的。

在清理方法中，还必须注意对基类清理方法和成员对象清理方法的调用顺序，以防止某个子对象依赖于另一个子对象的情形发生。

亲自处理垃圾清理时，得多做努力并多家小心。一旦设计垃圾回收，能够信赖的事就不会很多了。最好的办法是出了内存以外，不能依赖垃圾回收器去做任何事。如果需要进行清理，最好是编写你自己的清理方法，但不要使用finalize().

### 7.4.2 名称屏蔽

如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点与C++不同）。

即使子类引入一个新的重载方法（在C++中若要完成这工作则需要屏蔽基类方法），超类的所有重载方法都是可用的。使用与基类完全相同的特征签名和返回类型来覆盖具有相同名称的方法，是一件及其平常的事。

Java SE 5 新增加了@Override注解，他并不是关键字，但是可以把他当关键字使用。@Override可以防止你在不想重载时意外地进行了重载。

## 7.5 在组合与继承之间选择

组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。

在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。

“is-a”的关系用继承来表达，“has-a”的关系则是用组合来表达。

## 7.6 protected关键字

关键字protected指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或其他位于同一包内的类来说，它却是可以访问的。”（protected也提供了包内访问权限。）

## 7.7 向上转型

### 7.7.1 为什么称为向上转型

传统的类继承图的绘制方法

由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。唯一可能发生的事情是丢失方法。

### 7.7.2 再论组合与继承

在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，并使用该类的对象。也可以运用组合技术使用现有类来开发新的类；而继承技术其实是不太常用的。慎用继承技术，其使用场合仅限于你确信使用该技术确实有效的情况。到底改用组合还是用继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的。

## 7.8 final数据

1. 一个永不改变的编译时常量

2. 一个在运行时被初始化的值，而你不希望它被改变。

在Java中，这类常量必须是基本数据类型，并且以final关键字表示。在对这个常量进行定义的时候，必须对其进行赋值。

一个既是static又是final的域只占据一段不能改变的存储空间。

对于基本类型，final使其数值恒定不变；而对于对象引用，final使其引用恒定不变。然而对象其本身确实可以被修改的，Java并未提供使任何对象恒定不变的途径（但可以自己编写类以实现）。这一限制适用于数组，也就是对象。

定义为public，则可以用于包之外；定义为static，则强调只有一份；定义为final，则说明它是一个常量。请注意，带有恒定初始值（即，编译期常量）的final static基本类型全用大写字母命名，并且字与字之间用下划线隔开。

我们不能因为某数据是final的就认为在编译时可以知道它的值。比如final数据赋值使用了随机数的情况就不能在编译期知道。

static的，在装载时初始化，而不是每次创建新对象时都初始化。

### 空白final

空白final是指被声明final但又未给定初值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。

必须在域的定义处或者每个构造器内用表达式对final赋值，这正是final域在使用前总是被初始化的原因所在。

### final 参数

Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。

参数被指明final时，你可以读参数，但却无法修改它。这一特性主要用来向匿名内部类传递数据。

### 7.8.2 final方法

原因有二：一，把方法锁定，以防止任何继承类修改它的含义。确保继承中使方法行为保持不变，并且不会被覆盖。二，过去建议使用final方法的第二个原因是效率。	内嵌调用 	最近的Java版本中，虚拟机（特别是HotSpot技术）可以探测到这些情况，并优化去掉这些效率反而降低的额外内嵌调用。所以不再需要final方法来进行优化了。

### final和private关键字

“覆盖”只有在某方法是基类的接口的一部分时才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同方法。如果某方法是private，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。如果在导出类中以相同名称生成一个public、protected或包访问权限方法的话，该方法就不会产生基类中出现的“仅具有相同名称”的情况。此时你并没有覆盖该方法，而仅是生成了一个新的方法。由于private方法无法触及而且能有效隐藏，所以除了把它看成是因为它归属的类的组织结构的原因而存在外，其他任何事物都不需要考虑到它。

### 7.8.3 final类

某个类整体定义为final时，就表明你不打算继承该类，而且也不允许别人这么做。

final类的域可以根据个人意愿选择是不是final。无论类是否被定义为final，相同的规则都适用于定义为final的域。

### 7.8.4 有关final的忠告

Vector和Stack

Hashtable

## 7.9 初始化及类的加载

类的代码在初次使用时才加载。这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或static方法时，也会发生加载。

初次使用之处也是static初始化发生之处。所有static对象和static代码都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化。当然，定义为static的东西只会被初始化依次。

### 7.9.1 继承与初始化

# 第8章 多态

在面向对象的程序设计语言中，**多态**是继数据抽象和继承之后的第三种基本特征。

多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能创建可扩展的程序。

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过细节“私有化”把接口和实现分离开来。这种类型的组织机制对于那些拥有过程化程序设计背景的人来说容易理解。而多态的作用则是消除类型之间的耦合关系。继承运行将对象视为它自己本身的类型或其基类型来处理。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。

多态，也被称作**动态绑定**、**后期绑定**或**运行时绑定**。

## 8.1 再论向上转型

### 8.1.1 忘记对象类型

我们只写这样一个简单方法，它仅接受基类作为参数，而不是那些特殊的导出类。我们不管导出类的存在，编写的代码只是与基类打交道。

这正是多态所允许的。

## 8.2 转机

### 8.2.1 方法调用绑定

将一个方法调用同一个方法主题关联起来被称作**绑定**。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做**前期绑定**。

**后期绑定**含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做**动态绑定**或**运行时绑定**。如果一种语言想实现后期绑定，就必须具有某种机制以便在运行时能判断对象的类型，从而调用恰当的方法。

==Java中除了static方法和final方法（private方法属于final方法）之外==，其他所有的方法都是后期绑定。

声明final还有一点重要原因：有效“关闭”动态绑定，或者说，告诉编译器不需要对它进行动态绑定。但最好根据设计来决定是否使用final，而不是处于试图提高性能的目的。

### 8.2.2 产生正确的行为

在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。

### 8.2.3 可扩展性

### 8.2.4 缺陷：“覆盖”私有方法

只有非private方法才可以覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类中的private方法，最好采用不同的名字

### 8.2.5 缺陷：域与静态方法

只有普通的方法可以是多态的。如果你直接访问某个域，这个访问就会在编译期进行解析，就像下面的示例所演示的：

``` java
//:polymorphism/FieldAccess.java
//Direct field access is determined at compile time.
class Super{
    public int field =0;
    public int getField(){return field;}
}
class Sub extends Super{
    public int field = 1;
    public int getField(){return field;}
    public int getSuperField(){return super.field;}
}
public class FieldAccess{
    public static void main(String[] args){
        Super sup = new Sub();//Upcast
        System.out.println("sup.field = " + sup.field + ",sup.getField() = " + sup.getField());
        Sub sub = new Sub();
        System.out.println("sub.field = " + sub.field + ",sub.getField() = " + sub.getField() + ", sub.getSuperField() = " + sub.getSuperField());
    }
}/*Output:
sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
*///:~
```

当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的。在本例中，为Super.field和sub.field分配了不同的存储空间。这样，Sub实际上包含两个称为field的域。因此，为了得到Super.field，必须显式地指明super.field。

尽管这看起来好像会成为一个容易令人混淆的问题，但是在实践中，它实际上从来不会发生。首先，你通常会将所有的域都设置成private，因此你不能直接访问他们，其副作用是只能通过方法来访问。另外，你可能不会对基类中的域和导出类中的域赋予相同的名字，因为这种做法容易令人混淆。

如果某个方法是静态的，它的行为就不具有多态性。

静态方法是与类，而并非与单个对象相关联的。

## 8.3 构造器和多态

尽管构造器并不具有多态性（它们实际上是static方法，只不过该static声明是隐式的），但还是非常有必要理解构造器怎样通过多态在复杂的层次结构中运作，这一理解将有助于大家避免一些令人不快的困扰。

### 8.3.1 构造器的调用顺序

基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。编译器强制每个导出类部分都必须调用构造器的原因：基类成员是private，只有基类构造器具有恰当的知识和权限来对自己的元素进行初始化，因此，必须令所有构造器都得到调用，否则就不可能正确构造完整对象。在导出类的构造器主体中，如果没有明确指定调用某个基类构造器，它就会默默地调用默认构造器，如果不存在默认构造器，编译器就会报错。

复杂对象调用构造器遵照下面顺序：

1. 调用基类构造器。这个步骤会不断地递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最低层的导出类。
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

但遗憾的是，这种做法并不适用所有的情况，这一点我们会在下一节看到。

### 8.3.2 继承与清理

万一某个子对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反。对于字段，则意味着与声明的顺序相反（因为字段的初始化是按照声明的顺序进行的）。对于基类（遵循C++中析构函数的形式），应该首先对其导出类进行清理，然后才是基类。这是因为导出类的清理可能会调用基类的某些方法。

**引用计数**来跟踪仍旧访问着共享对象的对象数量

### 8.3.3 构造器内部的多态方法的行为

如果一个构造器内部调用正在构造对象的某个动态绑定方法，那会发生什么情况呢？

如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用的效果可能相当难于预料，因为被覆盖的方法在对象完全构造之前就会被调用。这可能会造成一些难于发现的隐藏错误。

从概念上讲，构造器的工作实际上是创建对象（这并非是一件平常的工作）。在任何构造器内部，整个对象可能只是部分形成——我们只知道基类对象已经进行初始化。如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍然是没有被初始化的。然而，一个动态绑定方法的调用却会向外深入到继承层次结构内部，它可以调用导出类里的方法。如果我们是在构造器内部这样做，那么就可能会调用某个方法，而这个方法所操纵的成员可能还未进行初始化——这肯定会招致灾难。

初始化的实际过程是：

1. 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。
2. 如前所述那样调用基类构造器。此时，调用被覆盖后的draw()方法（要在调用RoundGlyph构造器之前调用），由于步骤一的缘故，我们此时会发现radius的值为0。
3. 按照声明的顺序调用成员的初始化方法。
4. 调用导出类的构造器主体。

这样做有一个优点，那就是==所有东西都至少初始化成零（或者是某些特殊数据类型中与“零”等价的值）==，而不是仅仅留作垃圾。其中包括通过“组合”而嵌入一个类的内部对象引用，其值是null，所以如果忘记为该引用进行初始化，就会在运行时出现异常。查看输出结果时，会发现所有东西的值都会是零，这通常也是发现问题的证据。

另一方面，我们应该对这个程序的结果相当震惊。在逻辑方面，我们做的已经十分完美，而它的行为却不可思议地错了，而且编译器也没有报错。（在这种情况下，C++语言会产生更加合理的行为。）诸如此类的错误会很容易被人忽略，而且要花很长时间才能发现。

因此，编写构造器时有一条有效的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。在构造器内唯一能够安全调用的那些方法是基类的fianl方法（也适用于private方法，它们自动属于final方法）。这些方法不能被覆盖，因此也就不会出现上述令人惊讶的问题。

## 8.4 协变返回类型

Java SE5中添加了协变返回类型，它表示导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。

Java SE5与Java较早版本之间的主要差异就是较早的版本将强制process()的覆盖版本必须返回Grain，而不能返回Wheat，尽管Wheat是从Grain导出的，因而也应该是一种合法的返回类型。协变返回类型允许返回更具体的Wheat类型。

## 8.5 用继承进行设计

更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时。组合不会强制我们的程序设计进入继承的层次结构中。而且，组合更加灵活，因为它可以动态选择类型（因此也就选择了行为）；相反，继承在编译时就需要知道确切类型。

**状态模式**

一条通用的准则是：“用继承表达行为间的差异，并用字段表达状态上的变化”。

### 8.5.1 纯继承与扩展

采用“纯粹”的方式来创建继承层次结构似乎是最好的方式。也就是说，只有在基类中已经建立的方法才可以在导出类中被覆盖。

纯替代，因为导出类可以完全代替基类，而在使用它们时，完全不需要知道关于子类的任何额外信息。

### 8.5.2 向下转型与运行时类型识别

由于向上转型会丢失具体的类型信息，所以我们就想，通过向下转型应该能够获取类型信息。然而，我们知道向上转型是安全的，因为基类不会具有大于导出类的接口。但是对于向下转型，我们无法知道确实是哪一个子类。

在某些程序设计语言（如C++）中，我们必须执行一个特殊的操作来获得安全的向下转型。但是在Java语言中，所有转型都会得到检查！所以即使我们只是进行一次普通的加括号形式的类型转换，在进入运行期时仍然会对其进行检查，以便保证它的确是我们希望的那种类型。如果不是，就会返回一个ClassCastException（类转型异常）。这种在运行期间对类型进行检查的行为称作“运行时类型识别”（RTTI）。

# 第9章 接口

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。

这种机制在编程语言中并不通用。例如C++对这些概念只有间接的支持。在Java 中存在语言关键字这个事实表明人们认为这些思想是很重要的，以至于要提供对它们的直接支持。

## 9.1 抽象类和抽象方法

Instrument类的目的是为它的所有导出类创建一个**通用接口**。

不同子类可以用不同方式表示此接口。通用接口建立起一种基本形式，以此表示所有导出类的公共部分。另一种说法是将Instrument类称作**抽象基类**，或简称为**抽象类**。

为此，Java提供一个叫做**抽象方法**的机制，这种方法是不完整的；仅有声明而没有方法体。下面是抽象方法声明所采用的语法：

```java
abstract void f();
```

包含抽象方法的类叫做**抽象类**。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器就会报错）

一个抽象类不完整，那么当我们试图产生该类的对象时，编译器会怎样处理呢？由于为抽象类创建对象是不安全的，所以我们会从编译器那里得到一条出错消息。这样，编译器会确保抽象类的纯粹性，我们不必担心会误用它。

如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类中所有的抽象方法提供方法定义。如果不这样做（可以选择不做），那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。

我们也可能会创建一个没有任何抽象方法的抽象类。考虑这种情况：如果有一个类，让其包含任何abstract方法都显得没有实际意义，而且我们也想要阻止产生这个类的任何对象，那么这时这样做就很有用了。

创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次向上移动。

## 9.2 接口

interface关键字使抽象的概念更向前迈进了一步。abstract关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。interface这个关键字产生了一个完全抽象的类，它根本就没有提供任何具体的实现。它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体，接口只提供了形式，而未提供任何具体实现。

一个接口表示：“所有实现了该特定接口的类看起来都像这样”。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。因此，接口被用来建立类与类之间的**协议**。（某些面向对象编程语言使用关键字protocol来完成这一功能。）

但是，interface不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性。

要想创建一个接口，需要用interface关键字来代替class关键字。就像类一样，可以在interface关键字前面添加public关键字（但仅限于该接口在与其同名的文件中被定义）。如果不添加public关键字，则它只具有包访问权限，这样它就只能在同一个包内可用。接口也可以包含域，但是这些域隐式地是static和final的。

要让一个类遵循某个特定接口（或者是一组接口），需要使用implements关键字，它表示：“interface只是它的外貌，但是现在我要声明它是如何工作的。”除此之外，它看起来还很像继承。

可以选择在接口中显式地将方法声明为public的，但即使你不这么做，它们也是public的。因此，当要实现一个接口时，在接口中被定义的方法必须被定义是public的；否则，它们将值得到默认的包访问权限，这样在方法继承的过程中，其可访问权限就降低了，这是Java编译器所不允许的。

## 9.3 完全解耦

只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类，那么你就会触霉头了。接口可以在很大程度上放宽这种限制，因此，它使得我们可以编写可复用性更好的代码。

创建一个能够根据所传递参数对象的不同而具有不同行为的方法，被称为**策略**设计模式。这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分

复用代码的第一种方式是客户端程序员遵循该接口来编写他们自己的类。

你经常碰到的情况是你无法修改你想使用的类。在这些情况下，可以使用**适配器**设计模式。适配器的代码将接受你所拥有的接口，并产生你所需要的接口。

将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性。

## 9.4 Java中的多重继承

在C++中，组合多个类的接口的行为被称作**多重继承**。在Java中，你可以执行相同的行为，但是只有一个类可以有具体实现；因此，通过组合多个接口，C++中的问题是不会在Java中发生的。

在导出类中，不强制要求必须有一个是抽象的或“具体的”（没有任何抽象方法的）基类。如果要从一个非接口的类继承，那么只能从一个类去继承，其余的基元素都必须是接口。需要将所有的接口名都置于implements关键字之后，用逗号将它们一一隔开。可以继承任意多个接口，并可以向上转型为每个接口，因为每一个接口都是一个独立类型。

前面的例子所展示的就是使用接口的核心原因：为了能够向上转型为多个基类型（以及由此而带来的灵活性）。然而，使用接口的第二个原因却是与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。这就带来了一个问题：我们应该使用接口还是抽象类？如果要创建不带任何方法定义和成员变量的基类，那么第一选择应该使它成为一个接口（该主题在本章的总结中将再次讨论）。

## 9.5 通过继承来扩展接口

通过继承，可以很容易在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。

一般情况下，只可以将extends用于单一类，但是可以引用多个基类接口。就像所看到的，只需用逗号将接口名一一分隔开即可。

### 9.5.1 组合接口时的名字冲突

在前面的例子中，CanFight和ActionCharacter都有一个相同的void fight()方法。这不是问题所在，因为该方法在二者中是相同的。相同的方法不是什么问题，但是如果它们的签名或返回类型不同，又会怎么样呢？

此时困难来了，因为覆盖、实现和重载令人不快地搅在了一起，而且重载方法仅通过返回类型是区分不开的。

在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱，请尽量避免这种情况。

## 9.6 适配接口

接口的一种常见用法就是前面提到的**策略**设计模式，此时你编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的接口。你主要就是要声明：“你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口。”

Readable接口只要求实现read()方法，在read()内部，将输入内容添加到charBuffer参数中，或者在没有任何输入时返回-1。

## 9.7 接口中的域

因为你放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具。在Java SE5之前，这是产生与C或C++中的enum（枚举类型）具有相同效果的类型的唯一途径。

Java标识具有常量初始化值的static final时，会使用大写字母风格（在一个标识符中用下划线来分隔多个单词）。接口中的域自动是public的，所以没有显式地指明这一点。

有了Java SE5，你就可以使用更加强大而灵活的enum关键字，因此，使用接口来群组常量已经显得没什么意义了。

### 9.7.1 初始化接口中的域

在接口中定义的域不能是“空final”，但是可以被非常量表达式初始化。

既然域是static的，它们就可以在类第一次被加载时初始化，这发生在任何域首次被访问时。

当然，这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。

## 9.8 嵌套接口

接口可以嵌套在类或其他接口中。这揭示了许多非常有趣的特性：

```java
//:interfaces/nesting/NestingInterfaces.java
package interfaces.nesting;
class A {
    interface B{
        void f();
    }
    public class BImp implements B{
        public void f(){}
    }
    private class BImp2 implements B{
        public void f(){}
    }
    public interface C{
        void f();
    }
    class CImp implements C{
        public void f(){}
    }
    private class CImp2 implements C{
        public void f(){}
    }
    private interface D{
        void f();
    }
    private class DImp implements D{
        public void f(){}
    }
    public class DImp2 implements D{
        public void f(){}
    }
    public D getD(){return new DImp2();}
    private D dRef;
    public void receiveD(D d){
        dRef = d;
        dRef.f();
    }
}
interface E{
    interface G{
        void f();
    }
	//Redundant "public":
	public interface H{
    	void f();
	}
	void g();
    //Cannot be private within an interface:
    //! private interface I{}
}
public class NestingInterfaces{
    public class BImp implements A.B{
        public void f(){}
    }
    class CImp implements A.C{
        public void f(){}
    }
    //Cannot implement a private interface except within that interface's defining class:
    //! class DImp implements A.D{
    //! 	public void f(){}
    //! }
    class EImp implements E{
        public void g(){}
    }
    class EGImp implements E.G{
        public void f(){}
    }
    class EImp2 implements E{
        public void g(){}
        class EG implements E.G{
            public void f(){}
        }
    }
    public static void main(String[] args){
        A a = new A();
        //Can't access A.D:
        //! A.D ad = a.getD();
        //Doesn't return anything but A.D:
        //! A.DImp2 di2 = a.getD();
        //Cannot access a member of the interface:
        //! a.getD().f();
        //Only another A can do anything with getD();
        A a2 = new A();
        a2.receiveD(a.getD());
    }
}


```



在类中嵌套接口的语法是相当显而易见的，就像非嵌套接口一样，可以拥有publlic和“包访问”两种可视性。

作为一种新添加的方式，接口也可以被实现为private的。（相同的语法既适用于嵌套接口，也适用于嵌套类）那么private的嵌套接口能带来什么好处呢？读者可能会猜想，它只能够被实现为DImp中的一个private内部类，但是A.DImp2展示了它同样可以被实现为public类。但是，A.DImp2只能被其自身所使用。你无法说它实现了一个private接口D，因此，实现一个private接口只是一种形式，它可以强制该接口中的方法定义不要添加任何类型信息（也就是说，不允许向上转型）。

getD()方法使我们陷入了一个进退两难的境地，这个问题与private接口相关：它是一个返回对private接口的引用的public方法。你对这个方法的返回值能做什么呢？在main()中，可以看到数次试图使用返回值的行为都失败了。只有一种方式可成功，那就是将返回值交给有权使用它 的对象。在本例中，是另一个A通过receiveD()方法来实现的。

接口E说明接口彼此之间也可以嵌套。==然而，作用于接口的各种规则，特别是所有的接口元素都必须是public的，在此都会被严格执行。==因此，嵌套在另一个接口中的接口自动就是public的，而不能声明为private。

NestingInterfaces 展示了嵌套接口的各种实现方式。特别需要注意的是，当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且，private接口不能在定义它的类之外被实现。

## 9.9 接口与工厂

接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是**工厂方法**设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。

为什么我们想要添加这种额外级别的间接性呢？一个常见的原因是想要创建框架。

在下一章中，你将可以看到另一种更加优雅的工厂实现方式，那就是使用匿名内部类。

# 第10章 内部类

可以将一个类定义放在另一个类的定义内部，这就是内部类。

在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信；而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样。

## 10.1 创建内部类

创建内部类的方式就如同你想的一样——把类的定义置于外围类的里面。

```java
//:innerclasses/Parcel1.java
//Creating inner classes.
```



当我们在ship()方法里面使用内部类的时候，与使用普通类没什么不同。在这里，实际区别只是内部类的名字是嵌套在Parcel1里面的。不过你将会看到，这并不是唯一的区别。

更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像在to()和contents()方法中看到的那样：

```java
//:inerclasses/Parcel2.java
//Returning a reference to an inner class.
```

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须想在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName.

## 10.2 链接到外部类

到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的**外围对象（enclosing object）**之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何条件。此外，内部类还拥有其外围类的所有元素的访问权。（这与C++的嵌套类的设计非常不同，在C++中只是单纯的名字隐藏机制，与外围对象没有联系，也没有隐含的访问权。）

``` java
//:innerclasses/Sequence.java
// Holds a sequence of Objects.

```

Sequence类只是一个固定大小的Object的数组，以类的形式包装了起来。可以调用add()在序列末添加新的Object（只要还有空间）。要获取Sequence中的每一个对象，可以使用Selector接口。这是“迭代器”设计模式的一个例子，在本书稍后的部分将更多地学习它。Selector允许你检查序列是否到末尾了（end()）,访问当前对象（current()），以及移到序列中的下一对象（next()）。因为Selector是一个接口，所以别的类可以按自己的方式来实现这个接口，并且另的方法能以此接口为参数，来生成更加通用的代码。

这里，SequenceSelector是提供Selector功能的private类。可以看到，在main()中创建了一个Sequence，并向其中添加了一些String对象。然后通过调用selector()获取一个Selector，并用它在Sequence中移动和选择某一个元素。

最初看到SequenceSelector，可能会觉得它只不过是另一个内部类罢了。但仔细观察它，注意方法end()、current()和next()都用到了objects，这是一个引用，它并不是SequenceSelector的一部分，而是外围类中的一个private字段。然而内部类可以访问其外围类的方法和字段，就像自己拥有它们似的，这带来了很大的方便，就如前面的例子所示。

==所以内部类自动拥有对其外围类的所有成员的访问权。==这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在看到：内部类的对象只能在与其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时）。构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。

## 10.3 使用.this与.new

如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型。这一点在编译期就被知晓并收到检查，因此没有任何运行时开销。

有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这时需要使用.new语法。

要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不必声明（实际上你不能声明） dn.new.DotNew.Inner().

在拥有外部类对象之前不可能创建内部类对象的。这是因为内部类对象会暗暗地链接到它的外部类对象上。但是，如果你创建的是**嵌套类（静态内部类）**，那么它就不需要对外部类的引用。

## 10.4 内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

当取得了一个指向基类或接口的引用时，甚至可能无法找出它确切的类型，看下面的例子：

``` java
//: innerclasses/TestParcel.java
```

Parcel4中增加了一些新东西：内部类PContents是private，所以除了Parcel4，没有人能访问它。PDestination是protected，所以只有Parcel4及其子类，还有与Parcel4同一个包中的类（因为protected也给予了包访问权）能访问PDestination，其他类都不能访问PDestination。这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成private内部类（或protected内部类，除非是继承自它的子类），因为不能访问其名字，就像在TestParcel类中看到的那样。于是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给Java编译器提供了生成更高效代码的机会。

## 10.5 在方法和作用域内的内部类

可以在一个方法里面或者在任意的作用域内定义内部类。这么做有两个理由：

1. 如前所示，你实现某类型的接口，于是可以创建并返回对其的引用。
2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。

在后面的例子中，先前的代码将被修改，以用来实现：

1. 一个定义在方法中的类。
2. 一个定义在作用域内的类，此作用域在方法的内部。
3. 一个实现了接口的匿名类。
4. 一个匿名类，它拓展了有非默认构造器的类。
5. 一个匿名类，它执行字段初始化。
6. 一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）。

第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类，这被称作**局部内部类**：

```java
//:innerclasses/Parcel5.java
// Nesting a class within a method.
public class Parcel5{
    public Destination destination(String s){
        class PDestination implements Destination{
            private String label;
            public PDestination(String whereTo){
                label = whereTo;
            }
            public String readLabel(){
                return label;
            }
        }
        return new PDestination(s);
    }
    public static void main(String[] args){
        Parcel5 P =new Parcel5();
        Destination d=p.destination("Tasmania");
    }
}///:~
```

PDestination类是destination()方法的一部分，而不是Parcel5的 一部分。所以，在destination()之外不能访问PDestination。注意出现在return语句中的向上转型——返回的是Destination的引用，它是PDestination的基类。当然，在destination()中定义了内部类PDestination，并不意味着一旦dest()方法执行完毕，PDestination就不可用了。

你可以在同一个子目录下的任意类中对某个内部类使用类标识符PDestination，这并不会有命名冲突。

下面的例子展示了如何在任意的作用域内嵌入一个内部类：

``` java
//: innerclasses/Parcel6.java
//Nesting a class within a scope.
```

TrackingSlip类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义TrackingSlip的作用域之外，它是不可用的；除此之外，它与普通类一样。

## 10.6 匿名内部类

下面的例子看起来有点奇怪

```java
//:innerclasses/Parcel7.java
// Returning an instance of an anonymous inner class.
public class Parcel7{
    public Contents contents(){
        return new Constents(){//Insert a class defination
            private int i = 11;
            public int value(){
                return i;
            }
        };//Semicolon required in this case
    }
    public static void main(String[] args){
        Parcel7 p = new Parcel7();
        Contents c = p.contents();
    }
}///:~
```

contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个Constents对象。但是然后（在到达语句结束的分号之前）你却说："等一等，我想在这里插入一个类的定义。"

这种奇怪的语法指的是：“创建一个继承自Constents的匿名类的对象。”通过new表达式返回的引用被自动向上转型为对Contents的引用。上述匿名内部类的语法是下述形式的简化形式：

```java
//:innerclasses/Parcel7b.java
// Expanded version of Parcel7.java
public class Parcel7b{
    class MyContents implements Contents{
        private int i=11;
        public int value(){return i;}
    }
    public Contents contents(){return new MyContents();}
    public static void main(String[] args){
        Parcel7b p =new Parcel7b();
        Contents c = p.contents();
    }
}///:~
```

在这个匿名内部类中，使用了默认的构造器来生成Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：

```java
//: innerclasses/Parcel8.java
// Calling the base-class constructor.
public class Parcel8{
    public Wrapping wrapping(int x){
        //Base constructor call;
        return new Wrapping(x){//Pass constuct arguments
            public int value(){
                return super.value()*47;
            }
        };//Semicolon required
    }
    public static void main(String[] args){
        Parcel8 p =new Parcel8();
        Wrapping w = p.wrapping(10);
    }
}///:~
```

只需简单地传递合适的参数给基类的构造器即可，这里是将x传进new Wrapping(x).尽管Wrapping只是一个具有具体实现的普通类，但它还是被其导出类当作公共“接口”来使用。

匿名内部类末尾的分号

在匿名类中定义字段时，还能够对其执行初始化操作。

如果定义一个匿名内部类，并且希望它使用一个其外部定义的对象，那么编译器会要求其参数引用是final的，就像你在destination()的参数中看到的那样。如果你忘记了，将会的得到一个编译时错误消息。

如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名内部类中不可能有命名构造器（因为它根本没名字！），但通过**实例初始化**，就能够达到为匿名内部类创建一个构造器的效果。就像这样：

```java
//: innerclasses/AnonymousConstructor.java
// Creating a constructor for an anonymous inner class.
import static net.mindView.util.Print.*;

abstract class Base{
    public Base(int i){
        print("Base constructor, i = " + i);
    }
    public abstract void f();
}
public class AnonymousConstructor{
    public static Base getBase(int i){
        return new Base(i){
            {print("Inside instance initializer");}
            public void f(){
                print("In anonymous f()");
            }
        };
    }
    public static void main(String[] args){
        Base base = getBase(47);
        base.f();
    }
}/* Output:
Base constructor, i = 47
Inside instance initializer
In anonymous f()
*///:~
```

在此例中，不要求变量i一定是final的。因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。

下例是带实例初始化的"parcel"形式。注意destination()的参数必须是final的，因为它们是匿名类内部使用的。

``` java
//: innerclasses/Parcel10.java
// Using "instance initialization" to perform
// construction on an anonymous inner class.

```



在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是if语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制——你不能重载实例初始化方法，所以你仅有一个这样的构造器。

==匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。==

### 10.6.1 再访工厂方法

interfaces/Factories.java示例使用匿名内部类变得多么美妙

interfaces/Games.java示例也可以通过使用匿名内部类来改进。

请记住在第9章最后给出的建议：优先使用类而不是接口。如果你的设计中需要某个接口，你必须了解它。否则，不到迫不得已，不要将其放到你的设计中。

## 10.7 嵌套类

如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为**嵌套类**。（与C++嵌套类大致相似，只不过在C++中那些类不能访问私有成员，而在Java中可以访问）想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着：

1. 要创建嵌套类的对象，并不需要其外围类的对象。
2. 不能从嵌套类的对象中访问非静态的外围类对象。

嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。

嵌套类没有链接到其外围对象的特殊的this引用

### 10.7.1 接口内部的类

正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口规则。你甚至可以在内部类中实现其外围接口。

如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。

我曾经在本书中建议过，在每个类中都写一个main()方法，用来测试这个类。==这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码==。

### 10.7.2 从多层嵌套类中访问外部类的成员

一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员。

```java
//:innerclasses/MultiNestingAccess.java
//Nested classes can access all members of all
//levels of the classes they are nested within.
class MNA{
	private void f(){}
	class A{
		private void g(){}
		public class B{
			void h(){
				g();
				f();
			}
		}
	}
}
public class MultiNestingAccess {
	public static void main(String[] args) {
		MNA mna = new MNA();
		MNA.A mnaa = mna.new A();
		MNA.A.B mnaab = mnaa.new B();
		mnaab.h();
	}
}///:~
```

这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以不必在调用构造器时限定类名。

## 10.8 为什么需要内部类

使用内部类最吸引人的原因是：==每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。==

如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。

如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。

使用内部类，还可以获得其他的一些特性：

1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
2. 在单个外围类中，可以让多个内部类以不同方式实现同一个接口，或继承同一个类。
3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
4. 内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。

### 10.8.1 闭包与回调

**闭包（closure）**是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。

Java最引人争议的问题之一就是，人们认为Java应该包含某种类似指针的机制，以允许**回调（callback）**。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java更小心仔细，所以没有在语言中包括指针。

通过内部类提供的闭包功能是优良的解决方案，它比指针更灵活，更安全。

### 10.8.2 内部类与控制框架

**控制框架（control framework）**

**应用程序框架（application framework）**就是被设计用以解决某些特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，已解决你的特定问题。模块方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。

控制框架是一类特殊的应用程序框架，它用来解决响应时间的需求。主要用来响应时间的系统被称作**事件驱动系统**。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。

要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。接下来的问题就是，对于要控制什么，控制框架并不包含任何具体的信息。那些信息是在实现算法的action()部分时，通过继承来提供的。

首先，接口描述了要控制的时间。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口。

内部类允许：

1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的action().
2. 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择其他方法。

## 10.9 内部类的继承

因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：

```java
//:innerclasses/InheritInner.java
//Inheriting an inner class.
class WithInner{
    class Inner {}
}
public class InheritInner extends WithInner, Inner{
    //! InheritInner(){}//Won't compile
    InheritInner(WithInner wi){
        wi.super();
    }
    public static void main(String[] args){
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    }
}
```

可以看到，InheritInner只继承自内部类，而不是外围类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。此外，必须在构造器内使用如下语法：

```java
enclosingClassReference.super();
```

这样才提供了必要的引用，然后程序才能编译通过。

## 10.10 内部类可以被覆盖吗

“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用。

```java
//:innerclasses/BigEgg.java
//An inner class cannot be overriden like a method.
import static net.mindView.util.Print.*;
class Egg{
    private Yolk y;
    protected class Yolk {
        public Yolk(){print("Egg.Yolk()");}
    }
    public Egg(){
        print("New Egg()");
        y = new Yolk();
    }
}
public class BigEgg extends Egg{
    public class Yolk{
        public Yolk(){print("BigEgg.Yolk()");}
    }
    public static void main(String[] args){
        new BigEgg();
    }
}/* Output:
New Egg()
Egg.Yolk()
*///:~
```



默认的构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了BigEgg的对象，那么所使用的应该是“覆盖后”的Yolk版本，但从输出中可以看到实际情况并不是这样的。

这个例子说明，当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：

```java
//:innerclasses/BigEgg2.java
// Proper inheirtance of an inner class.
```

## 10.11 局部内部类

前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。

```java
//:innerclasses/LocalInnerClass.java
// Holds a sequence of Objects.
```

既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。

所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。

## 10.12 内部类标识符

这些类文件的命名有严格的规则：外围类的名字，加上"\$"，再加上内部类的名字。

如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与"\$"的后面。

# 第11章 持有对象

如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这时一个非常简单的程序。

List、Set、Queue和Map。这些对象类型也称为**集合类**。但由于Java的类库使用了Collection这个名字指代该类库的一个特殊自己，所以我使用了范围更广的术语**“容器”**称呼它们。

Set对于每个值只保存一个对象，Map是允许你将某些对象与其他一些对象关联起来的**关联数组**，Java容器类都可以自动地调整自己的尺寸。

## 11.1 泛型和类型安全的容器

Java SE 5之前的容器一个主要问题就是编译器允许你向容器中插入不正确的类型。	ArrayList：	add()插入对象	get()访问这些对象	size()，查看多少元素添加了进来

@SuppressWarnings注解及其参数（“unchecked”）表示只有有关“不受检查的异常”的警告信息应该被抑制

尖括号括起来的是**类型参数**（可以有多个），它指定了这个容器实例可以保存的类型。通过使用泛型，就可以在编译期防止将错误类型的对象放置到容器中。

向上转型也可以像作用于其他类型一样作用于泛型

## 11.2 基本概念

Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：

1. Collection。 一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
2. Map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此某种意义上来讲，它将数字与对象关联在了一起。**映射表**允许我们使用另一个对象来查找某个对象，它也被称为**“关联数组”**；或者被称为**“字典”**，因为你可以使用键对象来查找值对象。Map是强大的编程工具。

Collection接口概括了**序列**的概念——一种存放一组对象的方式。

所有的Collection都可以用foreach遍历。

## 11.3 添加一组元素

Arrays.asList()方法接受一个数组或是一个逗号分隔的元素列表（使用可变参数），并将其转换为一个List对象。Collection==s==.addAll()方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。

Collection的构造器可以接受另一个Collection，用它来将自身初始化，因此你可以使用Array.List()来为这个构造器产生输入。==但是Collection.addAll()方法运行起来要快得多，而且构建一个不包含元素的Collection，然后调用Collections.addAll()这种方式很方便，所以它是首选方式==。

Collection.addAll()成员方法只能接受另一个Collection对象作为参数，因此它不如Array==s==.asList()或Collection==s==.addAll() 灵活，这两个方法使用的都是可变参数列表。

你也可以直接使用Arrays.asList()的输出，将其当做List，但是这种情况下，底层表示的是数组，因此不能调整尺寸。

**显式类型参数说明**

Map更加复杂，除了用另一个Map之外，Java标准类库没有提供其他任何自动初始化它们的方式。

## 11.4 容器的打印

Arrays.toString()来产生数组的可打印表示

Collection每个槽中只能保存一个元素。此类容器包括：List，Set，Queue。Map在每个槽内保存了两个对象，即键和与之相关联的值。

ArrayList和LinkedList都是List类型，不同之处不仅在于执行某些类型的操作时的性能，而且LinkedList包含的操作也多于ArrayList。

HashSet、TreeSet和LinkedHashSet都是Set类型，输出显示在Set中，每个相同的项只有保存一次，但是输出也显示了不同Set实现存储元素的方式也不同。	HashSet是最快的获取元素方式，因此，存储顺序看起来并无实际意义。如果存储顺序很重要，那么可以使用TreeSet，它按照比较结果的升序保存对象；或者使用LinkedHashSet，它按照被添加的顺序保存对象。

Map（也被称为关联数组）使得你可以用键来查找对象，就像一个简单的数据库。键所关联的对象称为值。

Map.put(key, value)方法将增加一个值（你想要增加的对象），并将它与某个键（你用来查找这个值的对象）关联起来。Map.get(key)方法将产生与这个键相关联的值。上面的示例只添加了键-值对，并没有执行查找。

键和值在Map中保存顺序并不是它们的插入顺序，因为HashMap实现使用的是一种非常快的算法来控制顺序。

本例使用了三种基本风格的Map：HashMap、TreeMap和LinkedHashMap。与HashSet一样，HashMap也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素。TreeMap按照比较结果的升序保存键，而LinkedHashMap则按照插入顺序保存键，同时还保留了HashMap的查询速度。

## 11.5 List

List承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量方法，使得可以在List的中间插入和移除元素。

有两种类型的List：

- 基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
- LinkedList， 它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList更大。

contains()方法来确定某个对象是否在列表中。如果你想移除一个对象，则可以将这个对象的引用传递给remove()方法。同样，如果你有一个对象的引用，则可以使用IndexOf()来发现该对象在List中所处位置的索引编号。

当确定一个元素是否属于某个List，发现某个元素的索引，以及从某个List中移除一个元素时，都会用到equals()方法（它是根类Object的一部分）。==因此为了防止以外，就必须意识到List的行为根据equals()的行为而有所变化==

subList()方法允许你很容易地从较大的列表中创建出一个片断，而将其结果传递给这个较大的列表的containsAll()方法时，很自然地会得到true。还有一点也很有趣，那就是我们注意到顺序并不重要，在sub上调用名字很直观的Collections.sort()和Collections.shuffle()方法，不会影响containsAll()的结果。==subList()所产生的的列表的幕后就是初始列表，因此，对返回的列表的修改都会反映到初始列表中，反之亦然==。（***笔记注解***：这里会有一点歧义，或者说逻辑上的小bug——因为修改subList()赋值的sub会改变原List，所以感觉这个例子就不能说明顺序不重要了，虽然经过测试其实顺序的确不重要……）

retainAll()方法是一种有效的“交集”操作，它保留两个List中同时存在的元素。请再次注意，所产生的行为依赖于equals()方法。

remove()可以使用索引值来移除元素。不必担心equals()的行为。

removeAll()方法的行为也是基于equals()方法的。它将从List中移除在List中的所有元素。

set()方法的命名显得很不合时宜，因为它与Set类存在潜在冲突。它的功能是在指定索引处（第一个参数），用第二个参数替换那个位置的元素。

对于List，有一个重载的addAll()方法使得我们可以在初始List的中间插入新的列表，而不仅仅只能用Collection中的addAll()方法将其追加到表尾。

isEmpty()和clear()方法

toArray()方法，将任意的Collection转换为一个数组。这是一个重载方法，其无参数版本返回的是Object数组，但是如果你向这个重载版本传递目标类型的数据，那么它将产生指定类型的数据（假设它能通过类型检查）。如果参数数组太小，存放不下List的所有元素，toArray()方法将创建一个具有合适尺寸的数组。

## 11.6 迭代器

任何容器类，都必须有某种方式可以插入元素并将它们再次取回。对于List，add()是插入元素的方法之一，而get()是取出元素的方法之一。

**迭代器**（也是一种设计模式）的概念可以用于达成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为**轻量级对象**：创建它的代价小。因此，经常可以见到对迭代器有些奇怪的限制，例如，Java的Iterator只能单向移动，这个Iterator只能用来：

1. 使用方法Iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。
2. 使用next()获得序列中的下一个元素。
3. 使用hasNext()检查序列中是否还有元素。
4. 使用remove()将迭代器新近返回的元素删除。

有了Iterator就不必为容器中元素的数量操心了，那是由hasNext()和next()关心的事情。

如果你只是向前遍历List，不打算修改List对象本身，那么foreach会显得更加简介。

Iterator还可以移除由next()产生的最后一个元素，这意味着在调用remove()之前必须先调用next()。

（remove()是所谓的“可选”方法（还有一些其他的这种方法），即不是所有的Iterator实现都必须实现该方法。这个问题将在第17章中介绍。但是，标准java类库实现了remove()，因此直至17章前，你都不用担心这个问题。）

==Iterator的真正威力：能够将遍历序列的操作与序列底层的结构分离。==正由于此，我们有时会说：迭代器统一了对容器的访问方式。

### 11.6.1 ListIterator

ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。（***笔记注解***：使用hasPrevious()、previous()）

它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。

## 11.7 LinkedList

LinkedList也像ArrayList一样实现了基本的List接口，但是它执行某些操作（在List的中间插入和移除）时比ArrayList更高效，但在随机访问操作方面却要逊色一些。

LinkedList还添加了可以使其用作栈、队列或双端队列的方法。

这些方法中有些彼此之间只是名称有所差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在Queue中）。例如，getFirst()和element()完全一样，都返回列表的头（第一个元素），而并不移除它，如果List为空，则抛出NoSuchElementException，peek()方法与这两个方法只是稍有差异，在列表为空时返回null。

removeFirst()与remove()也是完全一样的，它们移除并返回列表的头，而在列表为空时抛出NoSuchElementException，poll()稍有差异，它在列表为空时返回null。

addFirst()与add()和addLast()相同，它们都将某个元素插入到列表的尾（端）部。

removeLast()移除并返回列表的最后一个元素。

如果你浏览一下Queue接口就会发现，它在LinkedList的基础上添加了element(), offer(), peek(), poll()和remove()方法，以使其可以成为一个Queue实现。

## 11.8 Stack

栈通常是指“后进先出”（LIFO）的容器。有时栈也被称为叠加栈，因为最后压入栈的元素，第一个弹出栈。

LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。不过，有时一个真正的“栈”更能把事情讲清楚：

```java
//:net/mindview/util/Stack.java
//Making a stack from a LinkedList.
package net.mindview.util;
import java.util.LinkedList;

public class Stack<T>{
    private LinkedList<T> storage = new LinkedList<T>();
    public void push(T v){storage.addFirst(v);}
    public T peek(){return storage.getFirst();}
    public T pop(){return storage.removeFirst();}
    public boolean empty(){return storage.isEmpty();}
    public String toString(){return storage.toString();}
}///:~
```

这里通过使用泛型，引入了在栈的类定义中最简单的可行示例。peek()方法提供栈顶元素，但不是将其从栈顶移除，而pop()将移除并返回栈顶元素。

如果你只需要栈的行为，这里使用继承就不合适了，因为这样会产生具有LinkedList的其他所有方法的类（就像你将在第17章看到的，Java 1.0的设计者在创建java.util.Stack时，就犯了这个错误）。

## 11.9 Set

Set不保存重复的元素(至于如何判断元素相同则较为复杂，稍后便会看到)。如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。Set最长被使用的是测试归属性，你可以很容易地询问某个对象是否在某个Set中。因此你通常会选择一个HashSet的实现，它专门对快速查找进行了优化。

Set具有Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection，只是行为不同。（这是继承与多态思想的典型应用：表现不同的行为）Set是基于对象的值来确定归属性的，而更加复杂的问题我们将在第17章中介绍。

HashSet使用了散列，HashSet所维护的顺序与TreeSet或LinkedHashSet都不同，因为它们的实现具有不同的元素存储方式。TreeSet将元素存储在红黑树数据结构中，而HashSet使用的是散列函数。LinkedHashSet（***笔记注解：***这里原文貌似有误，写的是LinkedHashList）因为查询速度的原因也使用了散列，但是看起来它使用了链表来维护元素的插入顺序。

如果你想对结果排序，一种方式是使用TreeSet代替HashSet。

contains()测试Set的归属性

## 11.10 Map

将对象映射到其他对象的能力是一种解决编程问题的杀手锏。

自动包装机制可以将int转换为HashMap可以使用的Integer引用（不能使用基本类型的容器）。如果键不再容器中，get()方法将返回null（这表示该数字第一次被找到）。否则，get()方法将产生与该键相关联的Integer值。

containsKey()和containsValue()测试一个Map，以便查看它是否包含某个键或某个值。

Map与数组和其他Collection一样可以很容易扩展到多维，而我们只需将其值设置为Map（这些Map的值可以是其他容器，甚至是其他Map）。

Map可以返回它的键的Set，它的值的Collection，或者它的键值对的Set。keySet()方法产生了由在petPeople中的所有键组成的Set，它在foreach语句中被用来迭代遍历该Map。

## 11.11 Queue

队列是一个典型的先进先出（FIFO）的容器。队列在并发编程中特别重要，就像你将在21章中所看到的，因为它们可以安全地将对象从一个任务传输给另一个任务。

LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口，因此LinkedList可以用做Queue的一种实现。通过将LinkedList向上转型为Queue。

offer()方法是与Queue相关方法之一，它在允许的情况下，将一个元素插入到队尾，或者返回false，peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，而element()会抛出NoSuchElementException异常。poll()和remove()方法将移除并返回队头，但是poll()在队列为空时返回null,而remove()会抛出NoSuchElementException异常。

自动包装机制会自动地将nextInt()方法的int结果转换为queue所需的Integer对象，将char c转换为qc所需的Character对象，Queue接口窄化了对LinkedList的方法的访问权限，以使得只有恰当的方法才可以使用，因此，你能够访问的LinkedList方法会变少（这里你实际上可以将queue转型回LinkedList，但是至少我们不鼓励这么做）。

注意，与Queue相关的方法提供了完整而独立的功能。即，对于Queue所继承的Collection，在不需要使用它的任何方法的情况下，就可以拥有一个可用的Queue。

### 11.11.1 PriorityQueue

先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素、

优先级队列声明下一个弹出元素是最需要的元素（具有最高优先级）

offer()	Comparator	peek()	poll()	remove()

## 11.12 Collection和Iterator

Java中，遵循C++的方式看起来似乎很明智，即用迭代器而不是Collection来表示容器之间的共性。但是两种方法绑定到了一起，因为实现Collection就意味着需要提供Iterator()方法。

生成Iterator是将队列与消费队列的方法链接在一起耦合度最小的方式，并且与实现Collection相比，它在序列类上所施加的约束也少得多。

## 11.13 Foreach与迭代器

foreach语法主要用于数组，但是它也可以应用于任何Collection对象的特性。

称为Iterable的接口

System.getenv()返回一个Map，entrySet()产生一个由Map.Entry的元素构成的Set，并且这个Set是一个Iterable，因此它可以用于foreach循环。

不存在任何从数组到Iterable的自动转换

### 11.13.1 适配器方法惯用法

“适配器”部分来自于设计模式，因为你必须提供特定接口以满足foreach语句。

# 第12章 通过异常处理错误

## 12.1 概念

C++的异常处理机制基于Ada，Java的异常处理则建立在C++的基础之上

## 12.2 基本异常

**异常情形（exceptional condition）**是指阻止当前方法或作用域继续执行的问题。

**异常处理程序**，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

### 12.2.1 异常参数

所有标准异常类都有两个构造器：一个默认构造器；另一个是接受字符串作为参数，以便把相关信息放入异常对象的构造器：

```java
throw new NullPointerException("t=null");
```

Throwable对象，异常类型的根类。

## 12.3 捕获异常

**监控区域（guarded region）**

### 12.3.1 try块

try关键字

### 12.3.2 异常处理程序

catch关键字

标识符不可以省略

try块内部，许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。

### 终止与恢复

**终止模型**：错误无法挽回，也不能回来继续运行。

**恢复模型**：异常处理程序的工作是修正错误

恢复模型不是很实用，主要原因可能是它所导致的耦合。

## 12.4 创建自定义异常

要定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。

System.err将错误发送给标准错误流。System.out也许会被重定向。如果把结果送到System.err，它就不会随System.out一起被重定向，这样更容易被用户注意。

Throwable类的printStackTrace()方法，默认输出到标准错误流。

### 12.4.1 异常与记录日志

静态的Logger.getLogger()方法	severe()

Throwable.getMessage()方法

## 12.5 异常说明

throws关键字

被检查的异常

## 12.6 捕获所有异常

Exception是与编程有关的所有异常类的基类，可以调用它从基类Throwable继承的方法：

String getMessage()

String getLocalizedMessage()

用来获取详细信息，或用本地语言表示的详细信息。

String toString()

返回对Throwable的简单描述，要是有详细信息的话，也会把它包含在内。

void printStackTrace()

void printStackTrace(PrintStream)

void printStackTrace(java.io.PrintWriter)

打印Throwable和Throwable的调用栈轨迹。第一个版本输出到标准错误，后两个版本允许选择要输出的流。

Throwable fillInStackTrace()

用于在Throwable对象的内部记录栈帧的当前状态。

此外，也可以使用Throwable从其基类Object继承的方法。	getClass()	getName()	getSimpleName()

### 12.6.1 栈轨迹

元素0是栈顶元素	数组中最后一个元素和栈底是调用序列中的第一个方法调用

stackTraceElement

### 12.6.2 重新抛出异常

重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将会被忽略。

如果只是把当前异常重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。	fillInStackTrace()方法，返回一个把当前调用栈信息填入原来异常对象而建立的Throwable对象

### 12.6.3 异常链

JDK1.4之后，Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数。

有趣的是，在Throwable子类中，只有三个基本的异常类提供了带cause参数的构造器。它们是Error、Exception以及RuntimeException。如果要把其他类型的异常连接起来，应该使用InitCause()方法而不是构造器。

## 12.7 Java标准异常

Throwable这个Java类被用来表示任何可以作为异常被抛出的类。Throwable对象可分为两种类型（指从Throwable继承而得到的类型）：Error用来表示编译时和系统错误，Exception是可以被抛出的基本类型。

异常并非全是在java.lang包里定义的。

### 12.7.1 特例：RuntimeException

属于运行时异常的类型有很多，它们自动被Java虚拟机抛出，所以不必在异常说明中把它们列出来。	不受检查的异常，这种异常属于错误，将被自动捕获。

如果RuntimeException没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法。

不应把Java的异常处理机制当成是用途单一用途的工具。它被设计用来处理一些烦人的运行时错误，这些错误往往是由代码能力之外的因素导致的，然而，它对于发现某些编译器无法检测到的编译错误也是非常重要的。

## 12.8 使用finally进行清理

对于一些代码，可能希望无论try块中的异常是否抛出，它们都能得到执行。可以在异常处理程序后面加上finally子句。

### 12.8.1 finally用来作什么

要把除内存之外的资源恢复到它们初始状态时，就要用到finally子句。

如果把finally子句和标签的break和continue配合使用，在Java里就没必要使用goto语句了。

### 12.8.2 在return中使用finally

在finally类内部，从何处返回无关紧要

### 12.8.3 缺憾：异常丢失

用某些特殊方式使用finally子句，就可能会导致异常被忽略。

相比之下，C++把"前一个异常还没处理就抛出下一个异常"的情形看成是糟糕的编程错误。

一种更简单的丢失异常的方法是从finally子句中返回。

## 12.9 异常的限制

当覆盖方法时，只能抛出基类方法的异常说明里列出的那些异常。

异常限制对构造器不起作用。然而因为基类构造器必须以这样或那样的方式被调用，派生类构造器的异常说明必须包含基类构造器的异常说明。

派生类的构造器不能捕获基类构造器抛出的异常。

通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证。

尽管在继承过程中，编译器会对异常说明做强制要求，但异常说明本身并不属于方法类型的一部分，方法类型是由方法的名字与参数的类型组成的。因此，不能基于异常说明来重载方法。	换句话说，在继承和覆盖的过程中，某个特定方法的“异常说明接口”不是变大了而是变小了——这恰恰和类接口在继承时的情形相反。

## 12.10 构造器

对于在构造阶段可能抛出异常，并且需要清理的类，最安全的使用方式是使用嵌套的try子句

这种通用的清理惯用法在构造器不抛出任何异常时也应该运用，其基本规则是：在创建需要清理的对象之后，立即进入try-finally语句块。

## 12.11 异常匹配

异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再寻找。

派生类对象也可以匹配其基类的处理程序。

## 12.12 其他可选方式

异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。

**吞食则有害（harmful if swallowed）**

我们使用的工具已经不是ANSI标准出台前的像C那样弱类型的语言，而是C++和Java这样的“强静态类型语言”（也就是编译时就做类型检查的语言）

### 12.12.1 历史

异常处理起源于PL/1和Mesa之类的系统中，后来又出现在CLU、Smalltalk、Modula-3、Ada、Eiffel、C++、Python、Java以及后Java语言Ruby和C#中。

C++异常模型主要借鉴了CLU的做法。然而，当时其他语言已经支持异常处理了：包括Ada、Smalltalk（两者都有异常处理，但是都没有异常说明），以及Modula-3（它既有异常处理也有异常说明）。

### 12.12.2 观点

首先，Java无谓地发明了“被检查的异常”，没有别的语言采用这种做法

其次，程序变大的时候，“被检查的异常”会带来一些微妙的问题。	过多的类型检查

### 12.12.3 把异常传递给控制台

### 12.12.4 把“被检查的异常”转换为“不检查的异常”

JDK1.4的异常链提供了一种新的思路来解决这个问题，可以直接把“被检查的异常”包装进RuntimeException里面。

这种技巧给了你一种选择，可以不写try-catch子句和/或异常说明，直接忽略异常，让它自己沿着调用栈往上“冒泡”。同时还可以用getCause()捕获和处理特定异常。

## 12.13 异常使用指南

在下列情况中使用异常：

1. 在恰当的级别处理问题（在知道该如何处理的情况下才捕获异常）
2. 解决问题并且重新调用产生异常的方法
3. 进行少许修补，然后绕过异常发生的地方继续执行
4. 用别的数据进行计算，以代替方法预计会返回的值
5. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层
6. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层
7. 终止程序
8. 进行简化（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人）
9. 让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资）

# 第13章 字符串

## 13.1 不可变String

String类每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包括修改后的字符串内容。

## 13.2 重载“+”与StringBuilder

不可变性会带来一定的效率问题。为String对象重载的“+”操作符就是一个例子。（用于String的“+”和“+=”是Java中仅有的两个重载过的操作符，而Java不允许程序员重载任何操作符）

JDK自带的工具javap来反编译

如果你要在toString()方法中使用循环，那么最好自己创建一个StringBuilder对象

StringBuilder是Java SE5引入的，在这之前Java用的是StringBuffer。后者是线程安全的，因此开销也要大写。

## 13.3 无意义的递归

打印对象的内存地址，应该调用Object.toString()方法。所以，你不该使用this，而是应该调用super.toString()方法

## 13.4 String上的操作

| 方法                        | 参数，重载版本                                               | 应用                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 构造器                      | 重载版本：默认版本，String，StringBuilder，StringBuffer，char数组，byte数组 | 创建String对象                                               |
| length()                    |                                                              | String中字符的个数                                           |
| charAt()                    | int索引                                                      | 取得String中该索引位置上的char                               |
| getChars(),getBytes()       | 要复制部分的起点和终点索引，复制的目标数组，目标数组的起始索引 | 复制char或byte到一个目标数组中                               |
| toCharArray()               |                                                              | 生成了一个char[]，包含String的所有字符                       |
| equals(),equalsIgnoreCase() | 与之进行比较的String                                         | 比较两个String的内容是否相同                                 |
| compareTo()                 | 与之进行比较的String                                         | 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写并不等价 |
| contains()                  | 要搜索的CharSequence                                         | 如果该String对象包含参数的内容，则返回true                   |
| contentEquals()             | 与之进行比较的CharSequence或StringBuffer                     | 如果该String与参数的内容完全一致，则返回true                 |
| equalsIgnoreCase()          | 与之进行比较的String                                         | 忽略大小写，如果两个String的内容相同，则返回true             |
| regionMatcher()             | 该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本添加了“忽略大小写”功能 | 返回boolean结果，以表明所比较区域是否相等                    |
| startsWith()                | 可能的起始String。重载版本在参数中添加了偏移量               | 返回boolean结果，以表明该String是否以此参数起始              |
| endsWith()                  | 该String可能的后缀String                                     | 返回boolean结果，以表明此参数是否该字符串的后缀              |
| indexOf(),lastIndexOf()     | 重载版本包括：char, char与起始索引，String，String与起始索引 | 如果该String并不包含此参数，就返回-1，否则返回此参数在String中的起始索引。lastIndexOf()是从后往前搜索 |
| substring()(subSequence())  | 重载版本：起始索引; 起始索引+终点坐标                        | 返回一个新的String，以包含参数指定的子字符串                 |
| concat()                    | 要连接的String                                               | 返回一个新的String对象，内容为原始String连接上参数String     |
| replace()                   | 要替换的字符， 用来进行替换的新字符。也可以用一个CharSequence来替换另一个CharSequence | 返回替换字符后的新String对象，如果没有替换发生，则返回原始的String对象 |
| toLowerCase() toUpperCase() |                                                              | 将字符的大小写改变后，返回一个新String对象。如果没有改变发生，则返回原始的String对象 |
| trim()                      |                                                              | 将String两端的空白字符删除后，返回一个新的String对象。如果没有改变发生，则返回原始的String对象 |
| valueOf()                   | 重载版本：Object; char[]; char[], 偏移量, 与字符的个数; boolean; char; int; long; float; double | 返回一个表示参数内容的String                                 |
| intern()                    |                                                              | 为每个唯一的字符序列生成一个且仅生成一个String引用           |

## 13.5 格式化输出

Java SE 5推出了C语言中printf()风格的格式化输出这一功能。

### 13.5.1 printf()

格式占位符

### 13.5.2 System.out.format()

JavaSE5引入的format方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。format()方法模仿自C的printf()

可以看到，format()与printf()是等价的。

### 13.5.3 Formatter类

在Java中，所有新的格式化功能都有java.util.Formatter类处理。可以将Formatter看做一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。

### 13.5.4 格式化说明符

其抽象的语法：`%[argument_index$][flags][width][.precision]conversion`

使用“-”标志来改变对齐方向。

precision应用于String时，它表示打印String时输出字符的最大数量。而在将precision应用于浮点数时，它表示小数部分要显示出来的位数（默认为6位小数），如果小数位数过多则舍入，太少则在尾部补零。precision无法应用于整数，如果你对整数应用precision，则会触发异常。

### 13.5.5 Formatter转换

| 类型转换字符 | 意义               |
| ------------ | ------------------ |
| d            | 整数型（十进制）   |
| c            | Unicode字符        |
| b            | Boolean值          |
| s            | String             |
| f            | 浮点数（十进制）   |
| e            | 浮点数（科学计数） |
| x            | 整数（十六进制）   |
| h            | 散列码（十六进制） |
| %            | 字符“%”            |

程序中每个变量都用到了b转换，虽然它对各种类型都是合法的，但其行为却不一定与你想象的一致。对于boolean基本类型或Boolean对象，其转换结果是对应的true或false。但是，对于其他类型的参数，只要该参数不为null，那转换的结果就永远都是true。即使是数字0，转换结果依然为true，而在其他语言中（包括C），往往转化为false。

还有些不常用的类型转换与格式修饰符选项，你可以在JDK文档中Formatter类部分找到它们。

### 13.5.6 String.format()

Java SE 5也参考了C中的printf()方法，以生成格式化的String对象。String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象。

### 一个十六进制转储（dump）工具

## 13.6 正则表达式

### 13.6.1 基础

例如要找一个数字，它可能有一个符号在最前面，那你就写一个负号加上一个问号，就像：`-?`

在正则表达式中，用`\d`表示一位数字。如果在其他语言中使用过正则表达式，那你立刻就能发现Java对反斜线\的不同处理。在其他语言中，`\\`表示“我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊的意义。”而在Java中，`\\`的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。”例如，如果你想表示一位数字，那么正则表达式应该是`\\d`。如果你想插入一个普通的反斜线，则应该写成这样`\\\\`。不过换行和制表符之类的东西只需使用单反斜线：`\n\t`

要表示“一个或多个之前的表达式”，应该使用+。所以，如果要表示“可能有一个负号，后面跟着一位或多位数字”，可以这样：`-?\\d+`

应用正则表达式的最简单的途径，就是利用String类的内建的功能。matches()方法

在正则表达式中，括号有着将表达式分组的效果，而竖直线`|`则表示或操作。

因为字符+在正则表达式中有特殊意义，所以必须使用`\\`将其转移，使之称为表达式中的一个普通字符。

String类还自带了一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开。”

`\W`,意思是非单词字符（如果W小写，`\w`，则表示一个单词字符）。

在原始字符串中，与正则表达式匹配的部分，在split()结果中都不存在了。

String.split()还有一个重载的版本，它允许你限制字符串分割的次数。

String类自带的最后一个正则表达式工具是“替换”。你可以只替换正则表达式第一个匹配的子串，或是替换所有匹配的地方。

稍后你会看到，String之外的正则表达式还有更强大的替换工具，例如可以通过方法调用执行替换。而且，如果正则表达式不是只使用一次的话，非String对象的正则表达式明显具备更佳的性能。

### 13.6.2 创建正则表达式

正则表达式的完整构造子列表，请参考JDK文档java.util.regex包的Pattern类。

| 字符   | 意义                              |
| ------ | --------------------------------- |
| B      | 指定字符B                         |
| \xhh   | 十六进制值为0xhh的字符            |
| \uhhhh | 十六进制表示为0xhhhh的Unicode字符 |
| \t     | 制表符Tab                         |
| \n     | 换行符                            |
| \r     | 回车                              |
| \f     | 换页                              |
| \e     | 转义（Escape）                    |

当你学会使用字符类（character class）之后，正则表达式的威力才能真正显现出来。以下是一些创建字符类的典型方式，以及一些预定义的类：

| 字符类       | 意义                                                         |
| ------------ | ------------------------------------------------------------ |
| .            | 任意字符                                                     |
| [abc]        | 包含a、b和c的任何字符（和a\|b\|c作用相同）                   |
| [^abc]       | 除了a、b和c之外的任何字符（否定）                            |
| [a-zA-Z]     | 从a到z或从A到Z的任何字符（范围）                             |
| [abc[hij]]   | 任意a、b、c、h、i 和 j 字符（与a\|b\|c\|h\|i\|j作用相同）（合并） |
| [a-z&&[hij]] | 任意h、i 或 j（交）                                          |
| \s           | 空白符（空格、tab、换行、换页和回车）                        |
| \S           | 非空白符(`[^\s]`)                                            |
| \d           | 数字[0-9]                                                    |
| \D           | 非数字`[^0-9]`                                               |
| \w           | 词字符[a-zA-Z0-9]                                            |
| \W           | 非词字符`[^\w]`                                              |

逻辑操作符

XY	Y跟在X后面

X|Y	X或Y

（X）	捕获组（capturing group），可以在表达式中用`\i`引用第i个捕获组

边界匹配符

`^`	一行的起始

`$`	一行的结束

`\b`	词的边界

`\B`	非词的边界

`\G`	前一个匹配的结束

### 13.6.3 量词

量词描述了一个模式吸收文本的方式：

- 贪婪型：量词总是贪婪的，除非有其他选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。
- 勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也称为懒惰的，最少匹配的、非贪婪的、或不贪婪的。
- 占有型：目前，这种类型的量词只有在Java语言中才可用（其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失效时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效。

| 贪婪型 | 勉强型  | 占有型  | 如何匹配              |
| ------ | ------- | ------- | --------------------- |
| X?     | X??     | X?+     | 一个或零个X           |
| X*     | X*?     | X*+     | 零个或多个X           |
| X+     | X+?     | X++     | 一个或多个X           |
| X{n}   | X{n}?   | X{n}+   | 恰好n次X              |
| X{n,}  | X{n,}?  | X{n,}+  | 至少n次X              |
| X{n,m} | X{n,m}? | X{n,m}+ | X至少n次，且不超过m次 |

接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类中抽象出了字符序列的一般化定义。因此，这些类都实现了该接口。多数正则表达式操作都接受CharSequence类型的参数。

### 13.6.4 Pattern和Matcher

static Pattern.compile()方法编译你的正则表达式。它会根据你的String类型的正则表达式生成一个Pattern对象。接下来，把你想要检索的字符串传入Pattern对象的matcher()方法。matcher()方法会生成一个Matcher对象，它有很多功能可用。例如它的replaceAll()方法能将所有匹配的部分都替换成你传入的参数。

Pattern类提供了static方法：`static boolean matches(String regex, CharSequence input)` 该方法用以检查regex是否匹配整个CharSequence类型的input参数。编译后的Pattern对象还提供了split()方法，它从匹配了regex的地方分割输入字符串，返回分割后的子字符串String数组。

通过调用Pattern.matcher()方法，并传入一个字符串参数，我们得到了一个Matcher对象，使用Matcher上的方法，我们将能够判断各种不同类型的匹配是否成功。

其中matches()方法用来判断整个输入字符串是否匹配正则表达式模式，而lookingAt()则用来判断该字符串（不必是整个字符串）的始部分是否能够匹配模式。

Matcher.find()方法可用来CharSequence中查找多个匹配。

组（groups）是用括号划分的正则表达式。

Matcher对象提供了一系列方法，用以获取与组相关的信息：public int groupCount()返回该匹配器的模式中的分组数目，第0组不包括在内。public String group()返回前一次匹配操作（例如find(）)的第0组（整个匹配）。public String group(int i) 返回在前一次匹配期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则会返回null。public int start(int group)返回在前一次匹配操作中寻找到的组的起始索引。public int end(int group)返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。

Pattern标记

在这些标记中，Pattern.CASE_INSENSITIVE,Patten.MULTILINE以及Pattern.COMMENTS（对声明或文档有用）特别有用。

### 13.6.5 split()

split()方法将输入字符串断开成字符串对象数组，断开边界由下列正则表达式确定。

### 13.6.6 替换操作

replaceFirst(String replacement)

replaceAll(String replacement)

appendReplacement(StringBuffer sbuf, String replacement)

appendTail(StringBuffer sbuf)

### 13.6.7 reset()

### 13.6.8 正则表达式与Java I/O

## 13.7 扫描输入

StringReader将String转化为可读的流对象，然后用这个对象来构造BufferedReader对象，因为我们要用BufferReader的readLine()方法。

Java SE 5 新增了Scanner类

Scanner的构造器可以接受任何类型的输入对象，包括File对象、InputStream、String或者Readable对象。Readable是Java SE 5中新加入的接口，表示“具有read()方法的某种东西”。BufferdReader也归于此类。有了Scanner，所有的输入、分词以及翻译的操作都隐藏在不同类型的next方法中。	Scanner还有相应的hasNext方法，用以判断下一个输入分词是否所需的类型。

Scanner有一个假设，在输入结束时会抛出IOException，所以Scanner会把IOException吞掉。不过通过ioException()方法，你可以找到最近发生的异常，因此，你可以在必要时检查它。

### 13.7.1 Scanner定界符

默认情况下，Scanner根据空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的定界符。

useDelimiter()设置定界符，同时还有一个delimiter()方法用来返回当前正在作为定界符使用的Pattern对象。

### 13.7.2 用正则表达式扫描

## 13.8 StringTokenizer

基本上，我们可以放心地说，StringTokenizer已经可以废弃不用了。

# 第14章 类型信息

RTTI（Run-Time Type Identification）运行阶段类型识别

运行时类型信息使得你可以在程序运行时发现和适用类型信息。

一种是“传统的”RTTI；另一种是“反射”机制

## 14.1 为什么需要RTTI

如果能够知道某个泛化引用的确切类型，就可以使用最简单的方式去解决它。使用RTTI，可以查询某个Shape引用所指的对象的确切类型，然后选择或者剔除特例。

## 14.2 Class对象

Class对象包含了与类相关的信息。事实上，Class对象就是用来创建类的所有的“常规”对象的。Java使用Class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。Class类还拥有大量的使用RTTI的其他方式。

类是程序的一部分，每个类都有一个class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象（更恰当地说，是被保存在了一个同名的.class文件中）。为了生成这个类的对象，运行这个程序的Java虚拟机（JVM）将使用被称为“类加载器”的子系统。

类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括JavaAPI类，它们通常是从本地盘加载的。

所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当做对类的静态成员的引用。

因此，Java程序在它开始运行之前并非被完全加载，其各个部分在必需时才加载的。这一点与许多传统语言都不同。

类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件（例如，某个附加类加载器可能会在数据库中查找字节码）。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码（这是Java中用于安全防范目的的措施之一）

一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。

forName()这个方法是Class类（所有Class对象都属于这个类）的一个static成员。它是取得Class对象的引用的一种方法。	对forName()的调用有个“副作用”：如果类还没被加载就加载它。

Class.forName()找不到你要加载的类，它会抛出异常ClassNotFoundException。

如果你已经拥有了一个感兴趣的类型的对象，就可以通过调用getClass()方法来获取Class引用了，这个方法属于根类Object的一部分，它将返回表示该对象的实际类型的Class引用。

printInfo()使用getName()来产生全限定的类名，并分别使用getSimpleName()和getCanonicalName()（在Java SE 5 中引入的）来产生不含包名的类名和全限定的类名。isInterface()方法如同其名，可以告诉你这个Class对象是否表达某个接口。

在main()中调用的Class.getInterfaces()方法返回的是Class对象，它们表示在感兴趣的Class对象中所包含的接口。

如果你有一个Class对象，还可以使用getSuperclass()方法查询其直接基类，这将返回你可以用来进一步查询的Class对象。

Class的newInstance()方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明：“我不知道你的确切类型，但是无论如何要正确地创建你自己。”	使用newInstance()来创建的类，必须带有默认的构造器。

### 14.2.1 类字面常量

Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。

这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中）。

类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及其他基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象。例如：boolean.class等价于Boolean.TYPE

我建议用“.class”的形式，以保持与普通类的一致性。

注意，有一点很有趣，当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：

1. 加载，这是由类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并不是必须的），并从这些字节码中创建一个Class对象。
2. 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。
3. 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用才执行。

初始化有效地实现了尽可能的“惰性”。仅使用.class语法来获得来获得对类的引用不会引发初始化。而Class.forName()立即就进行了初始化。

如果一个static final值是“编译期常量”，这个值不需要对Initable类进行初始化就可以被读取。但是，如果只是将一个域设置为static和final的，还不足以确保这种行为，因为它不是编译期常量。

如果一个static域不是final的，那么在对它访问时，总是要求在它被读取之前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间）

### 14.2.2 泛化的Class引用

通过使用泛型语法，可以让编译器强制执行额外的类型检查。

`Class<Number> genericNumberClass = int.class;`看起来是起作用的，因为Integer继承自Number。但是它无法工作，因为Integer Class对象不是Number Class对象的子类（这种差异看起来可能有些诡异，我们将在15章深入讨论它）

为了在使用泛化的Class引用时放松限制，我使用了通配符，它是Java泛型的一部分。通配符就是“？”，表示“任何事物”。

在Java SE5中，Class\<?>优于平凡的Class，即便它们是等价的，而且平凡的Class如你所见，不会产生编译器警告信息。Class\<?>的好处就是它表示你并非是碰巧或者由于疏忽，而使用了一个非具体的类引用，你就是选择了非具体的版本。

为了创建一个Class引用，它被限制为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字相结合，创建一个范围。

如果你手头的是超类，那编译器将只允许你声明超类引用是“某个类，它是FancyToy超类”就像在表达式Class\<? Super FancyToy>中所看的，而不会接受Class\<Toy>这样的声明。这看上去显得有些怪，因为getSuperClass()方法返回的是基类（不是接口）。正是由于这种含糊性，up.newInstance()的返回值不是精确类型，而只是Object。

### 14.2.3 新的转型语法

Java SE5还添加了用于Class引用的转型语法，即cast()方法：

cast()方法接受参数对象，并将其转型为Class引用的类型。这种转型多做了很多额外的工作。新的转型语法对于无法使用普通转型的情况显得非常有用，在你编写泛型代码时，如果你存储了Class引用，并希望以后通过这个引用来执行转型，这种情况就会时有发生。这被证明是一种罕见的情况——我发现整个Java SE5类库中，只有一处使用了cast()。

在Java SE5中另一个没有任何用处的新特性就是Class.asSubclass()，该方法允许你将一个类对象转型为更加具体的类型。

## 14.3 类型转换前先做检查

1）传统的类型转换，如“（Shape）”，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。

2）代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。

在C++中，经典的类型转换“（Shape）”并不使用RTTI。它只是简单地告诉编译器将这个对象作为新的类型对待。而Java要执行类型检查，这通常被称为“类型安全的向下转型”。

RTTI在Java中还有第三种形式，就是关键字instanceof。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。

在向下转型前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用instanceof是非常重要的，否则会得到一个ClassCastException异常。

### 14.3.1 使用类字面常量

### 14.3.2 动态的instanceof

Class.isInstance方法提供了一种动态地测试对象的途径。

isInstance()方法使我们不再需要instanceof表达式

### 14.3.3 递归计数

Class.isAssignableFrom()

## 14.4 注册工厂

工厂方法设计模式，将对象的创建工作交给类自己去完成。工厂方法可以被多态地调用，从而为你创建恰当类型的对象。

## 14.5 instanceof与Class的等价性

使人放心的是，instanceof和isInstance()生成的结果完全一样，equals()和\==也一样。instanceof保持了类型的概念，它指的是“你是这个类吗，或者你是这个类的派生类吗？”如果用\==比较实际的Class对象，就没有考虑继承——它或者是这个确切类型，或者不是。

## 14.6 反射：运行时的类信息

如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它。

“基于构件的编程”	快速应用开发（RAD）	集成开发环境（IDE）	反射提供了一种机制——用来检查可用的方法，并返回方法名。Java通过JavaBeans提供了基于构件的编程架构。

远程方法架构（RMI）

Class类和java.lang.reflect类库一起反射的概念进行了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这样你就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等很便利的方法，以返回字段、方法以及构造器的对象的数组

RTTI和反射之间真正的区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件。而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。

### 14.6.1 类方法提取器

反射是用来支持其他特性的，例如对象序列化和JavaBean。但是如果能动态地提取某个类的信息有的时候还是很有用的。请考虑类方法提取器。

Class的getMethods()和getConstuctors()方法分别返回Method对象的数组和Constructor对象的数组。

## 14.7 动态代理

代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常设计与“实际”对象的通信，因此代理通常充当着中间人的角色。

Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。

通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要得到一个类加载器（你通常可以从已经被加载的对象中获取其类加载器，然后传递给它），一个你希望该代理实现的接口列表（不是类或抽象类），以及InvocationHandler接口的一个实现。

invoke()方法中传递进来了代理对象，以防你需要区分请求的来源，但是在许多情况下，你并不关心这一点。然而，在invoke()内部，在代理上调用方法时需要格外当心，因为对接口的调用将被重定向为对代理的调用。

## 14.8 空对象

有时引入空对象的思想会很有用，它可以接受传递给它的所代表的对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。通过这种方式，你可以假设所有的对象都是有效的，而不必浪费编程精力去检查null（并阅读所产生的代码）。

### 14.8.1 模拟对象与桩

## 14.9 接口与类型信息

interface关键字一种重要目标就是允许程序员隔离构件、进而降低耦合性。如果你编写接口，那么就可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并非是对解耦的一种无懈可击的保障。

一种解决方案是直接声明，如果程序员决定使用实际的类而不是接口，他们需要自己对自己负责。你也许希望应用一些更严苛的控制。

最简单的方式是对实现使用包访问权限

## 14.10 总结

RTTI允许通过匿名基类的引用来发现类型信息。	面向对象编程语言的目的是让我们在凡是可以使用的地方都使用多态机制，只在必须的时候使用RTTI。

# 第15章 泛型

Java SE5的重大变化之一：泛型的概念。泛型实现了参数化类型的概念，使代码可以应用于多种类型。

## 15.1 与C++的比较

首先，了解C++模板的某些方面，有助于你理解泛型的基础。同时，非常重要的一点是，你可以了解java的泛型的局限是什么，以及为什么会有这些限制。

第二个原因是，在Java社区中，人们普遍对C++模板有一种误解，而这种误解可能会误导你，令你在理解泛型的意图时产生偏差。

## 15.2 简单泛型

许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。

Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。

### 15.2.1 一个元组类库

仅一次方法调用就能返回多个对象，你应该需要这样的功能吧。

这个概念称为**元组（tuple）**，它是将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。（这个概念也称为**数据传送对象**，或**信使**）。

通常元组可以拥有任意长度，同时，元组中的对象可以是任意不同的类型。不过，我们希望能够为每一个对象指明其类型，并且从容器中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。