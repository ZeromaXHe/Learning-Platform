# 第1章 快速上手：基础知识

## 1.3 数和表达式

所有常见算术运算符的工作原理都与你预期的一致。除法运算的结果为小数，即**浮点数**（float或floating-point number）。

~~~python
>>> 1 / 2
0.5
>>> 1 / 1
1.0
~~~

如果你想丢弃小数部分，即执行整除运算，可使用双斜杠。

~~~python
>>> 1 // 2
0
>>> 1 // 1
1
>>> 5.0 / 2.4
2.0
~~~

至此，你了解了基本的算术运算符（加法、减法、乘法和除法），但还有一种与整除关系紧密的运算没有介绍。

~~~python
>>> 1 % 2
1
~~~

这是求余（求模）运算符。x % y 的结果为x除以y的余数。换而言之，结果为执行整除时余下的部分，即x % y 等价于x - ((x // y) * y)。

~~~python
>>> 10 // 3 
3 
>>> 10 % 3
1 
>>> 9 // 3 
3 
>>> 9 % 3
0 
>>> 2.75 % 0.5
0.25
~~~

从最后一个示例可知，求余运算符也可用于浮点数。

这种运算符甚至可用于负数，但可能不那么好理解。

~~~python
>>> 10 % 3
1 
>>> 10 % -3
-2 
>>> -10 % 3
2 
>>> -10 % -3 
-1
~~~

你也许不能通过这些示例一眼看出求余运算的工作原理，但通过研究与之配套的整除运算可帮助理解。

~~~python
>>> 10 // 3 
3 
>>> 10 // -3 
-4 
>>> -10 // 3 
-4 
>>> -10 // -3 
3
~~~

基于除法运算的工作原理，很容易理解最终的余数是多少。对于整除运算，需要明白的一个重点是它向下圆整结果。因此在结果为负数的情况下，圆整后将离0更远。这意味着对于-10 // 3， 将**向下**圆整到-4，而不是**向上**圆整到-3。

这里要介绍的最后一个运算符是乘方（求幂）运算符。

~~~python
>>> 2 ** 3 
8 
>>> -3 ** 2
-9 
>>> (-3) ** 2 
9
~~~

请注意，乘方运算符的优先级比求负（单目减）高，因此`-3**2`等价于`-(3**2)`。如果你要计算的是`(-3)**2`，必须明确指出。

### 十六进制、八进制和二进制

结束本节前需要指出的是，十六进制数、八进制数和二进制数分别以下面的方式表示：

~~~python
>>> 0xAF 
175 
>>> 010 
8 
>>> 0b1011010010 
722
~~~

这些表示法都以0打头。（如果你不明白这些表示法有何意义，说明你使用它们的机会不多，只需将其牢记在心即可。）

## 1.4 变量

另一个你可能熟悉的概念是**变量**（variable）。如果代数对你来说不过是遥远的记忆，也不用担心，因为Python中的变量理解起来很容易。变量是表示（或指向）特定值的名称。例如，你可能想使用名称x来表示3，为此执行如下代码：

~~~python
>>> x = 3
~~~

这称为**赋值**（assignment），我们将值3赋给了变量x。换而言之，就是将变量x与值（或对象）3关联起来。给变量赋值后，就可在表达式中使用它。

~~~python
>>> x * 2 
6
~~~

不同于其他一些语言，使用Python变量前必须给它赋值，因为Python变量没有默认值。

> **注意** 在Python中，名称（**标识符**）只能由字母、数字和下划线（_）构成，且不能以数字打头。因此Plan9是合法的变量名，而9Plan不是。
>
> 在某种程度上说，标识符命名规则基于Unicode标准，详情请参阅“Python语言参考手册”

## 1.5 语句

语句和表达式有何不同呢？你可以这样想：表达式是一些东西，而语句做一些事情。

涉及赋值时，语句和表达式的差别更明显：鉴于赋值语句不是表达式，它们没有可供交互式解释器打印的值。

执行赋值语句后，交互式解释器只是再次显示提示符，但发生了一些变化：有一个名为x的新变量，与值3相关联。可以说，这是所有语句的一个根本特征：执行修改操作。例如，赋值语句改变变量，而print语句改变屏幕的外观。

## 1.6 获取用户输入

我们来看看很有用的函数input（稍后将更详细地介绍函数）。

~~~python
>>> input("The meaning of life: ") 
The meaning of life: 42 
'42'
~~~

这里在交互式解释器中执行了第一行（input(...)），它打印字符串"The meaning of life:"，提示用户输入相应的信息。我输入42并按回车。这个数被input（以文本或字符串的方式）返回，并在最后一行被自动打印出来。通过使用int将字符串转换为整数，可编写一个更有趣的示例：

~~~python
>>> x = input("x: ") 
x: 34 
>>> y = input("y: ") 
y: 42 
>>> print(int(x) * int(y)) 
1428
~~~

对于上述在Python提示符（>>>）下输入的语句，可将其放在完整的程序中，并让用户提供所需的值（34和42）。这样，这个程序将打印结果1428，即前述两个数的乘积。

## 1.7 函数

1.3节使用了乘方运算符（`**`）来执行幂运算。实际上，可不使用这个运算符，而使用**函数**pow。

~~~python
>>> 2 ** 3 
8 
>>> pow(2, 3) 
8
~~~

函数犹如小型程序，可用来执行特定的操作。Python提供了很多函数，可用来完成很多神奇的任务。实际上，你也可以自己编写函数（这将在后面更详细地介绍），因此我们通常将pow等标准函数称为**内置函数**。

有多个内置函数可用于编写数值表达式。例如，abs计算绝对值，round将浮点数圆整为与之最接近的整数。

整数总是向下圆整，而round圆整到最接近的整数，并在两个整数一样近时圆整到偶数。如果要将给定的数向下圆整，该如何做呢？例如，你知道某人的年龄为32.9，并想将这个值向下圆整为32，因为他还没有满33岁。Python提供了完成这种任务的函数floor，但你不能直接使用它，因为像众多很有用的函数一样，它也包含在模块中。

## 1.8 模块

可将模块视为扩展，通过将其导入可以扩展Python功能。要导入模块，可使用特殊命令import。前一节提及的函数floor包含在模块math中。

~~~python
>>> import math 
>>> math.floor(32.9) 
32
~~~

请注意其中的工作原理：我们使用import导入模块，再以module.function的方式使用模块中的函数。就这里执行的操作而言，也可像前面处理input的返回值那样，将这个数字转换为整数。

~~~python
>>> int(32.9) 
32
~~~

> **注意** 还有一些类似的函数，可用于转换类型，如str和float。实际上，它们并不是函数，而是类。类将在本书后面更详细地介绍。

模块math还包含其他几个很有用的函数。例如，ceil与floor相反，返回大于或等于给定数的最小整数。

~~~python
>>> math.ceil(32.3) 
33 
>>> math.ceil(32) 
32
~~~

如果确定不会从不同模块导入多个同名函数，你可能不想每次调用函数时都指定模块名。在这种情况下，可使用命令import的如下变种：

~~~python
>>> from math import sqrt 
>>> sqrt(9) 
3.0
~~~

通过使用命令import的变种from module import function，可在调用函数时不指定模块前缀。

> **提示** 事实上，可使用变量来引用函数（以及其他大部分Python元素）。执行赋值语句`foo = math.sqrt`后，就可使用foo来计算平方根。例如，foo(4)的结果为2.0。

### 1.8.1 cmath和负数

如果我们坚持将值域限定为实数，并使用其近似的浮点数实现，就无法计算负数的平方根。负数的平方根为虚数，而由实部和虚部组成的数为**复数**。Python标准库提供了一个专门用于处理复数的模块。

~~~python
>>> import cmath 
>>> cmath.sqrt(-1) 
1j
~~~

注意到这里没有使用from ... import ...。如果使用了这种import命令，将无法使用常规函数sqrt。类似这样的名称冲突很隐蔽，因此除非必须使用from版的import命令，否则应坚持使用常规版import命令。

1j是个虚数，虚数都以j（或J）结尾。复数算术运算都基于如下定义：-1的平方根为1j。这里不深入探讨这个主题，只举一个例子来结束对复数的讨论：

~~~python
>>> (1 + 3j) * (9 + 4j) 
(-3 + 31j)
~~~

从这个示例可知，Python本身提供了对复数的支持。

> **注意** Python没有专门表示虚数的类型，而将虚数视为实部为零的复数。

### 1.8.2 回到未来

据说Python之父Guido van Rossum有一台时光机，因为这样的情况出现了多次：大家要求Python提供某项功能时，却发现这项功能早已实现。当然，并非什么人都能进入这台时光机，不过Guido很体贴，通过神奇模块`__future__`让Python具备了时光机的部分功能。对于Python当前不支持，但未来将成为标准组成部分的功能，你可从这个模块进行导入。这一点你在1.3节已经见识过，本书后面也将经常遇到这个模块。

## 1.9 保存并执行程序

### 1.9.1 从命令提示符运行 Python 脚本

实际上，运行程序的方式有多种。首先，假定你打开了DOS窗口或UNIX shell，并切换到了Python可执行文件（在Windows中为python.exe，在UNIX中为python）或将该可执行文件所在的目录加入到了环境变量PATH中（仅适用于Windows）。另外，假定前一节的脚本（hello.py）存储在当前目录下。满足上述条件后，就可在Windows中使用如下命令来执行这个脚本：

`C:\>python hello.py`

在UNIX系统中，可使用如下命令：

~~~shell
$ python hello.py
~~~

如你所见，命令是一样的，只是系统提示符不同。

### 1.9.2 让脚本像普通程序一样

在有些情况下，你希望能够像执行其他程序（如Web浏览器或文本编辑器）一样执行Python脚本，而无需显式地使用Python解释器。UNIX提供了实现这种目标的标准方式：让脚本的第一行以字符序列#!（称为pound bang或shebang）开始，并在它后面指定用于对脚本进行解释的程序（这里是Python）的绝对路径。即便你对这一点不太明白，只需将下面的代码作为脚本的第一行，就可在UNIX中轻松运行脚本：

~~~python
#!/usr/bin/env python
~~~

不管Python库位于什么地方，这都将让你能够像运行普通程序一样运行脚本。如果你安装了多个版本的Python，可用更具体的可执行文件名（如python3）替换python。

要像普通程序一样运行脚本，还必须将其变成可执行的：

~~~shell
$ chmod a+x hello.py
~~~

现在，可以像下面这样来运行它（假定当前目录包含在执行路径中）：

~~~shell
$ hello.py
~~~

如果这不管用，请尝试使用./hello.py，这在当前目录（.）未包含在执行路径中时也管用（负责的系统管理员会告诉你执行路径是什么）。

如果你愿意，可对文件进行重命名并删除扩展名.py，使其看起来更像普通程序。

#### 如果双击会如何呢

在Windows中，扩展名`.py`是让脚本像普通程序一样的关键所在。请尝试双击前一节保存的文件hello.py。如果正确地安装了Python，这将打开一个DOS窗口，其中包含提示信息What is your name?。然而，这样运行程序存在一个问题：输入名字后，程序窗口将立即关闭，你根本来不及看清结果。这是因为程序结束后窗口将立即关闭。尝试修改脚本，在末尾添加如下代码行：

~~~python
input("Press <enter>")
~~~

现在运行这个程序并输入名字后，DOS窗口将包含如下内容：

~~~
What is your name? Gumby 
Hello, Gumby! 
Press <enter>
~~~

等你按回车键后，窗口将立即关闭，因为程序结束了。

### 1.9.3 注释

在Python中，井号（#）比较特殊：在代码中，井号后面到行尾的所有内容都将被忽略。（这也是Python解释器未被前面的/usr/bin/env卡住的原因所在。）

## 1.10 字符串

### 1.10.1 单引号字符串以及对引号转义

与数一样，字符串也是值：

~~~python
>>> "Hello, world!" 
'Hello, world!'
~~~

在这个示例中，有一点可能让你颇感意外：Python在打印字符串时，用单引号将其括起，而我们使用的是双引号。这有什么差别吗？其实没有任何差别。

这里使用的是单引号，结果完全相同。既然如此，为何同时支持单引号和双引号呢？因为在有些情况下，这可能会有用。

~~~python
>>> "Let's go!" 
"Let's go!" 
>>> '"Hello, world!" she said' 
'"Hello, world!" she said'
~~~

第二个字符串包含双引号，因此必须使用单引号将整个字符串括起，原因和前面一样。实际上，并非必须这样做（这样做只是出于方便考虑）。可使用反斜杠（\）对引号进行转义，如下所示

~~~python
>>> "\"Hello, world!\" she said" 
'"Hello, world!" she said'
~~~

像这样对引号进行转义很有用，且在有些情况下必须这样做。例如，在字符串同时包含单引号和双引号（如`'Let\'s say "Hello, world!"'`）时，如果不使用反斜杠进行转义，该如何办呢？

> **注意** 厌烦了反斜杠？你在本章后面将看到，在大多数情况下，可通过使用长字符串和原始字符串（可结合使用这两种字符串）来避免使用反斜杠。

### 1.10.2 拼接字符串

那么应该如何拼接字符串呢？就像将数相加一样，将它们相加

### 1.10.3 字符串表示str和repr

~~~python
>>> "Hello,\nworld!" 
'Hello,\nworld!' 
>>> print("Hello,\nworld!") 
Hello, 
world!
~~~

通过两种不同的机制将值转换成了字符串。你可通过使用函数str和repr直接使用这两种机制。使用str能以合理的方式将值转换为用户能够看懂的字符串。例如，尽可能将特殊字符编码转换为相应的字符。然而，使用repr时，通常会获得值的合法Python表达式表示。

~~~python
>>> print(repr("Hello,\nworld!")) 
'Hello,\nworld!' 
>>> print(str("Hello,\nworld!")) 
Hello, 
world!
~~~

### 1.10.4 长字符串、原始字符串和字节

有一些独特而有用的字符串表示方式。例如，有一种独特的语法可用于表示包含换行符或反斜杠的字符串（**长字符串**和**原始字符串**）。对于包含特殊符号的字符串，Python 2还提供了一种专用的表示语法，结果为Unicode字符串。这种语法现在依然管用，但是多余，因为在Python 3中，**所有**的字符串都是Unicode字符串。Python 3还引入了一种新语法，用于表示大致相当于老式字符串的字节对象。你将看到，在处理Unicode编码方面，这种对象依然扮演着重要的角色。

#### 1. 长字符串

要表示很长的字符串（跨越多行的字符串），可使用三引号（而不是普通引号）。

~~~python
print('''This is a very long string. It continues here. 
And it's not over yet. "Hello, world!" 
Still here.''')
~~~

还可使用三个双引号，如`"""like this"""`。请注意，这让解释器能够识别表示字符串开始和结束位置的引号，因此字符串本身可包含单引号和双引号，无需使用反斜杠进行转义。

> **提示** 常规字符串也可横跨多行。只要在行尾加上反斜杠，反斜杠和换行符将被转义，即被忽略。例如，如果编写如下代码：
>
> ~~~python
> print("Hello, \ world!")
> ~~~
>
> 它将打印Hello, world!。这种处理手法也适用于表达式和语句。
>
> ~~~python
> >>> 1 + 2 + \ 
>  	4 + 5 
> 12 
> >>> print \ 
>  	('Hello, world') 
> Hello, world
> ~~~

#### 2. 原始字符串

原始字符串不以特殊方式处理反斜杠，因此在有些情况下很有用。在常规字符串中，反斜杠扮演着特殊角色：它对字符进行转义，让你能够在字符串中包含原本无法包含的字符。

对于很长的路径，将需要使用大量的反斜杠。

`path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'`

在这样的情况下，原始字符串可派上用场，因为它们根本不会对反斜杠做特殊处理，而是让字符串包含的每个字符都保持原样。

~~~python
>>> print(r'C:\nowhere') 
C:\nowhere 
>>> print(r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz') 
C:\Program Files\fnord\foo\bar\baz\frozz\bozz
~~~

如你所见，原始字符串用前缀r表示。看起来可在原始字符串中包含任何字符，这大致是正确的。一个例外是，引号需要像通常那样进行转义，但这意味着用于执行转义的反斜杠也将包含在最终的字符串中。

~~~python
>>> print(r'Let\'s go!') 
Let\'s go!
~~~

另外，原始字符串不能以单个反斜杠结尾。换而言之，原始字符串的最后一个字符不能是反斜杠，除非你对其进行转义（但进行转义时，用于转义的反斜杠也将是字符串的一部分）。根据前一个示例，这一点应该是显而易见的。如果最后一个字符（位于结束引号前面的那个字符）为反斜杠，且未对其进行转义，Python将无法判断字符串是否到此结束。

~~~python
>>> print(r"This is illegal\") 
SyntaxError: EOL while scanning string literal
~~~

这合乎情理，但如果要指定以反斜杠结尾的原始字符串（如以反斜杠结尾的DOS路径），该如何办呢？本节介绍了大量技巧，应该能够帮助你解决这个问题，但基本技巧是将反斜杠单独作为一个字符串，下面是一个简单的示例：

~~~python
>>> print(r'C:\Program Files\foo\bar' '\\') 
C:\Program Files\foo\bar\
~~~

请注意，指定原始字符串时，可使用单引号或双引号将其括起，还可使用三引号将其括起。

#### 3. Unicode、bytes和bytearray

Python字符串使用Unicode编码来表示文本。对大多数简单程序来说，这一点是完全透明的，因此如果你愿意，可跳过本节，等需要时再学习这个主题。然而，鉴于处理字符串和文本文件的Python代码很多，大致浏览一下本节至少不会有什么坏处。

大致而言，每个Unicode字符都用一个码点（code point）表示，而码点是Unicode标准给每个字符指定的数字。这让你能够以任何现代软件都能识别的方式表示129个文字系统中的12万个以上的字符。当然，鉴于计算机键盘不可能包含几十万个键，因此有一种指定Unicode字符的通用机制：使用16或32位的十六进制字面量（分别加上前缀\u或\U）或者使用字符的Unicode名称（\N{*name*}）

~~~python
>>> "\u00C6" 
'Æ' 
>>> "\U0001F60A" 
'☺ '
>>> "This is a cat: \N{Cat}" 
'This is a cat: '
~~~

Unicode的理念很简单，却带来了一些挑战，其中之一是编码问题。在内存和磁盘中，所有对象都是以二进制数字（0和1）表示的（这些数字每8个为一组，即1字节），字符串也不例外。在诸如C等编程语言中，这些字节完全暴露，而字符串不过是字节序列而已。为与C语言互操作以及将文本写入文件或通过网络套接字发送出去，Python提供了两种类似的类型：不可变的bytes和可变的bytearray。如果需要，可直接创建bytes对象（而不是字符串），方法是使用前缀b：

# 第2章 列表和元组

本章将介绍一个新概念：**数据结构**。数据结构是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。在Python中，最基本的数据结构为**序列**（sequence）。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推。在有些编程语言中，从1开始给序列中的元素编号，但从0开始指出相对于序列开头的**偏移量**。这显得更自然，同时可回绕到序列末尾，用负索引表示序列末尾元素的位置。你可能认为这种编号方式有点怪，但我敢肯定，你很快就会习惯的。

## 2.1 序列概述

Python内置了多种序列，本章重点讨论其中最常用的两种：列表和元组。另一种重要的序列是字符串，将在下一章更详细地讨论。

列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。禁止修改序列通常出于技术方面的考虑，与Python的内部工作原理相关，这也是有些内置函数返回元组的原因所在。在你自己编写程序时，几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键，这将在第4章讨论。在这种情况下，不能使用列表来代替元组，因为字典键是不允许修改的。

在需要处理一系列值时，序列很有用。在数据库中，你可能使用序列来表示人，其中第一个元素为姓名，而第二个元素为年龄。如果使用列表来表示（所有元素都放在方括号内，并用逗号隔开），将类似于下面这样：

~~~python
>>> edward = ['Edward Gumby', 42]
~~~

序列还可包含其他序列，因此可创建一个由数据库中所有人员组成的列表：

~~~python
>>> edward = ['Edward Gumby', 42]
>>> john = ['John Smith', 50] 
>>> database = [edward, john] 
>>> database 
[['Edward Gumby', 42], ['John Smith', 50]]
~~~

> **注意** Python支持一种数据结构的基本概念，名为**容器**（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。映射将在第4章详细讨论。有一种既不是序列也不是映射的容器，它就是集合（set），将在第10章讨论。

## 2.2 通用的序列操作

有几种操作适用于所有序列，包括**索引**、**切片**、**相加**、**相乘**和**成员资格检查**。另外，Python还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。

> **注意** 有一个重要的操作这里不会介绍，它就是**迭代**（iteration）。对序列进行迭代意味着对其每个元素都执行特定的操作。有关迭代的详细信息，请参阅5.5节。

### 2.2.1 索引

序列中的所有元素都有编号——从0开始递增。你可像下面这样使用编号来访问各个元素

~~~python
>>> greeting = 'Hello' 
>>> greeting[0] 
'H'
~~~

> **注意** 字符串就是由字符组成的序列。索引0指向第一个元素，这里为字母H。不同于其他一些语言，Python没有专门用于表示字符的类型，因此一个字符就是只包含一个元素的字符串。

这称为**索引**（indexing）。你可使用索引来获取元素。这种索引方式适用于所有序列。当你使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此-1是最后一个元素的位置。

~~~python
>>> greeting[-1] 
'o'
~~~

对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给变量。这与先赋给变量再对变量执行索引操作的效果是一样的。

~~~python
>>> 'Hello'[1] 
'e'
~~~

如果函数调用返回一个序列，可直接对其执行索引操作。例如，如果你只想获取用户输入的年份的第4位，可像下面这样做：

~~~python
>>> fourth = input('Year: ')[3] 
Year: 2005 
>>> fourth 
'5'
~~~

### 2.2.2 切片

除使用索引来访问单个元素外，还可使用**切片**（slicing）来访问特定范围内的元素。为此，可使用两个索引，并用冒号分隔：

~~~python
>>> tag = '<a href="http://www.python.org">Python web site</a>' 
>>> tag[9:30] 
'http://www.python.org' 
>>> tag[32:-4] 
'Python web site'
~~~

如你所见，切片适用于提取序列的一部分，其中的编号非常重要：第一个索引是包含的第一

个元素的编号，但第二个索引是切片后余下的第一个元素的编号。请看下面的示例：

~~~python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
>>> numbers[3:6] 
[4, 5, 6] 
>>> numbers[0:1] 
[1]
~~~

简而言之，你提供两个索引来指定切片的边界，其中第一个索引指定的元素包含在切片内，但第二个索引指定的元素不包含在切片内。

#### 1. 绝妙的简写

假设你要访问前述数字列表中的最后三个元素，显然可以明确地指定这一点。

~~~python
>>> numbers[7:10] 
[8, 9, 10]
~~~

在这里，索引10指的是第11个元素：它并不存在，但确实是到达最后一个元素后再前进一步所处的位置。明白了吗？如果要从列表末尾开始数，可使用负数索引。

~~~python
>>> numbers[-3:-1] 
[8, 9]
~~~

然而，这样好像无法包含最后一个元素。如果使用索引0，即到达列表末尾后再前进一步所处的位置，结果将如何呢？

~~~python
>>> numbers[-3:0] 
[]
~~~

结果并不是你想要的。事实上，执行切片操作时，如果第一个索引指定的元素位于第二个索引指定的元素后面（在这里，倒数第3个元素位于第1个元素后面），结果就为空序列。好在你能使用一种简写：如果切片结束于序列末尾，可省略第二个索引。

~~~python
>>> numbers[-3:] 
[8, 9, 10]
~~~

同样，如果切片始于序列开头，可省略第一个索引。

~~~python
>>> numbers[:3] 
[1, 2, 3]
~~~

实际上，要复制整个序列，可将两个索引都省略。

~~~python
>>> numbers[:] 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~

#### 2. 更大的步长

执行切片操作时，你显式或隐式地指定起点和终点，但通常省略另一个参数，即步长。在普通切片中，步长为1。这意味着从一个元素移到下一个元素，因此切片包含起点和终点之间的所有元素。

~~~python
>>> numbers[0:10:1] 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~

在这个示例中，指定了另一个数。你可能猜到了，这显式地指定了步长。如果指定的步长大于1，将跳过一些元素。例如，步长为2时，将从起点和终点之间每隔一个元素提取一个元素。

~~~python
>>> numbers[0:10:2] 
[1, 3, 5, 7, 9] 
numbers[3:6:3] 
[4]
~~~

显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供步长4即可。

~~~python
>>> numbers[::4] 
[1, 5, 9]
~~~

当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。

~~~python
>>> numbers[8:3:-1] 
[9, 8, 7, 6, 5] 
>>> numbers[10:0:-2] 
[10, 8, 6, 4, 2] 
>>> numbers[0:10:-2] 
[] 
>>> numbers[::-2] 
[10, 8, 6, 4, 2]
>>> numbers[5::-2] 
[6, 4, 2] 
>>> numbers[:5:-2] 
[10, 8]
~~~

在这种情况下，要正确地提取颇费思量。如你所见，第一个索引依然包含在内，而第二个索引不包含在内。步长为负数时，第一个索引必须比第二个索引大。可能有点令人迷惑的是，当你省略起始和结束索引时，Python竟然执行了正确的操作：步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点。

### 2.2.3 序列相加

可使用加法运算符来拼接序列。

~~~python
>>> [1, 2, 3] + [4, 5, 6] 
[1, 2, 3, 4, 5, 6] 
>>> 'Hello,' + 'world!' 
'Hello, world!' 
>>> [1, 2, 3] + 'world!' 
Traceback (innermost last): 
	File "<pyshell>", line 1, in ? 
		[1, 2, 3] + 'world!' 
TypeError: can only concatenate list (not "string") to list
~~~

从错误消息可知，不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类型的序列。

### 2.2.4 乘法

将序列与数*x*相乘时，将重复这个序列*x*次来创建一个新序列：

~~~python
>>> 'python' * 5 
'pythonpythonpythonpythonpython' 
>>> [42] * 10 
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
~~~

#### None、空列表和初始化

空列表是使用不包含任何内容的两个方括号（`[]`）表示的。如果要创建一个可包含10个元素的列表，但没有任何有用的内容，可像前面那样使用`[42]*10`。但更准确的做法是使用`[0]*10`，这将创建一个包含10个零的列表。然而，在有些情况下，你可能想使用表示“什么都没有”的值，如表示还没有在列表中添加任何内容。在这种情况下，可使用None。在Python中，None表示什么都没有。因此，要将列表的长度初始化为10，可像下面这样做

~~~python
>>> sequence = [None] * 10 
>>> sequence 
[None, None, None, None, None, None, None, None, None, None]
~~~

### 2.2.5 成员资格

要检查特定的值是否包含在序列中，可使用运算符in。这个运算符与前面讨论的运算符（如乘法或加法运算符）稍有不同。它检查是否满足指定的条件，并返回相应的值：满足时返回True，不满足时返回False。这样的运算符称为**布尔运算符**，而前述真值称为**布尔值**。布尔表达式将在5.4节详细介绍。

下面是一些in运算符的使用示例：

~~~python
>>> permissions = 'rw' 
>>> 'w' in permissions 
True 
>>> 'x' in permissions 
False 
>>> users = ['mlh', 'foo', 'bar'] 
>>> input('Enter your user name: ') in users 
Enter your user name: mlh 
True 
>>> subject = '$$$ Get rich now!!! $$$' 
>>> '$$$' in subject 
True
~~~

开头两个示例使用成员资格测试分别检查'w'和'x'是否包含在字符串变量permissions中。在UNIX系统中，可在脚本中使用这两行代码来检查对文件的写入和执行权限。接下来的示例检查提供的用户名mlh是否包含在用户列表中，这在程序需要执行特定的安全策略时很有用（在这种情况下，可能还需检查密码）。最后一个示例检查字符串变量subject是否包含字符串'$$$'，这可用于垃圾邮件过滤器中。

> **注意**
>
> 相比于其他示例，检查字符串是否包含'$$$'的示例稍有不同。一般而言，运算符in检查指定的对象是否是序列（或其他集合）的成员（即其中的一个元素），但对字符串来说，只有它包含的字符才是其成员或元素，因此下面的代码完全合理：
>
> ~~~python
> >>> 'P' in 'Python' 
> True
> ~~~
>
> 事实上，在较早的Python版本中，只能对字符串执行这种成员资格检查——确定指定的字符是否包含在字符串中，但现在可使用运算符in来检查指定的字符串是否为另一个字符串的子串。

#### 长度、最小值和最大值

内置函数len、min和max很有用，其中函数len返回序列包含的元素个数，而min和max分别返回序列中最小和最大的元素（对象比较将在5.4.6节的“比较运算符”部分详细介绍）。

~~~python
>>> numbers = [100, 34, 678] 
>>> len(numbers) 
3 
>>> max(numbers) 
678 
>>> min(numbers)
34 
>>> max(2, 3) 
3 
>>> min(9, 3, 2, 5) 
2
~~~

基于前面的解释，这些代码应该很容易理解，但最后两个表达式可能例外。在这两个表达式中，调用max和min时指定的实参并不是序列，而直接将数作为实参。

## 2.3 列表：Python 的主力

前面的示例大量地使用了列表，你明白了它们很有用，但本节主要讨论列表不同于元组和字符串的地方——列表是可变的，即可修改其内容。另外，列表有很多特有的**方法**。

### 2.3.1 函数 list

鉴于不能像修改列表那样修改字符串，因此在有些情况下使用字符串来创建列表很有帮助。为此，可使用函数list。（它实际上是一个类，而不是函数，但眼下，这种差别并不重要。）

~~~python
>>> list('Hello') 
['H', 'e', 'l', 'l', 'o']
~~~

请注意，可将任何序列（而不仅仅是字符串）作为list的参数。

> **提示** 要将字符列表（如前述代码中的字符列表）转换为字符串，可使用下面的表达式：
>
> `''.join(somelist) `
>
> 其中somelist是要转换的列表。这到底是什么意思呢？3.4.3节对此做了说明。

### 2.3.2 基本的列表操作

可对列表执行所有的标准序列操作，如索引、切片、拼接和相乘，但列表的有趣之处在于它是可以修改的。本节将介绍一些修改列表的方式：给元素赋值、删除元素、给切片赋值以及使用列表的方法。（请注意，并非所有列表方法都会修改列表。）

#### 1. 修改列表：给元素赋值

修改列表很容易，只需使用第1章介绍的普通赋值语句即可，但不是使用类似于x = 2这样的赋值语句，而是使用索引表示法给特定位置的元素赋值，如x[1] = 2。

~~~python
>>> x = [1, 1, 1] 
>>> x[1] = 2 
>>> x 
[1, 2, 1]
~~~

> **注意** 不能给不存在的元素赋值，因此如果列表的长度为2，就不能给索引为100的元素赋值。要这样做，列表的长度至少为101。请参阅本章前面的“None、空列表和初始化”一节。

#### 2. 删除元素

从列表中删除元素也很容易，只需使用del语句即可。

~~~python
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl'] 
>>> del names[2] 
>>> names 
['Alice', 'Beth', 'Dee-Dee', 'Earl']
~~~

注意到Cecil彻底消失了，而列表的长度也从5变成了4。除用于删除列表元素外，del语句还可用于删除其他东西。你可将其用于字典（参见第4章）乃至变量，有关这方面的详细信息，请参阅第5章。

#### 3. 给切片赋值

切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。

~~~python
>>> name = list('Perl') 
>>> name 
['P', 'e', 'r', 'l'] 
>>> name[2:] = list('ar') 
>>> name 
['P', 'e', 'a', 'r']
~~~

从上述代码可知，可同时给多个元素赋值。你可能认为，这有什么大不了的，分别给每个元素赋值不是一样的吗？确实如此，但通过使用切片赋值，可将切片替换为长度与其不同的序列。

~~~python
>>> name = list('Perl') 
>>> name[1:] = list('ython') 
>>> name 
['P', 'y', 't', 'h', 'o', 'n']
~~~

使用切片赋值还可在不替换原有元素的情况下插入新元素。

~~~python
>>> numbers = [1, 5] 
>>> numbers[1:1] = [2, 3, 4] 
>>> numbers 
[1, 2, 3, 4, 5]
~~~

在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除切片。

~~~python
>>> numbers 
[1, 2, 3, 4, 5] 
>>> numbers[1:4] = [] 
>>> numbers 
[1, 5]
~~~

你可能猜到了，上述代码与del numbers[1:4]等效。现在，你可自己尝试执行步长不为1（乃至为负）的切片赋值了。

### 2.3.3 列表方法

方法是与对象（列表、数、字符串等）联系紧密的函数。通常，像下面这样调用方法：

`object.method(arguments)`

方法调用与函数调用很像，只是在方法名前加上了对象和句点（第7章将详细阐述方法到底是什么）。列表包含多个可用来查看或修改其内容的方法。

#### 1. append

方法append用于将一个对象附加到列表末尾。

~~~python
>>> lst = [1, 2, 3] 
>>> lst.append(4) 
>>> lst 
[1, 2, 3, 4]
~~~

你可能心存疑虑，为何给列表取lst这样糟糕的名字，而不称之为list呢？我原本是可以这样做的，但你可能还记得，list是一个内置函数(实际上，从Python 2.2起，list就是类型，而不是函数了（tuple和str亦如此）。有关这方面的完整说明，请参阅9.3.2节。)，如果我将前述列表命名为list，就无法调用这个函数。在特定的应用程序中，通常可给列表选择更好的名称。诸如lst等名称确实不能提供任何信息。因此，如果列表为价格列表，可能应该将其命名为prices、prices_of_eggs或pricesOfEggs。

另外请注意，与其他几个类似的方法一样，append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表。这通常正是你想要的，但有时会带来麻烦。我将在本章后面介绍sort时再回过头来讨论这一点。

#### 2. clear

方法clear就地清空列表的内容。

~~~python
>>> lst = [1, 2, 3] 
>>> lst.clear() 
>>> lst 
[]
~~~

这类似于切片赋值语句lst[:] = []。

#### 3. copy

方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。

~~~python
>>> a = [1, 2, 3] 
>>> b = a 
>>> b[1] = 4 
>>> a 
[1, 4, 3]
~~~

要让a和b指向不同的列表，就必须将b关联到a的副本。

~~~python
>>> a = [1, 2, 3] 
>>> b = a.copy() 
>>> b[1] = 4 
>>> a 
[1, 2, 3]
~~~

这类似于使用a[:]或list(a)，它们也都复制a。

#### 4. count

方法count计算指定的元素在列表中出现了多少次。

~~~python
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to') 
2 
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]] 
>>> x.count(1) 
2 
>>> x.count([1, 2]) 
1
~~~

#### 5. extend

方法extend让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提供给方法extend。换而言之，你可使用一个列表来扩展另一个列表。

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a.extend(b) 
>>> a 
[1, 2, 3, 4, 5, 6]
~~~

这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列（这里是a）。在常规拼接中，情况是返回一个全新的序列。

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a + b 
[1, 2, 3, 4, 5, 6] 
>>> a 
[1, 2, 3]
~~~

如你所见，拼接出来的列表与前一个示例扩展得到的列表完全相同，但在这里a并没有被修改。鉴于常规拼接必须使用a和b的副本创建一个新列表，因此如果你要获得类似于下面的效果，拼接的效率将比extend低：

~~~python
>>> a = a + b
~~~

另外，拼接操作并非就地执行的，即它不会修改原来的列表。要获得与extend相同的效果，可将列表赋给切片，如下所示：

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a[len(a):] = b 
>>> a 
[1, 2, 3, 4, 5, 6]
~~~

这虽然可行，但可读性不是很高。

#### 6. index

方法index在列表中查找指定值第一次出现的索引。

~~~python
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni'] 
>>> knights.index('who') 
4 
>>> knights.index('herring') 
Traceback (innermost last): 
 File "<pyshell>", line 1, in ? 
 knights.index('herring') 
ValueError: list.index(x): x not in list
~~~

搜索单词'who'时，发现它位于索引4处。

然而，搜索'herring'时引发了异常，因为根本就没有找到这个单词。

#### 7. insert

方法insert用于将一个对象插入列表。

~~~python
>>> numbers = [1, 2, 3, 5, 6, 7] 
>>> numbers.insert(3, 'four') 
>>> numbers 
[1, 2, 3, 'four', 5, 6, 7]
~~~

与extend一样，也可使用切片赋值来获得与insert一样的效果。

~~~python
>>> numbers = [1, 2, 3, 5, 6, 7] 
>>> numbers[3:3] = ['four'] 
>>> numbers 
[1, 2, 3, 'four', 5, 6, 7]
~~~

这虽巧妙，但可读性根本无法与使用insert媲美。

#### 8. pop

方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。

~~~python
>>> x = [1, 2, 3] 
>>> x.pop() 
3 
>>> x 
[1, 2] 
>>> x.pop(0) 
1 
>>> x 
[2]
~~~

> **注意** pop是唯一既修改列表又返回一个非None值的列表方法。

使用pop可实现一种常见的数据结构——**栈**（stack）。栈就像一叠盘子，你可在上面添加盘子，还可从上面取走盘子。最后加入的盘子最先取走，这被为**后进先出**（LIFO）

push和pop是大家普遍接受的两种栈操作（加入和取走）的名称。Python没有提供push，但可使用append来替代。方法pop和append的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同。

~~~python
>>> x = [1, 2, 3] 
>>> x.append(x.pop()) 
>>> x 
[1, 2, 3]
~~~

>**提示** 要创建先进先出（FIFO）的队列，可使用insert(0, ...)代替append。另外，也可继续使用append，但用pop(0)替代pop()。一种更佳的解决方案是，使用模块collections中的deque。有关这方面的详细信息，请参阅第10章。

#### 9. remove

方法remove用于删除第一个为指定值的元素。

~~~python
>>> x = ['to', 'be', 'or', 'not', 'to', 'be'] 
>>> x.remove('be') 
>>> x 
['to', 'or', 'not', 'to', 'be'] 
>>> x.remove('bee') 
Traceback (innermost last): 
 File "<pyshell>", line 1, in ? 
 x.remove('bee') 
ValueError: list.remove(x): x not in list
~~~

如你所见，这只删除了为指定值的第一个元素，无法删除列表中其他为指定值的元素（这里是字符串'bee'）。

请注意，remove是就地修改且不返回值的方法之一。不同于pop的是，它修改列表，但不返回任何值。

#### 10. reverse

方法reverse按相反的顺序排列列表中的元素（我想你对此应该不会感到惊讶）。

~~~python
>>> x = [1, 2, 3] 
>>> x.reverse() 
>>> x 
[3, 2, 1]
~~~

注意到reverse修改列表，但不返回任何值（与remove和sort等方法一样）。

> **提示** 如果要按相反的顺序迭代序列，可使用函数reversed。这个函数不返回列表，而是返回一个迭代器（迭代器将在第9章详细介绍）。你可使用list将返回的对象转换为列表。
>
> ~~~python
> >>> x = [1, 2, 3] 
> >>> list(reversed(x)) 
> [3, 2, 1] 
> ~~~

#### 11. sort

方法sort用于对列表就地排序(多说一句，从Python 2.3起，方法sort使用的是稳定的排序算法)。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> x.sort() 
>>> x 
[1, 2, 4, 6, 7, 9]
~~~

前面介绍了多个修改列表而不返回任何值的方法，在大多数情况下，这种行为都相当自然（例如，对append来说就如此）。需要强调sort的行为也是这样的，因为这种行为给很多人都带来了困惑。在需要排序后的列表副本并保留原始列表不变时，通常会遭遇这种困惑。为实现这种目标，一种直观（但错误）的方式是像下面这样做：

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = x.sort() # Don't do this! 
>>> print(y) 
None
~~~

鉴于sort修改x且不返回任何值，最终的结果是x是经过排序的，而y包含None。为实现前述目标，正确的方式之一是先将y关联到x的副本，再对y进行排序，如下所示:

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = x.copy() 
>>> y.sort() 
>>> x 
[4, 6, 2, 1, 7, 9] 
>>> y 
[1, 2, 4, 6, 7, 9]
~~~

只是将x赋给y是不可行的，因为这样x和y将指向同一个列表。为获取排序后的列表的副本，另一种方式是使用函数sorted。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = sorted(x) 
>>> x 
[4, 6, 2, 1, 7, 9] 
>>> y 
[1, 2, 4, 6, 7, 9]
~~~

实际上，这个函数可用于任何序列，但总是返回一个列表(实际上，函数sorted可用于任何可迭代的对象。可迭代的对象将在第9章详细介绍)。

~~~python
>>> sorted('Python') 
['P', 'h', 'n', 'o', 't', 'y']
~~~

如果要将元素按相反的顺序排列，可先使用sort（或sorted），再调用方法reverse，也可使用参数reverse，这将在下一小节介绍。

#### 12. 高级排序

方法sort接受两个可选参数：key和reverse。这两个参数通常是按名称指定的，称为关键字参数，将在第6章详细讨论。参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数key设置为函数len。

~~~python
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] 
>>> x.sort(key=len) 
>>> x 
['add', 'acme', 'aerate', 'abalone', 'aardvark']
~~~

对于另一个关键字参数reverse，只需将其指定为一个真值（True或False，将在第5章详细介绍），以指出是否要按相反的顺序对列表进行排序。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> x.sort(reverse=True) 
>>> x 
[9, 7, 6, 4, 2, 1]
~~~

函数sorted也接受参数key和reverse。在很多情况下，将参数key设置为一个自定义函数很有用。第6章将介绍如何创建自定义函数。

## 2.4 元组：不可修改的序列

与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串也不能修改）。元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组。

~~~python
>>> 1, 2, 3 
(1, 2, 3)
~~~

如你所见，元组还可用圆括号括起（这也是通常采用的做法）。

~~~python
>>> (1, 2, 3) 
(1, 2, 3)
~~~

空元组用两个不包含任何内容的圆括号表示。

~~~python
>>> () 
()
~~~

你可能会问，如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它后面加上逗号。

~~~python
>>> 42 
42 
>>> 42, 
(42,)
>>> (42,) 
(42,)
~~~

最后两个示例创建的元组长度为1，而第一个示例根本没有创建元组。逗号至关重要，仅将值用圆括号括起不管用：(42)与42完全等效。但仅仅加上一个逗号，就能完全改变表达式的值。

~~~python
>>> 3 * (40 + 2) 
126 
>>> 3 * (40 + 2,) 
(42, 42, 42)
~~~

函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组（与list一样，tuple实际上也不是函数，而是类型。而且同样，目前你完全可以不考虑这一点）。如果参数已经是元组，就原封不动地返回它。

~~~python
>>> tuple([1, 2, 3]) 
(1, 2, 3) 
>>> tuple('abc') 
('a', 'b', 'c') 
>>> tuple((1, 2, 3)) 
(1, 2, 3)
~~~

你可能意识到了，元组并不太复杂，而且除创建和访问其元素外，可对元组执行的操作不多。元组的创建及其元素的访问方式与其他序列相同。

~~~python
>>> x = 1, 2, 3 
>>> x[1] 
2 
>>> x[0:2] 
(1, 2)
~~~

元组的切片也是元组，就像列表的切片也是列表一样。为何要熟悉元组呢？原因有以下两个。

- 它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。
- 有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count等方法时例外）。

一般而言，使用列表足以满足对序列的需求。

# 第3章 使用字符串

## 3.1 字符串基本操作

前一章说过，所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的。

## 3.2 设置字符串的格式：精简版

如果你是Python编程新手，可能不会用到所有的Python字符串格式设置选项，因此这里介绍精简版。如果你想了解详情，请参阅接下来的3.3节，否则只需阅读本节，再直接跳到3.4节。

将值转换为字符串并设置其格式是一个重要的操作，需要考虑众多不同的需求，因此随着时间的流逝，Python提供了多种字符串格式设置方法。以前，主要的解决方案是使用字符串格式设置运算符——百分号。这个运算符的行为类似于C语言中的经典函数printf：在%左边指定一个字符串（格式字符串），并在右边指定要设置其格式的值。指定要设置其格式的值时，可使用单个值（如字符串或数字），可使用元组（如果要设置多个值的格式），还可使用字典（这将在下一章讨论），其中最常见的是元组。

~~~python
>>> format = "Hello, %s. %s enough for ya?"
>>> values = ('world', 'Hot') 
>>> format % values
'Hello, world. Hot enough for ya?'
~~~

上述格式字符串中的%s称为**转换说明符**，指出了要将值插入什么地方。s意味着将值视为字符串进行格式设置。如果指定的值不是字符串，将使用str将其转换为字符串。其他说明符将导致其他形式的转换。例如，%.3f将值的格式设置为包含3位小数的浮点数。

这种格式设置方法现在依然管用，且依然活跃在众多代码中，因此你很可能遇到。可能遇到的另一种解决方案是所谓的模板字符串。它使用类似于UNIX shell的语法，旨在简化基本的格式设置机制，如下所示：

~~~python
>>> from string import Template 
>>> tmpl = Template("Hello, $who! $what enough for ya?") 
>>> tmpl.substitute(who="Mars", what="Dusty") 
'Hello, Mars! Dusty enough for ya?'
~~~

包含等号的参数称为关键字参数，第6章将详细介绍这个术语。在字符串格式设置中，可将关键字参数视为一种向命名替换字段提供值的方式。

编写新代码时，应选择使用字符串方法format，它融合并强化了早期方法的优点。使用这种方法时，每个替换字段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息。

在最简单的情况下，替换字段没有名称或将索引用作名称。

~~~python
>>> "{}, {} and {}".format("first", "second", "third") 
'first, second and third' 
>>> "{0}, {1} and {2}".format("first", "second", "third") 
'first, second and third'
~~~

然而，索引无需像上面这样按顺序排列。

~~~python
>>> "{3} {0} {2} {1} {3} {0}".format("be", "not", "or", "to") 
'to be or not to be'
~~~

命名字段的工作原理与你预期的完全相同。

~~~python
>>> from math import pi 
>>> "{name} is approximately {value:.2f}.".format(value=pi, name="π") 
'π is approximately 3.14.'
~~~

当然，关键字参数的排列顺序无关紧要。在这里，我还指定了格式说明符.2f，并使用冒号将其与字段名隔开。它意味着要使用包含2位小数的浮点数格式。如果没有指定.2f，结果将如下：

~~~python
>>> "{name} is approximately {value}.".format(value=pi, name="π") 
'π is approximately 3.141592653589793.'
~~~

最后，在Python 3.6中，如果变量与替换字段同名，还可使用一种简写。在这种情况下，可使用f字符串——在字符串前面加上f。

~~~python
>>> from math import e 
>>> f"Euler's constant is roughly {e}." 
"Euler's constant is roughly 2.718281828459045."
~~~

在这里，创建最终的字符串时，将把替换字段e替换为变量e的值。这与下面这个更明确一些的表达式等价：

~~~python
>>> "Euler's constant is roughly {e}.".format(e=e) 
"Euler's constant is roughly 2.718281828459045."
~~~

## 3.3 设置字符串的格式：完整版

字符串格式设置涉及的内容很多，因此即便是这里的完整版也无法全面探索所有的细节，而只是介绍主要的组成部分。这里的基本思想是对字符串调用方法format，并提供要设置其格式的值。字符串包含有关如何设置格式的信息，而这些信息是使用一种微型格式指定语言（mini-language）指定的。每个值都被插入字符串中，以替换用花括号括起的替换字段。要在最终结果中包含花括号，可在格式字符串中使用两个花括号（即{{或}}）来指定。

~~~python
>>> "{{ceci n'est pas une replacement field}}".format() 
"{ceci n'est pas une replacement field}"
~~~

在格式字符串中，最激动人心的部分为替换字段。替换字段由如下部分组成，其中每个部分都是可选的。

- **字段名**：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段。除指定值外，还可指定值的特定部分，如列表的元素。

- **转换标志**：跟在叹号后面的单个字符。当前支持的字符包括r（表示repr）、s（表示str） 和a（表示ascii）。如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转换为字符串，再做进一步的格式设置。

- **格式说明符**：跟在冒号后面的表达式（这种表达式是使用微型格式指定语言表示的）。格式说明符让我们能够详细地指定最终的格式，包括格式类型（如字符串、浮点数或十六进制数），字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式。

下面详细介绍其中的一些要素。

### 3.3.1 替换字段名

在最简单的情况下，只需向format提供要设置其格式的未命名参数，并在格式字符串中使用未命名字段。此时，将按顺序将字段和参数配对。你还可给参数指定名称，这种参数将被用于相应的替换字段中。你可混合使用这两种方法。

~~~python
>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3) 
'3 1 4 2'
~~~

还可通过索引来指定要在哪个字段中使用相应的未命名参数，这样可不按顺序使用未命名参数。

~~~python
>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3) 
'3 2 4 1'
~~~

然而，不能同时使用手工编号和自动编号，因为这样很快会变得混乱不堪。

你并非只能使用提供的值本身，而是可访问其组成部分（就像在常规Python代码中一样），如下所示：

~~~python
>>> fullname = ["Alfred", "Smoketoomuch"] 
>>> "Mr {name[1]}".format(name=fullname) 
'Mr Smoketoomuch' 
>>> import math 
>>> tmpl = "The {mod.__name__} module defines the value {mod.pi} for π" 
>>> tmpl.format(mod=math) 
'The math module defines the value 3.141592653589793 for π'
~~~

如你所见，可使用索引，还可使用句点表示法来访问导入的模块中的方法、属性、变量和函数（看起来很怪异的变量`__name__`包含指定模块的名称）。

### 3.3.2 基本转换

指定要在字段中包含的值后，就可添加有关如何设置其格式的指令了。首先，可以提供一个**转换标志**。

~~~python
>>> print("{pi!s} {pi!r} {pi!a}".format(pi="π")) 
π 'π' '\u03c0'
~~~

上述三个标志（s、r和a）指定分别使用str、repr和ascii进行转换。函数str通常创建外观普通的字符串版本（这里没有对输入字符串做任何处理）。函数repr尝试创建给定值的Python表示（这里是一个字符串字面量）。函数ascii创建只包含ASCII字符的表示，类似于Python 2中的repr。

你还可指定要转换的值是哪种类型，更准确地说，是要将其视为哪种类型。例如，你可能提供一个整数，但将其作为小数进行处理。为此可在格式说明（即冒号后面）使用字符f（表示定点数）。

~~~python
>>> "The number is {num}".format(num=42) 
'The number is 42' 
>>> "The number is {num:f}".format(num=42) 
'The number is 42.000000'
~~~

你也可以将其作为二进制数进行处理。

~~~python
>>> "The number is {num:b}".format(num=42) 
'The number is 101010'
~~~

这样的类型说明符有多个，完整的清单见表3-1。

表3-1 字符串格式设置中的类型说明符

| 类型 | 含 义                                                        |
| ---- | ------------------------------------------------------------ |
| b    | 将整数表示为二进制数                                         |
| c    | 将整数解读为Unicode码点                                      |
| d    | 将整数视为十进制数进行处理，这是整数默认使用的说明符         |
| e    | 使用科学表示法来表示小数（用e来表示指数）                    |
| E    | 与e相同，但使用E来表示指数                                   |
| f    | 将小数表示为定点数                                           |
| F    | 与f相同，但对于特殊值（nan和inf），使用大写表示              |
| g    | 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数 |
| G    | 与g相同，但使用大写来表示指数和特殊值                        |
| n    | 与g相同，但插入随区域而异的数字分隔符                        |
| o    | 将整数表示为八进制数                                         |
| s    | 保持字符串的格式不变，这是默认用于字符串的说明符             |
| x    | 将整数表示为十六进制数并使用小写字母                         |
| X    | 与x相同，但使用大写字母                                      |
| %    | 将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%） |

### 3.3.3 宽度、精度和千位分隔符

设置浮点数（或其他更具体的小数类型）的格式时，默认在小数点后面显示6位小数，并根据需要设置字段的宽度，而不进行任何形式的填充。当然，这种默认设置可能不是你想要的，在这种情况下，可根据需要在格式说明中指定宽度和精度。

宽度是使用整数指定的，如下所示：

~~~python
>>> "{num:10}".format(num=3) 
'         3' 
>>> "{name:10}".format(name="Bob") 
'Bob    '
~~~

如你所见，数和字符串的对齐方式不同。对齐将在下一节介绍。

精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点。

~~~python
>>> "Pi day is {pi:.2f}".format(pi=pi) 
'Pi day is 3.14'
~~~

这里显式地指定了类型f，因为默认的精度处理方式稍有不同（相关的规则请参阅“Python库参考手册”）。当然，可同时指定宽度和精度。

~~~python
>>> "{pi:10.2f}".format(pi=pi) 
'      3.14'
~~~

实际上，对于其他类型也可指定精度，但是这样做的情形不太常见。

~~~python
>>> "{:.5}".format("Guido van Rossum") 
'Guido'
~~~

最后，可使用逗号来指出你要添加**千位分隔符**。

~~~python
>>> 'One googol is {:,}'.format(10**100) 
'One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000'
~~~

同时指定其他格式设置元素时，这个逗号应放在宽度和表示精度的句点之间(如果要使用随区域而异的千位分隔符，应使用类型说明符n)。

### 3.3.4 符号、对齐和用 0 填充

有很多用于设置数字格式的机制，比如便于打印整齐的表格。在大多数情况下，只需指定宽度和精度，但包含负数后，原本漂亮的输出可能不再漂亮。另外，正如你已看到的，字符串和数的默认对齐方式不同。在一栏中同时包含字符串和数时，你可能想修改默认对齐方式。在指定宽度和精度的数前面，可添加一个标志。这个标志可以是零、加号、减号或空格，其中零表示使用0来填充数字。

~~~python
>>> '{:010.2f}'.format(pi) 
'0000003.14'
~~~

要指定左对齐、右对齐和居中，可分别使用<、>和^。

~~~python
>>> print('{0:<10.2f}\n{0:^10.2f}\n{0:>10.2f}'.format(pi)) 
3.14       
   3.14   
      3.14
~~~

可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充。

~~~python
>>> "{:$^15}".format(" WIN BIG ") 
'$$$ WIN BIG $$$'
~~~

还有更具体的说明符=，它指定将填充字符放在符号和数字之间。

~~~python
>>> print('{0:10.2f}\n{1:10.2f}'.format(pi, -pi)) 
      3.14 
     -3.14 
>>> print('{0:10.2f}\n{1:=10.2f}'.format(pi, -pi)) 
      3.14 
-     3.14
~~~

如果要给正数加上符号，可使用说明符+（将其放在对齐说明符后面），而不是默认的-。如果将符号说明符指定为空格，会在正数前面加上空格而不是+。

~~~python
>>> print('{0:-.2}\n{1:-.2}'.format(pi, -pi)) #默认设置
3.1 
-3.1 
>>> print('{0:+.2}\n{1:+.2}'.format(pi, -pi)) 
+3.1 
-3.1 
>>> print('{0: .2}\n{1: .2}'.format(pi, -pi)) 
 3.1 
-3.1
~~~

需要介绍的最后一个要素是井号（#）选项，你可将其放在符号说明符和宽度之间（如果指定了这两种设置）。这个选项将触发另一种转换方式，转换细节随类型而异。例如，对于二进制、八进制和十六进制转换，将加上一个前缀。

~~~python
>>> "{:b}".format(42) 
'101010' 
>>> "{:#b}".format(42) 
'0b101010'
~~~

对于各种十进制数，它要求必须包含小数点（对于类型g，它保留小数点后面的零）。

~~~python
>>> "{:g}".format(42) 
'42' 
>>> "{:#g}".format(42) 
'42.0000'
~~~

## 3.4 字符串方法

前面介绍了列表的方法，而字符串的方法要多得多，因为其很多方法都是从模块string那里“继承”而来的。（在较早的Python版本中，这些方法为模块string中的函数。如果需要，现在依然能够找到这些函数。）

字符串的方法太多了，这里只介绍一些最有用的。完整的字符串方法清单请参阅附录B。这里描述字符串的方法时，将列出其他相关的方法。如果这些相关方法在本章做了介绍，将用“另请参见”标识，否则用“附录B”标识。

> 模块**string**未死
>
> 虽然字符串方法完全盖住了模块string的风头，但这个模块包含一些字符串没有的常量
>
> 和函数。下面就是模块string中几个很有用的常量①。 
>
> - string.digits：包含数字0～9的字符串。
> - string.ascii_letters：包含所有ASCII字母（大写和小写）的字符串。
> - string.ascii_lowercase：包含所有小写ASCII字母的字符串。
> - string.printable：包含所有可打印的ASCII字符的字符串。
> - string.punctuation：包含所有ASCII标点字符的字符串。
> - string.ascii_uppercase：包含所有大写ASCII字母的字符串。
>
> 虽然说的是ASCII字符，但值实际上是未解码的Unicode字符串

### 3.4.1 center

方法center通过在两边添加填充字符（默认为空格）让字符串居中。

~~~python
>>> "The Middle by Jimmy Eat World".center(39) 
' The Middle by Jimmy Eat World ' 
>>> "The Middle by Jimmy Eat World".center(39, "*") 
'*****The Middle by Jimmy Eat World*****'
~~~

附录B：ljust、rjust和zfill。

### 3.4.2 find

方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。

~~~python
>>> 'With a moo-moo here, and a moo-moo there'.find('moo') 
7 
>>> title = "Monty Python's Flying Circus" 
>>> title.find('Monty') 
0 
>>> title.find('Python')
6 
>>> title.find('Flying') 
15 
>>> title.find('Zirquss') 
-1
~~~

第2章初识成员资格时，我们在垃圾邮件过滤器中检查主题是否包含'$$$'。这种检查也可使用find来执行。（在Python 2.3之前的版本中，这种做法也管用，但in只能用于检查单个字符是否包含在字符串中。）

~~~python
>>> subject = '$$$ Get rich now!!! $$$' 
>>> subject.find('$$$') 
0
~~~

> **注意** 字符串方法find返回的**并非**布尔值。如果find像这样返回0，就意味着它在索引0处找到了指定的子串。

你还可指定搜索的起点和终点（它们都是可选的）。

~~~python
>>> subject = '$$$ Get rich now!!! $$$' 
>>> subject.find('$$$') 
0 
>>> subject.find('$$$', 1) # 只指定了起点
20 
>>> subject.find('!!!') 
16 
>>> subject.find('!!!', 0, 16) # 同时指定了起点和终点
-1
~~~

请注意，起点和终点值（第二个和第三个参数）指定的搜索范围包含起点，但不包含终点。这是Python惯常的做法。

附录B：rfind、index、rindex、count、startswith、endswith。

### 3.4.3 join

join是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素。

~~~python
>>> seq = [1, 2, 3, 4, 5] 
>>> sep = '+' 
>>> sep.join(seq) # 尝试合并一个数字列表
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
TypeError: sequence item 0: expected string, int found 
>>> seq = ['1', '2', '3', '4', '5'] 
>>> sep.join(seq) # 合并一个字符串列表
'1+2+3+4+5' 
>>> dirs = '', 'usr', 'bin', 'env' 
>>> '/'.join(dirs) 
'/usr/bin/env' 
>>> print('C:' + '\\'.join(dirs)) 
C:\usr\bin\env
~~~

如你所见，所合并序列的元素必须都是字符串。注意到在最后两个示例中，我使用了一系列目录，并按UNIX和DOS/Windows的约定设置其格式：通过使用不同的分隔符（并在DOS版本中添加了盘符）。

另请参见：split。

### 3.4.4 lower

方法lower返回字符串的小写版本。

~~~python
>>> 'Trondheim Hammer Dance'.lower() 
'trondheim hammer dance'
~~~

在你编写代码时，如果不想区分字符串的大小写（即忽略大小写的差别），这将很有用。例如，假设你要检查列表中是否包含指定的用户名。如果列表包含字符串'gumby'，而指定的用户名为'Gumby'，你将找不到它。

当然，如果列表包含'Gumby'，而指定的用户名为'gumby'或'GUMBY'，结果同样找不到。对于这种问题，一种解决方案是在存储和搜索时，将所有的用户名都转换为小写。

另请参见：islower、istitle、isupper、translate。

附录B：capitalize、casefold、swapcase、title、upper。

> **词首大写**
>
> 一个与lower相关的方法是title（参见附录B）。它将字符串转换为词首大写，即所有单词的首字母都大写，其他字母都小写。然而，它确定单词边界的方式可能导致结果不合理。
>
> ~~~python
> >>> "that's all folks".title() 
> "That'S All, Folks"
> ~~~
>
> 另一种方法是使用模块string中的函数capwords。
>
> ~~~python
> >>> import string 
> >>> string.capwords("that's all, folks") 
> That's All, Folks"
> ~~~
>
> 当然，要实现真正的词首大写（根据你采用的写作风格，冠词、并列连词以及不超过5个字母的介词等可能全部小写），你得自己编写代码。

### 3.4.5 replace

方法replace将指定子串都替换为另一个字符串，并返回替换后的结果。

~~~python
>>> 'This is a test'.replace('is', 'eez') 
'Theez eez a test'
~~~

如果你使用过字处理程序的“查找并替换”功能，一定知道这个方法很有用。

另请参见：translate。

附录B：expandtabs。

### 3.4.6 split

split是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。

~~~python
>>> '1+2+3+4+5'.split('+') 
['1', '2', '3', '4', '5'] 
>>> '/usr/bin/env'.split('/') 
['', 'usr', 'bin', 'env'] 
>>> 'Using the default'.split() 
['Using', 'the', 'default']
~~~

注意，如果没有指定分隔符，将默认在单个或多个连续的空白字符（空格、制表符、换行符等）处进行拆分。

另请参见：join。

附录B：partition、rpartition、rsplit、splitlines。

### 3.4.7 strip

方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。

~~~python
>>> ' internal whitespace is kept '.strip() 
'internal whitespace is kept'
~~~

你还可在一个字符串参数中指定要删除哪些字符。

~~~python
>>> '*** SPAM * for * everyone!!! ***'.strip(' *!') 
'SPAM * for * everyone'
~~~

这个方法只删除开头或末尾的指定字符，因此中间的星号未被删除。

附录B：lstrip、rstrip。

### 3.4.8 translate

方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。这个方法的优势在于能够同时替换多个字符，因此效率比replace高。

这个方法的用途很多（如替换换行符或其他随平台而异的特殊字符），但这里只介绍一个比较简单（也有点傻）的示例。假设你要将一段英语文本转换为带有德国口音的版本，为此必须将字符c和s分别替换为k和z。

然而，使用translate前必须创建一个转换表。这个转换表指出了不同Unicode码点之间的转换关系。要创建转换表，可对字符串类型str调用方法maketrans，这个方法接受两个参数：两个长度相同的字符串，它们指定要将第一个字符串中的每个字符都替换为第二个字符串中的相应字符(也可传入下一章将介绍的字典，将一些字符映射到其他字符（如果要删除这些字符，则映射到None）)。就这个简单的示例而言，代码类似于下面这样：

~~~python
>>> table = str.maketrans('cs', 'kz')
~~~

如果愿意，可查看转换表的内容，但你看到的只是Unicode码点之间的映射。

~~~python
>>> table 
{115: 122, 99: 107}
~~~

创建转换表后，就可将其用作方法translate的参数。

~~~python
>>> 'this is an incredible test'.translate(table) 
'thiz iz an inkredible tezt'
~~~

调用方法maketrans时，还可提供可选的第三个参数，指定要将哪些字母删除。例如，要模仿语速极快的德国口音，可将所有的空格都删除。

~~~python
>>> table = str.maketrans('cs', 'kz', ' ') 
>>> 'this is an incredible test'.translate(table) 
'thizizaninkredibletezt'
~~~

另请参见：replace、lower。

### 3.4.9 判断字符串是否满足特定的条件

很多字符串方法都以is打头，如isspace、isdigit和isupper，它们判断字符串是否具有特定的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回True，否则返回False。

附录B：isalnum、isalpha、isdecimal、isdigit、isidentifier、islower、isnumeric、isprintable、isspace、istitle、isupper。

# 第4章 当索引行不通时

需要将一系列值组合成数据结构并通过编号来访问各个值时，列表很有用。本章介绍一种可通过名称来访问其各个值的数据结构。这种数据结构称为**映射**（mapping）。字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。

## 4.1 字典的用途

字典的名称指出了这种数据结构的用途。普通图书适合按从头到尾的顺序阅读，如果你愿意，可快速翻到任何一页，这有点像Python中的列表。字典（日常生活中的字典和Python字典）旨在让你能够轻松地找到特定的单词（键），以获悉其定义（值）。

在很多情况下，使用字典都比使用列表更合适。下面是Python字典的一些用途：

- 表示棋盘的状态，其中每个键都是由坐标组成的元组；
- 存储文件修改时间，其中的键为文件名；
- 数字电话/地址簿。

## 4.2 创建和使用字典

字典以类似于下面的方式表示：

~~~python
phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
~~~

字典由键及其相应的值组成，这种键-值对称为项（item）。在前面的示例中，键为名字，而值为电话号码。每个键与其值之间都用冒号（:）分隔，项之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号表示，类似于下面这样：{}。

> **注意** 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。

### 4.2.1 函数 dict

可使用函数dict(与list、tuple和str一样，dict其实根本就不是函数，而是一个类)从其他映射（如其他字典）或键-值对序列创建字典。

~~~python
>>> items = [('name', 'Gumby'), ('age', 42)] 
>>> d = dict(items) 
>>> d 
{'age': 42, 'name': 'Gumby'} 
>>> d['name'] 
'Gumby'
~~~

还可使用关键字实参来调用这个函数，如下所示：

~~~python
>>> d = dict(name='Gumby', age=42) 
>>> d 
{'age': 42, 'name': 'Gumby'}
~~~

尽管这可能是函数dict最常见的用法，但也可使用一个映射实参来调用它，这将创建一个字典，其中包含指定映射中的所有项。像函数list、tuple和str一样，如果调用这个函数时没有提供任何实参，将返回一个空字典。从映射创建字典时，如果该映射也是字典（毕竟字典是Python中唯一的内置映射类型），可不使用函数dict，而是使用字典方法copy，这将在本章后面介绍。

### 4.2.2 基本的字典操作

字典的基本行为在很多方面都类似于序列。

- len(d)返回字典d包含的项（键-值对）数。
- d[k]返回与键k相关联的值。
- d[k] = v将值v关联到键k。 
- del d[k]删除键为k的项。
- k in d检查字典d是否包含键为k的项。

虽然字典和列表有多个相同之处，但也有一些重要的不同之处。

- **键的类型**：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组。
- **自动添加**：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。
- **成员资格**：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in l（其中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。

> **提示** 相比于检查列表是否包含指定的值，检查字典是否包含指定的键的效率更高。数据结构越大，效率差距就越大。

### 4.2.3 将字符串格式设置功能用于字典

第3章介绍过，可使用字符串格式设置功能来设置值的格式，这些值是作为命名或非命名参数提供给方法format的。在有些情况下，通过在字典中存储一系列命名的值，可让格式设置更容易些。例如，可在字典中包含各种信息，这样只需在格式字符串中提取所需的信息即可。为此，必须使用format_map来指出你将通过一个映射来提供所需的信息。

~~~python
>>> phonebook 
{'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'} 
>>> "Cecil's phone number is {Cecil}.".format_map(phonebook) 
"Cecil's phone number is 3258."
~~~

像这样使用字典时，可指定任意数量的转换说明符，条件是所有的字段名都是包含在字典中的键。

### 4.2.4 字典方法

#### 1. clear

方法clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不返回（或者说返回None）。

~~~python
>>> d = {} 
>>> d['name'] = 'Gumby' 
>>> d['age'] = 42 
>>> d 
{'age': 42, 'name': 'Gumby'} 
>>> returned_value = d.clear() 
>>> d 
{} 
>>> print(returned_value) 
None
~~~

#### 2. copy

方法copy返回一个新字典，其包含的键值对与原来的字典相同（这个方法执行的是浅复制，因为值本身是原件，而非副本）。

~~~python
>>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} 
>>> y = x.copy() 
>>> y['username'] = 'mlh' 
>>> y['machines'].remove('bar') 
>>> y 
{'username': 'mlh', 'machines': ['foo', 'baz']} 
>>> x 
{'username': 'admin', 'machines': ['foo', 'baz']}
~~~

如你所见，当替换副本中的值时，原件不受影响。然而，如果修改副本中的值（就地修改而不是替换），原件也将发生变化，因为原件指向的也是被修改的值（如这个示例中的'machines'列表所示）。

为避免这种问题，一种办法是执行深复制，即同时复制值及其包含的所有值，等等。为此，可使用模块copy中的函数deepcopy。

~~~python
>>> from copy import deepcopy 
>>> d = {} 
>>> d['names'] = ['Alfred', 'Bertrand'] 
>>> c = d.copy() 
>>> dc = deepcopy(d) 
>>> d['names'].append('Clive') 
>>> c 
{'names': ['Alfred', 'Bertrand', 'Clive']} 
>>> dc 
{'names': ['Alfred', 'Bertrand']}
~~~

#### 3. fromkeys

方法fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None。

~~~python
>>> {}.fromkeys(['name', 'age']) 
{'age': None, 'name': None}
~~~

这个示例首先创建了一个空字典，再对其调用方法fromkeys来创建另一个字典，这显得有点多余。你可以不这样做，而是直接对dict（前面说过，dict是所有字典所属的类型。类和类型将在第7章详细讨论）调用方法fromkeys。

~~~python
>>> dict.fromkeys(['name', 'age']) 
{'age': None, 'name': None}
~~~

如果你不想使用默认值None，可提供特定的值。

~~~python
>>> dict.fromkeys(['name', 'age'], '(unknown)') 
{'age': '(unknown)', 'name': '(unknown)'}
~~~

#### 4. get

方法get为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。

~~~python
>>> d = {} 
>>> print(d['name']) 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
KeyError: 'name'
~~~

而使用get不会这样：

~~~python
>>> print(d.get('name')) 
None
~~~

如你所见，使用get来访问不存在的键时，没有引发异常，而是返回None。你可指定“默认”值，这样将返回你指定的值而不是None。

~~~python
>>> d.get('name', 'N/A') 
'N/A'
~~~

如果字典包含指定的键，get的作用将与普通字典查找相同。

~~~python
>>> d['name'] = 'Eric' 
>>> d.get('name') 
'Eric'
~~~

#### 5. items

方法items返回一个包含所有字典项的列表，其中每个元素都为(key, value)的形式。字典项在列表中的排列顺序不确定。

~~~python
>>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0} 
>>> d.items() 
dict_items([('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')])
~~~

返回值属于一种名为**字典视图**的特殊类型。字典视图可用于迭代（迭代将在第5章详细介绍）。另外，你还可确定其长度以及对其执行成员资格检查。

~~~python
>>> it = d.items() 
>>> len(it) 
3 
>>> ('spam', 0) in it 
True
~~~

视图的一个优点是不复制，它们始终是底层字典的反映，即便你修改了底层字典亦如此。

~~~python
>>> d['spam'] = 1 
>>> ('spam', 0) in it 
False 
>>> d['spam'] = 0 
>>> ('spam', 0) in it 
True
~~~

然而，如果你要将字典项复制到列表中（在较旧的Python版本中，方法items就是这样做的），可自己动手做。

~~~python
>>> list(d.items()) 
[('spam', 0), ('title', 'Python Web Site'), ('url', 'http://www.python.org')]
~~~

#### 6. keys

方法keys返回一个字典视图，其中包含指定字典中的键。

#### 7. pop

方法pop可用于获取与指定键相关联的值，并将该键值对从字典中删除。

~~~python
>>> d = {'x': 1, 'y': 2} 
>>> d.pop('x') 
1 
>>> d 
{'y': 2}
~~~

#### 8. popitem

方法popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。

~~~python
>>> d = {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'} 
>>> d.popitem() 
('url', 'http://www.python.org') 
>>> d 
{'spam': 0, 'title': 'Python Web Site'}
~~~

虽然popitem类似于列表方法pop，但字典没有与append（它在列表末尾添加一个元素）对应的方法。这是因为字典是无序的，类似的方法毫无意义。

> **提示** 如果希望方法popitem以可预测的顺序弹出字典项，请参阅模块collections中的OrderedDict类。

#### 9. setdefault

方法setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。

~~~python
>>> d = {} 
>>> d.setdefault('name', 'N/A') 
'N/A' 
>>> d 
{'name': 'N/A'} 
>>> d['name'] = 'Gumby' 
>>> d.setdefault('name', 'N/A') 
'Gumby' 
>>> d 
{'name': 'Gumby'}
~~~

如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与get一样，值是可选的；如果没有指定，默认为None。

~~~python
>>> d = {} 
>>> print(d.setdefault('name')) 
None 
>>> d 
{'name': None}
~~~

> **提示** 如果希望有用于整个字典的全局默认值，请参阅模块collections中的defaultdict类。

#### 10. update

方法update使用一个字典中的项来更新另一个字典。

对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。

可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键值对组成的序列（或其他可迭代对象）或关键字参数。

#### 11. values

方法values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视图可能包含重复的值。

~~~python
>>> d = {} 
>>> d[1] = 1 
>>> d[2] = 2 
>>> d[3] = 3 
>>> d[4] = 1 
>>> d.values() 
dict_values([1, 2, 3, 1])
~~~

# 第5章 条件、循环及其他语句

## 5.1 再谈 print 和 import

随着你对Python的认识越来越深入，可能发现有些你自以为很熟悉的方面隐藏着让人惊喜的特性。下面就来看看print和import隐藏的几个特性。虽然print现在实际上是一个函数，但以前却是一种语句，因此在这里进行讨论。

> **提示** 对很多应用程序来说，使用模块logging来写入日志比使用print更合适，详情请参阅第19章。

### 5.1.1 打印多个参数

你知道，print可用于打印一个表达式，这个表达式要么是字符串，要么将自动转换为字符串。但实际上，你可同时打印多个表达式，条件是用逗号分隔它们：

~~~python
>>> print('Age:', 42) 
Age: 42
~~~

如你所见，在参数之间插入了一个空格字符。在你要合并文本和变量值，而又不想使用字符串格式设置功能时，这种行为很有帮助。

~~~python
>>> name = 'Gumby' 
>>> salutation = 'Mr.' 
>>> greeting = 'Hello,' 
>>> print(greeting, salutation, name) 
Hello, Mr. Gumby
~~~

如果字符串变量greeting不包含逗号，如何在结果中添加呢？你不能像下面这样做:

~~~python
print(greeting, ',', salutation, name)
~~~

因为这将在逗号前添加一个空格。下面是一种可行的解决方案：

~~~python
print(greeting + ',', salutation, name)
~~~

它将逗号和变量greeting相加。如果需要，可自定义分隔符：

~~~python
>>> print("I", "wish", "to", "register", "a", "complaint", sep="_") 
I_wish_to_register_a_complaint
~~~

你还可自定义结束字符串，以替换默认的换行符。例如，如果将结束字符串指定为空字符串，以后就可继续打印到当前行。

### 5.1.2 导入时重命名

从模块导入时，通常使用`import somemodule `

或使用`from somemodule import somefunction `

或`from somemodule import somefunction, anotherfunction, yetanotherfunction `

或`from somemodule import * `

仅当你确定要导入模块中的一切时，采用使用最后一种方式。但如果有两个模块，它们都包含函数open，该如何办呢？你可使用第一种方式导入这两个模块，并像下面这样调用函数：

~~~python
module1.open(...) 
module2.open(...)
~~~

但还有一种办法：在语句末尾添加as子句并指定别名。下面是一个导入整个模块并给它指定别名的例子：

~~~python
>>> import math as foobar 
>>> foobar.sqrt(4) 
2.0
~~~

下面是一个导入特定函数并给它指定别名的例子：

~~~python
>>> from math import sqrt as foobar 
>>> foobar(4) 
2.0
~~~

> **注意** 有些模块（如os.path）组成了层次结构（一个模块位于另一个模块中）。有关模块结构的详细信息，请参阅10.1.4节。

## 5.2 赋值魔法

### 5.2.1 序列解包

赋值语句你见过很多，有的给变量赋值，还有的给数据结构的一部分（如列表中的元素和切片，或者字典项）赋值，但还有其他类型的赋值语句。例如，可**同时**（并行）给多个变量赋值：

~~~python
>>> x, y, z = 1, 2, 3 
>>> print(x, y, z) 
1 2 3
~~~

看似用处不大？看好了，使用这种方式还可交换多个变量的值。

~~~python
>>> x, y = y, x 
>>> print(x, y, z) 
2 1 3
~~~

实际上，这里执行的操作称为**序列解包**（或**可迭代对象解包**）：将一个序列（或任何可迭代对象）解包，并将得到的值存储到一系列变量中。下面用例子进行解释。

~~~python
>>> values = 1, 2, 3 
>>> values 
(1, 2, 3) 
>>> x, y, z = values 
>>> x 
1
~~~

这在使用返回元组（或其他序列或可迭代对象）的函数或方法时很有用。假设要从字典中随便获取（或删除）一个键-值对，可使用方法popitem，它随便获取一个键-值对并以元组的方式返回。接下来，可直接将返回的元组解包到两个变量中。

~~~python
>>> scoundrel = {'name': 'Robin', 'girlfriend': 'Marion'} 
>>> key, value = scoundrel.popitem() 
>>> key 
'girlfriend' 
>>> value 
'Marion'
~~~

这让函数能够返回被打包成元组的多个值，然后通过一条赋值语句轻松地访问这些值。要解包的序列包含的元素个数必须与你在等号左边列出的目标个数相同，否则Python将引发异常。

可使用星号运算符（*）来收集多余的值，这样无需确保值和变量的个数相同，如下例所示：

~~~python
>>> a, b, *rest = [1, 2, 3, 4] 
>>> rest 
[3, 4]
~~~

还可将带星号的变量放在其他位置。

~~~python
>>> name = "Albus Percival Wulfric Brian Dumbledore" 
>>> first, *middle, last = name.split() 
>>> middle 
['Percival', 'Wulfric', 'Brian']
~~~

赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是一个列表。在变量和值的个数相同时亦如此。

~~~python
>>> a, *b, c = "abc" 
>>> a, b, c 
('a', ['b'], 'c')
~~~

这种收集方式也可用于函数参数列表中（参见第6章）。

### 5.2.2 链式赋值

链式赋值是一种快捷方式，用于将多个变量关联到同一个值。这有点像前一节介绍的并行赋值，但只涉及一个值：

~~~python
x = y = somefunction()
~~~

上述代码与下面的代码等价：

~~~python
y = somefunction() 
x = y
~~~

请注意，这两条语句可能与下面的语句不等价：

~~~python
x = somefunction() 
y = somefunction()
~~~

有关这方面的详细信息，请参阅5.4.6节介绍相同运算符（is）的部分。

### 5.2.3 增强赋值

可以不编写代码x = x + 1，而将右边表达式中的运算符（这里是+）移到赋值运算符（=）的前面，从而写成x += 1。这称为增强赋值，适用于所有标准运算符，如*、/、%等。

增强赋值也可用于其他数据类型（只要使用的双目运算符可用于这些数据类型）。

~~~python
>>> fnord = 'foo' 
>>> fnord += 'bar' 
>>> fnord *= 2 
>>> fnord 
'foobarfoobar'
~~~

通过使用增强赋值，可让代码更紧凑、更简洁，同时在很多情况下的可读性更强。

## 5.3 代码块：缩进的乐趣

代码块其实并不是一种语句，但要理解接下来两节的内容，你必须熟悉代码块。

代码块是一**组**语句，可在满足条件时执行（if语句），可执行多次（循环），等等。代码块是通过**缩进**代码（即在前面加空格）来创建的。

> **注意** 也可使用制表符来缩进代码块。Python将制表符解释为移到下一个制表位（相邻制表位相距8个空格），但标准（也是更佳的）做法是只使用空格（而不使用制表符）来缩进，且每级缩进4个空格。

在同一个代码块中，各行代码的缩进量必须相同。

在很多语言中，都使用一个特殊的单词或字符（如begin或{）来标识代码块的起始位置，并使用另一个特殊的单词或字符（如end或}）来标识结束位置。在Python中，使用冒号（:）指出接下来是一个代码块，并将该代码块中的每行代码都缩进相同的程度。发现缩进量与之前相同时，你就知道当前代码块到此结束了。（很多用于编程的编辑器和IDE知道如何缩进代码块，可帮助你轻松地正确缩进。）

## 5.4 条件和条件语句

### 5.4.1 这正是布尔值的用武之地

在本书前面，你多次遇到了**真值**，现在终于需要用到它们了。真值也称布尔值，是以在真值方面做出了巨大贡献的George Boole命名的。

> **注意** 如果你始终聚精会神，肯定注意到了第1章的旁注“先睹为快：if语句”，其中已经描述了if语句。然而，到目前为止，还没有正式介绍if语句。你将看到，有关if语句，还有很多我没有介绍的地方。

用作布尔表达式（如用作if语句中的条件）时，下面的值都将被解释器视为假：

`False` `None` `0` `""` `()` `[]` `{}` 

换而言之，标准值False和None、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假，而其他各种值都被视为真(至少对内置类型值来说如此。你在第9章将看到，对于自己创建的对象，解释为真还是假由你决定)，包括特殊值True。

明白了吗？这意味着任何Python值都可解释为真值。乍一看这有点令人迷惑，但也很有用。虽然可供选择的真值非常多，但标准真值为True和False。在有些语言（如C语言和2.3之前的Python版本）中，标准真值为0（表示假）和1（表示真）。实际上，True和False不过是0和1的别名，虽然看起来不同，但作用是相同的。

~~~python
>>> True 
True 
>>> False 
False 
>>> True == 1 
True 
>>> False == 0 
True 
>>> True + False + 42 
43
~~~

因此，如果你看到一个返回1或0的表达式（可能是使用较旧的Python版本编写的），就知道这实际上意味着True或False。

布尔值True和False属于类型bool，而bool与list、str和tuple一样，可用来转换其他的值。

~~~python
>>> bool('I think, therefore I am') 
True 
>>> bool(42) 
True 
>>> bool('') 
False 
>>> bool(0) 
False
~~~

鉴于任何值都可用作布尔值，因此你几乎不需要显式地进行转换（Python会自动转换）

> **注意** 虽然[]和""都为假（即bool([]) == bool("") == False），但它们并不相等（即[] != ""）。对其他各种为假的对象来说，情况亦如此（一个更显而易见的例子是() != False）。

### 5.4.2 有条件地执行和 if 语句

~~~python
name = input('What is your name? ') 
if name.endswith('Gumby'): 
	print('Hello, Mr. Gumby')
~~~

这就是if语句，让你能够有条件地执行代码。这意味着如果条件（if和冒号之间的表达式）为前面定义的真，就执行后续代码块（这里是一条print语句）；如果条件为假，就不执行（你应该猜到了）。

> **注意** 在第1章的旁注“先睹为快：if语句”中，将有条件执行的语句与if语句放在同一行中。这与前一个示例中使用单行代码块的做法等价。

### 5.4.3 else子句

在前一节的示例中，如果你输入以Gumby结尾的名字，方法name.endswith将返回True，导致后续代码块执行——打印问候语。如果你愿意，可使用else子句增加一种选择（之所以叫子句是因为else不是独立的语句，而是if语句的一部分）

~~~python
name = input('What is your name?') 
if name.endswith('Gumby'): 
	print('Hello, Mr. Gumby') 
else: 
	print('Hello, stranger')
~~~

还有一个与if语句很像的“亲戚”，它就是条件表达式——C语言中三目运算符的Python版本。下面的表达式使用if和else确定其值：

~~~python
status = "friend" if name.endswith("Gumby") else "stranger"
~~~

如果条件（紧跟在if后面）为真，表达式的结果为提供的第一个值（这里为"friend"），否则为第二个值（这里为"stranger"）。

### 5.4.4 elif子句

要检查多个条件，可使用elif。elif是else if的缩写，由一个if子句和一个else子句组合而成，也就是包含条件的else子句。

~~~python
num = int(input('Enter a number: ')) 
if num > 0: 
	print('The number is positive') 
elif num < 0: 
	print('The number is negative') 
else: 
	print('The number is zero')
~~~

### 5.4.5 代码块嵌套

### 5.4.6 更复杂的条件

#### 1. 比较运算符

| 表达式     | 描述                       |
| ---------- | -------------------------- |
| x == y     | x等于y                     |
| x < y      | x小于y                     |
| x > y      | x大于y                     |
| x >= y     | x大于或等于y               |
| x <= y     | x小于或等于y               |
| x != y     | x不等于y                   |
| x is y     | x和y是同一个对象           |
| x is not y | x和y是不同的对象           |
| x in y     | x是容器（如序列）y的成员   |
| x not in y | x不是容器（如序列）y的成员 |

> **对不兼容的类型进行比较**
>
> 从理论上说，可使用<和<=等运算符比较任意两个对象x和y的相对大小，并获得一个真值，但这种比较仅在x和y的类型相同或相近时（如两个整数或一个整数和一个浮点数）才有意义。
>
> 将整数与字符串相加毫无意义，检查一个整数是否小于一个字符串也是一样。奇怪的是，在Python 3之前，竟然可以这样做。不过即便你使用的是较旧的Python版本，也应对这类比较敬而远之，因为结果是不确定的，每次执行程序时都可能不同。在Python 3中，已经不允许这样比较不兼容的类型了。

与赋值一样，Python也支持链式比较：可同时使用多个比较运算符，如0 < age < 100。



**is：相同运算符**

> **警告** 不要将is用于数和字符串等不可变的基本值。鉴于Python在内部处理这些对象的方式，这样做的结果是不可预测的。



**字符串和序列的比较**

字符串是根据字符的字母排列顺序进行比较的。

~~~python
>>> "alpha" < "beta" 
True
~~~

实际上，字符是根据顺序值排列的。要获悉字母的顺序值，可使用函数ord。这个函数的作用与函数chr相反：

~~~python
>>> ord("【特殊emoji字符128585】") 
128585 
>>> ord("【特殊emoji字符128586】") 
128586 
>>> chr(128584) 
'【特殊emoji字符128584】'
~~~

这种方法既合理又一致，但可能与你排序的方式相反。例如，涉及大写字母时，排列顺序就可能与你想要的不同。

其他序列的比较方式与此相同，但这些序列包含的元素可能不是字符，而是其他类型的值。

~~~python
>>> [1, 2] < [2, 1] 
True
~~~

如果序列的元素为其他序列，将根据同样的规则对这些元素进行比较。

~~~python
>>> [2, [1, 4]] < [2, [1, 5]] 
True
~~~

#### 2. 布尔运算符

运算符and是一个布尔运算符。它接受两个真值，并在这两个值都为真时返回真，否则返回假。还有另外两个布尔运算符：or和not。通过使用这三个运算符，能以任何方式组合真值。

> **短路逻辑和条件表达式**
>
> 布尔运算符有个有趣的特征：只做必要的计算。例如，仅当x和y都为真时，表达式x and y才为真。因此如果x为假，这个表达式将立即返回假，而不关心y。实际上，如果x为假，这个表达式将返回x，否则返回y。（这将提供预期的结果，你明白了其中的原理吗？）这种行为称为**短路逻辑**（或者**延迟求值**）：布尔运算符常被称为逻辑运算符，如你所见，在有些情况下将“绕过”第二个值。对于运算符or，情况亦如此。在表达式x or y中，如果x为真，就返回x，否则返回y。（你明白这样做合理的原因吗？）请注意，这意味着位于布尔运算符后面的代码（如函数调用）可能根本不会执行。像下面这样的代码就利用了这种行为：
>
> ~~~python
> name = input('Please enter your name: ') or '<unknown>' 
> ~~~
>
> 如果没有输入名字，上述or表达式的结果将为'<unknown>'。在很多情况下，你都宁愿使用条件表达式，而不耍这样的短路花样。不过前面这样的语句确实有其用武之地。

### 5.4.7 断言

基本上，你可要求某些条件得到满足（如核实函数参数满足要求或为初始测试和调试提供帮助），为此可在语句中使用关键字assert。

~~~python
>>> age = 10 
>>> assert 0 < age < 100 
>>> age = -1 
>>> assert 0 < age < 100 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
AssertionError
~~~

如果知道必须满足特定条件，程序才能正确地运行，可在程序中添加assert语句充当检查点，这很有帮助。

还可在条件后面添加一个字符串，对断言做出说明。

~~~python
>>> age = -1 
>>> assert 0 < age < 100, 'The age must be realistic' 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
AssertionError: The age must be realistic
~~~

## 5.5 循环