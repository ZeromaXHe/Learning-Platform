# 第1章 快速上手：基础知识

## 1.3 数和表达式

所有常见算术运算符的工作原理都与你预期的一致。除法运算的结果为小数，即**浮点数**（float或floating-point number）。

~~~python
>>> 1 / 2
0.5
>>> 1 / 1
1.0
~~~

如果你想丢弃小数部分，即执行整除运算，可使用双斜杠。

~~~python
>>> 1 // 2
0
>>> 1 // 1
1
>>> 5.0 / 2.4
2.0
~~~

至此，你了解了基本的算术运算符（加法、减法、乘法和除法），但还有一种与整除关系紧密的运算没有介绍。

~~~python
>>> 1 % 2
1
~~~

这是求余（求模）运算符。x % y 的结果为x除以y的余数。换而言之，结果为执行整除时余下的部分，即x % y 等价于x - ((x // y) * y)。

~~~python
>>> 10 // 3 
3 
>>> 10 % 3
1 
>>> 9 // 3 
3 
>>> 9 % 3
0 
>>> 2.75 % 0.5
0.25
~~~

从最后一个示例可知，求余运算符也可用于浮点数。

这种运算符甚至可用于负数，但可能不那么好理解。

~~~python
>>> 10 % 3
1 
>>> 10 % -3
-2 
>>> -10 % 3
2 
>>> -10 % -3 
-1
~~~

你也许不能通过这些示例一眼看出求余运算的工作原理，但通过研究与之配套的整除运算可帮助理解。

~~~python
>>> 10 // 3 
3 
>>> 10 // -3 
-4 
>>> -10 // 3 
-4 
>>> -10 // -3 
3
~~~

基于除法运算的工作原理，很容易理解最终的余数是多少。对于整除运算，需要明白的一个重点是它向下圆整结果。因此在结果为负数的情况下，圆整后将离0更远。这意味着对于-10 // 3， 将**向下**圆整到-4，而不是**向上**圆整到-3。

这里要介绍的最后一个运算符是乘方（求幂）运算符。

~~~python
>>> 2 ** 3 
8 
>>> -3 ** 2
-9 
>>> (-3) ** 2 
9
~~~

请注意，乘方运算符的优先级比求负（单目减）高，因此`-3**2`等价于`-(3**2)`。如果你要计算的是`(-3)**2`，必须明确指出。

### 十六进制、八进制和二进制

结束本节前需要指出的是，十六进制数、八进制数和二进制数分别以下面的方式表示：

~~~python
>>> 0xAF 
175 
>>> 010 
8 
>>> 0b1011010010 
722
~~~

这些表示法都以0打头。（如果你不明白这些表示法有何意义，说明你使用它们的机会不多，只需将其牢记在心即可。）

## 1.4 变量

另一个你可能熟悉的概念是**变量**（variable）。如果代数对你来说不过是遥远的记忆，也不用担心，因为Python中的变量理解起来很容易。变量是表示（或指向）特定值的名称。例如，你可能想使用名称x来表示3，为此执行如下代码：

~~~python
>>> x = 3
~~~

这称为**赋值**（assignment），我们将值3赋给了变量x。换而言之，就是将变量x与值（或对象）3关联起来。给变量赋值后，就可在表达式中使用它。

~~~python
>>> x * 2 
6
~~~

不同于其他一些语言，使用Python变量前必须给它赋值，因为Python变量没有默认值。

> **注意** 在Python中，名称（**标识符**）只能由字母、数字和下划线（_）构成，且不能以数字打头。因此Plan9是合法的变量名，而9Plan不是。
>
> 在某种程度上说，标识符命名规则基于Unicode标准，详情请参阅“Python语言参考手册”

## 1.5 语句

语句和表达式有何不同呢？你可以这样想：表达式是一些东西，而语句做一些事情。

涉及赋值时，语句和表达式的差别更明显：鉴于赋值语句不是表达式，它们没有可供交互式解释器打印的值。

执行赋值语句后，交互式解释器只是再次显示提示符，但发生了一些变化：有一个名为x的新变量，与值3相关联。可以说，这是所有语句的一个根本特征：执行修改操作。例如，赋值语句改变变量，而print语句改变屏幕的外观。

## 1.6 获取用户输入

我们来看看很有用的函数input（稍后将更详细地介绍函数）。

~~~python
>>> input("The meaning of life: ") 
The meaning of life: 42 
'42'
~~~

这里在交互式解释器中执行了第一行（input(...)），它打印字符串"The meaning of life:"，提示用户输入相应的信息。我输入42并按回车。这个数被input（以文本或字符串的方式）返回，并在最后一行被自动打印出来。通过使用int将字符串转换为整数，可编写一个更有趣的示例：

~~~python
>>> x = input("x: ") 
x: 34 
>>> y = input("y: ") 
y: 42 
>>> print(int(x) * int(y)) 
1428
~~~

对于上述在Python提示符（>>>）下输入的语句，可将其放在完整的程序中，并让用户提供所需的值（34和42）。这样，这个程序将打印结果1428，即前述两个数的乘积。

## 1.7 函数

1.3节使用了乘方运算符（`**`）来执行幂运算。实际上，可不使用这个运算符，而使用**函数**pow。

~~~python
>>> 2 ** 3 
8 
>>> pow(2, 3) 
8
~~~

函数犹如小型程序，可用来执行特定的操作。Python提供了很多函数，可用来完成很多神奇的任务。实际上，你也可以自己编写函数（这将在后面更详细地介绍），因此我们通常将pow等标准函数称为**内置函数**。

有多个内置函数可用于编写数值表达式。例如，abs计算绝对值，round将浮点数圆整为与之最接近的整数。

整数总是向下圆整，而round圆整到最接近的整数，并在两个整数一样近时圆整到偶数。如果要将给定的数向下圆整，该如何做呢？例如，你知道某人的年龄为32.9，并想将这个值向下圆整为32，因为他还没有满33岁。Python提供了完成这种任务的函数floor，但你不能直接使用它，因为像众多很有用的函数一样，它也包含在模块中。

## 1.8 模块

可将模块视为扩展，通过将其导入可以扩展Python功能。要导入模块，可使用特殊命令import。前一节提及的函数floor包含在模块math中。

~~~python
>>> import math 
>>> math.floor(32.9) 
32
~~~

请注意其中的工作原理：我们使用import导入模块，再以module.function的方式使用模块中的函数。就这里执行的操作而言，也可像前面处理input的返回值那样，将这个数字转换为整数。

~~~python
>>> int(32.9) 
32
~~~

> **注意** 还有一些类似的函数，可用于转换类型，如str和float。实际上，它们并不是函数，而是类。类将在本书后面更详细地介绍。

模块math还包含其他几个很有用的函数。例如，ceil与floor相反，返回大于或等于给定数的最小整数。

~~~python
>>> math.ceil(32.3) 
33 
>>> math.ceil(32) 
32
~~~

如果确定不会从不同模块导入多个同名函数，你可能不想每次调用函数时都指定模块名。在这种情况下，可使用命令import的如下变种：

~~~python
>>> from math import sqrt 
>>> sqrt(9) 
3.0
~~~

通过使用命令import的变种from module import function，可在调用函数时不指定模块前缀。

> **提示** 事实上，可使用变量来引用函数（以及其他大部分Python元素）。执行赋值语句`foo = math.sqrt`后，就可使用foo来计算平方根。例如，foo(4)的结果为2.0。

### 1.8.1 cmath和负数

如果我们坚持将值域限定为实数，并使用其近似的浮点数实现，就无法计算负数的平方根。负数的平方根为虚数，而由实部和虚部组成的数为**复数**。Python标准库提供了一个专门用于处理复数的模块。

~~~python
>>> import cmath 
>>> cmath.sqrt(-1) 
1j
~~~

注意到这里没有使用from ... import ...。如果使用了这种import命令，将无法使用常规函数sqrt。类似这样的名称冲突很隐蔽，因此除非必须使用from版的import命令，否则应坚持使用常规版import命令。

1j是个虚数，虚数都以j（或J）结尾。复数算术运算都基于如下定义：-1的平方根为1j。这里不深入探讨这个主题，只举一个例子来结束对复数的讨论：

~~~python
>>> (1 + 3j) * (9 + 4j) 
(-3 + 31j)
~~~

从这个示例可知，Python本身提供了对复数的支持。

> **注意** Python没有专门表示虚数的类型，而将虚数视为实部为零的复数。

### 1.8.2 回到未来

据说Python之父Guido van Rossum有一台时光机，因为这样的情况出现了多次：大家要求Python提供某项功能时，却发现这项功能早已实现。当然，并非什么人都能进入这台时光机，不过Guido很体贴，通过神奇模块`__future__`让Python具备了时光机的部分功能。对于Python当前不支持，但未来将成为标准组成部分的功能，你可从这个模块进行导入。这一点你在1.3节已经见识过，本书后面也将经常遇到这个模块。

## 1.9 保存并执行程序

### 1.9.1 从命令提示符运行 Python 脚本

实际上，运行程序的方式有多种。首先，假定你打开了DOS窗口或UNIX shell，并切换到了Python可执行文件（在Windows中为python.exe，在UNIX中为python）或将该可执行文件所在的目录加入到了环境变量PATH中（仅适用于Windows）。另外，假定前一节的脚本（hello.py）存储在当前目录下。满足上述条件后，就可在Windows中使用如下命令来执行这个脚本：

`C:\>python hello.py`

在UNIX系统中，可使用如下命令：

~~~shell
$ python hello.py
~~~

如你所见，命令是一样的，只是系统提示符不同。

### 1.9.2 让脚本像普通程序一样

在有些情况下，你希望能够像执行其他程序（如Web浏览器或文本编辑器）一样执行Python脚本，而无需显式地使用Python解释器。UNIX提供了实现这种目标的标准方式：让脚本的第一行以字符序列#!（称为pound bang或shebang）开始，并在它后面指定用于对脚本进行解释的程序（这里是Python）的绝对路径。即便你对这一点不太明白，只需将下面的代码作为脚本的第一行，就可在UNIX中轻松运行脚本：

~~~python
#!/usr/bin/env python
~~~

不管Python库位于什么地方，这都将让你能够像运行普通程序一样运行脚本。如果你安装了多个版本的Python，可用更具体的可执行文件名（如python3）替换python。

要像普通程序一样运行脚本，还必须将其变成可执行的：

~~~shell
$ chmod a+x hello.py
~~~

现在，可以像下面这样来运行它（假定当前目录包含在执行路径中）：

~~~shell
$ hello.py
~~~

如果这不管用，请尝试使用./hello.py，这在当前目录（.）未包含在执行路径中时也管用（负责的系统管理员会告诉你执行路径是什么）。

如果你愿意，可对文件进行重命名并删除扩展名.py，使其看起来更像普通程序。

#### 如果双击会如何呢

在Windows中，扩展名`.py`是让脚本像普通程序一样的关键所在。请尝试双击前一节保存的文件hello.py。如果正确地安装了Python，这将打开一个DOS窗口，其中包含提示信息What is your name?。然而，这样运行程序存在一个问题：输入名字后，程序窗口将立即关闭，你根本来不及看清结果。这是因为程序结束后窗口将立即关闭。尝试修改脚本，在末尾添加如下代码行：

~~~python
input("Press <enter>")
~~~

现在运行这个程序并输入名字后，DOS窗口将包含如下内容：

~~~
What is your name? Gumby 
Hello, Gumby! 
Press <enter>
~~~

等你按回车键后，窗口将立即关闭，因为程序结束了。

### 1.9.3 注释

在Python中，井号（#）比较特殊：在代码中，井号后面到行尾的所有内容都将被忽略。（这也是Python解释器未被前面的/usr/bin/env卡住的原因所在。）

## 1.10 字符串

### 1.10.1 单引号字符串以及对引号转义

与数一样，字符串也是值：

~~~python
>>> "Hello, world!" 
'Hello, world!'
~~~

在这个示例中，有一点可能让你颇感意外：Python在打印字符串时，用单引号将其括起，而我们使用的是双引号。这有什么差别吗？其实没有任何差别。

这里使用的是单引号，结果完全相同。既然如此，为何同时支持单引号和双引号呢？因为在有些情况下，这可能会有用。

~~~python
>>> "Let's go!" 
"Let's go!" 
>>> '"Hello, world!" she said' 
'"Hello, world!" she said'
~~~

第二个字符串包含双引号，因此必须使用单引号将整个字符串括起，原因和前面一样。实际上，并非必须这样做（这样做只是出于方便考虑）。可使用反斜杠（\）对引号进行转义，如下所示

~~~python
>>> "\"Hello, world!\" she said" 
'"Hello, world!" she said'
~~~

像这样对引号进行转义很有用，且在有些情况下必须这样做。例如，在字符串同时包含单引号和双引号（如`'Let\'s say "Hello, world!"'`）时，如果不使用反斜杠进行转义，该如何办呢？

> **注意** 厌烦了反斜杠？你在本章后面将看到，在大多数情况下，可通过使用长字符串和原始字符串（可结合使用这两种字符串）来避免使用反斜杠。

### 1.10.2 拼接字符串

那么应该如何拼接字符串呢？就像将数相加一样，将它们相加

### 1.10.3 字符串表示str和repr

~~~python
>>> "Hello,\nworld!" 
'Hello,\nworld!' 
>>> print("Hello,\nworld!") 
Hello, 
world!
~~~

通过两种不同的机制将值转换成了字符串。你可通过使用函数str和repr直接使用这两种机制。使用str能以合理的方式将值转换为用户能够看懂的字符串。例如，尽可能将特殊字符编码转换为相应的字符。然而，使用repr时，通常会获得值的合法Python表达式表示。

~~~python
>>> print(repr("Hello,\nworld!")) 
'Hello,\nworld!' 
>>> print(str("Hello,\nworld!")) 
Hello, 
world!
~~~

### 1.10.4 长字符串、原始字符串和字节

有一些独特而有用的字符串表示方式。例如，有一种独特的语法可用于表示包含换行符或反斜杠的字符串（**长字符串**和**原始字符串**）。对于包含特殊符号的字符串，Python 2还提供了一种专用的表示语法，结果为Unicode字符串。这种语法现在依然管用，但是多余，因为在Python 3中，**所有**的字符串都是Unicode字符串。Python 3还引入了一种新语法，用于表示大致相当于老式字符串的字节对象。你将看到，在处理Unicode编码方面，这种对象依然扮演着重要的角色。

#### 1. 长字符串

要表示很长的字符串（跨越多行的字符串），可使用三引号（而不是普通引号）。

~~~python
print('''This is a very long string. It continues here. 
And it's not over yet. "Hello, world!" 
Still here.''')
~~~

还可使用三个双引号，如`"""like this"""`。请注意，这让解释器能够识别表示字符串开始和结束位置的引号，因此字符串本身可包含单引号和双引号，无需使用反斜杠进行转义。

> **提示** 常规字符串也可横跨多行。只要在行尾加上反斜杠，反斜杠和换行符将被转义，即被忽略。例如，如果编写如下代码：
>
> ~~~python
> print("Hello, \ world!")
> ~~~
>
> 它将打印Hello, world!。这种处理手法也适用于表达式和语句。
>
> ~~~python
> >>> 1 + 2 + \ 
>  	4 + 5 
> 12 
> >>> print \ 
>  	('Hello, world') 
> Hello, world
> ~~~

#### 2. 原始字符串

原始字符串不以特殊方式处理反斜杠，因此在有些情况下很有用。在常规字符串中，反斜杠扮演着特殊角色：它对字符进行转义，让你能够在字符串中包含原本无法包含的字符。

对于很长的路径，将需要使用大量的反斜杠。

`path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'`

在这样的情况下，原始字符串可派上用场，因为它们根本不会对反斜杠做特殊处理，而是让字符串包含的每个字符都保持原样。

~~~python
>>> print(r'C:\nowhere') 
C:\nowhere 
>>> print(r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz') 
C:\Program Files\fnord\foo\bar\baz\frozz\bozz
~~~

如你所见，原始字符串用前缀r表示。看起来可在原始字符串中包含任何字符，这大致是正确的。一个例外是，引号需要像通常那样进行转义，但这意味着用于执行转义的反斜杠也将包含在最终的字符串中。

~~~python
>>> print(r'Let\'s go!') 
Let\'s go!
~~~

另外，原始字符串不能以单个反斜杠结尾。换而言之，原始字符串的最后一个字符不能是反斜杠，除非你对其进行转义（但进行转义时，用于转义的反斜杠也将是字符串的一部分）。根据前一个示例，这一点应该是显而易见的。如果最后一个字符（位于结束引号前面的那个字符）为反斜杠，且未对其进行转义，Python将无法判断字符串是否到此结束。

~~~python
>>> print(r"This is illegal\") 
SyntaxError: EOL while scanning string literal
~~~

这合乎情理，但如果要指定以反斜杠结尾的原始字符串（如以反斜杠结尾的DOS路径），该如何办呢？本节介绍了大量技巧，应该能够帮助你解决这个问题，但基本技巧是将反斜杠单独作为一个字符串，下面是一个简单的示例：

~~~python
>>> print(r'C:\Program Files\foo\bar' '\\') 
C:\Program Files\foo\bar\
~~~

请注意，指定原始字符串时，可使用单引号或双引号将其括起，还可使用三引号将其括起。

#### 3. Unicode、bytes和bytearray

Python字符串使用Unicode编码来表示文本。对大多数简单程序来说，这一点是完全透明的，因此如果你愿意，可跳过本节，等需要时再学习这个主题。然而，鉴于处理字符串和文本文件的Python代码很多，大致浏览一下本节至少不会有什么坏处。

大致而言，每个Unicode字符都用一个码点（code point）表示，而码点是Unicode标准给每个字符指定的数字。这让你能够以任何现代软件都能识别的方式表示129个文字系统中的12万个以上的字符。当然，鉴于计算机键盘不可能包含几十万个键，因此有一种指定Unicode字符的通用机制：使用16或32位的十六进制字面量（分别加上前缀\u或\U）或者使用字符的Unicode名称（\N{*name*}）

~~~python
>>> "\u00C6" 
'Æ' 
>>> "\U0001F60A" 
'☺ '
>>> "This is a cat: \N{Cat}" 
'This is a cat: '
~~~

Unicode的理念很简单，却带来了一些挑战，其中之一是编码问题。在内存和磁盘中，所有对象都是以二进制数字（0和1）表示的（这些数字每8个为一组，即1字节），字符串也不例外。在诸如C等编程语言中，这些字节完全暴露，而字符串不过是字节序列而已。为与C语言互操作以及将文本写入文件或通过网络套接字发送出去，Python提供了两种类似的类型：不可变的bytes和可变的bytearray。如果需要，可直接创建bytes对象（而不是字符串），方法是使用前缀b：

# 第2章 列表和元组

本章将介绍一个新概念：**数据结构**。数据结构是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。在Python中，最基本的数据结构为**序列**（sequence）。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推。在有些编程语言中，从1开始给序列中的元素编号，但从0开始指出相对于序列开头的**偏移量**。这显得更自然，同时可回绕到序列末尾，用负索引表示序列末尾元素的位置。你可能认为这种编号方式有点怪，但我敢肯定，你很快就会习惯的。

## 2.1 序列概述

Python内置了多种序列，本章重点讨论其中最常用的两种：列表和元组。另一种重要的序列是字符串，将在下一章更详细地讨论。

列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。禁止修改序列通常出于技术方面的考虑，与Python的内部工作原理相关，这也是有些内置函数返回元组的原因所在。在你自己编写程序时，几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键，这将在第4章讨论。在这种情况下，不能使用列表来代替元组，因为字典键是不允许修改的。

在需要处理一系列值时，序列很有用。在数据库中，你可能使用序列来表示人，其中第一个元素为姓名，而第二个元素为年龄。如果使用列表来表示（所有元素都放在方括号内，并用逗号隔开），将类似于下面这样：

~~~python
>>> edward = ['Edward Gumby', 42]
~~~

序列还可包含其他序列，因此可创建一个由数据库中所有人员组成的列表：

~~~python
>>> edward = ['Edward Gumby', 42]
>>> john = ['John Smith', 50] 
>>> database = [edward, john] 
>>> database 
[['Edward Gumby', 42], ['John Smith', 50]]
~~~

> **注意** Python支持一种数据结构的基本概念，名为**容器**（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。映射将在第4章详细讨论。有一种既不是序列也不是映射的容器，它就是集合（set），将在第10章讨论。

## 2.2 通用的序列操作

有几种操作适用于所有序列，包括**索引**、**切片**、**相加**、**相乘**和**成员资格检查**。另外，Python还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。

> **注意** 有一个重要的操作这里不会介绍，它就是**迭代**（iteration）。对序列进行迭代意味着对其每个元素都执行特定的操作。有关迭代的详细信息，请参阅5.5节。

### 2.2.1 索引

序列中的所有元素都有编号——从0开始递增。你可像下面这样使用编号来访问各个元素

~~~python
>>> greeting = 'Hello' 
>>> greeting[0] 
'H'
~~~

> **注意** 字符串就是由字符组成的序列。索引0指向第一个元素，这里为字母H。不同于其他一些语言，Python没有专门用于表示字符的类型，因此一个字符就是只包含一个元素的字符串。

这称为**索引**（indexing）。你可使用索引来获取元素。这种索引方式适用于所有序列。当你使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此-1是最后一个元素的位置。

~~~python
>>> greeting[-1] 
'o'
~~~

对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给变量。这与先赋给变量再对变量执行索引操作的效果是一样的。

~~~python
>>> 'Hello'[1] 
'e'
~~~

如果函数调用返回一个序列，可直接对其执行索引操作。例如，如果你只想获取用户输入的年份的第4位，可像下面这样做：

~~~python
>>> fourth = input('Year: ')[3] 
Year: 2005 
>>> fourth 
'5'
~~~

### 2.2.2 切片

除使用索引来访问单个元素外，还可使用**切片**（slicing）来访问特定范围内的元素。为此，可使用两个索引，并用冒号分隔：

~~~python
>>> tag = '<a href="http://www.python.org">Python web site</a>' 
>>> tag[9:30] 
'http://www.python.org' 
>>> tag[32:-4] 
'Python web site'
~~~

如你所见，切片适用于提取序列的一部分，其中的编号非常重要：第一个索引是包含的第一

个元素的编号，但第二个索引是切片后余下的第一个元素的编号。请看下面的示例：

~~~python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
>>> numbers[3:6] 
[4, 5, 6] 
>>> numbers[0:1] 
[1]
~~~

简而言之，你提供两个索引来指定切片的边界，其中第一个索引指定的元素包含在切片内，但第二个索引指定的元素不包含在切片内。

#### 1. 绝妙的简写

假设你要访问前述数字列表中的最后三个元素，显然可以明确地指定这一点。

~~~python
>>> numbers[7:10] 
[8, 9, 10]
~~~

在这里，索引10指的是第11个元素：它并不存在，但确实是到达最后一个元素后再前进一步所处的位置。明白了吗？如果要从列表末尾开始数，可使用负数索引。

~~~python
>>> numbers[-3:-1] 
[8, 9]
~~~

然而，这样好像无法包含最后一个元素。如果使用索引0，即到达列表末尾后再前进一步所处的位置，结果将如何呢？

~~~python
>>> numbers[-3:0] 
[]
~~~

结果并不是你想要的。事实上，执行切片操作时，如果第一个索引指定的元素位于第二个索引指定的元素后面（在这里，倒数第3个元素位于第1个元素后面），结果就为空序列。好在你能使用一种简写：如果切片结束于序列末尾，可省略第二个索引。

~~~python
>>> numbers[-3:] 
[8, 9, 10]
~~~

同样，如果切片始于序列开头，可省略第一个索引。

~~~python
>>> numbers[:3] 
[1, 2, 3]
~~~

实际上，要复制整个序列，可将两个索引都省略。

~~~python
>>> numbers[:] 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~

#### 2. 更大的步长

执行切片操作时，你显式或隐式地指定起点和终点，但通常省略另一个参数，即步长。在普通切片中，步长为1。这意味着从一个元素移到下一个元素，因此切片包含起点和终点之间的所有元素。

~~~python
>>> numbers[0:10:1] 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~

在这个示例中，指定了另一个数。你可能猜到了，这显式地指定了步长。如果指定的步长大于1，将跳过一些元素。例如，步长为2时，将从起点和终点之间每隔一个元素提取一个元素。

~~~python
>>> numbers[0:10:2] 
[1, 3, 5, 7, 9] 
numbers[3:6:3] 
[4]
~~~

显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供步长4即可。

~~~python
>>> numbers[::4] 
[1, 5, 9]
~~~

当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。

~~~python
>>> numbers[8:3:-1] 
[9, 8, 7, 6, 5] 
>>> numbers[10:0:-2] 
[10, 8, 6, 4, 2] 
>>> numbers[0:10:-2] 
[] 
>>> numbers[::-2] 
[10, 8, 6, 4, 2]
>>> numbers[5::-2] 
[6, 4, 2] 
>>> numbers[:5:-2] 
[10, 8]
~~~

在这种情况下，要正确地提取颇费思量。如你所见，第一个索引依然包含在内，而第二个索引不包含在内。步长为负数时，第一个索引必须比第二个索引大。可能有点令人迷惑的是，当你省略起始和结束索引时，Python竟然执行了正确的操作：步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点。

### 2.2.3 序列相加

可使用加法运算符来拼接序列。

~~~python
>>> [1, 2, 3] + [4, 5, 6] 
[1, 2, 3, 4, 5, 6] 
>>> 'Hello,' + 'world!' 
'Hello, world!' 
>>> [1, 2, 3] + 'world!' 
Traceback (innermost last): 
	File "<pyshell>", line 1, in ? 
		[1, 2, 3] + 'world!' 
TypeError: can only concatenate list (not "string") to list
~~~

从错误消息可知，不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类型的序列。

### 2.2.4 乘法

将序列与数*x*相乘时，将重复这个序列*x*次来创建一个新序列：

~~~python
>>> 'python' * 5 
'pythonpythonpythonpythonpython' 
>>> [42] * 10 
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
~~~

#### None、空列表和初始化

空列表是使用不包含任何内容的两个方括号（`[]`）表示的。如果要创建一个可包含10个元素的列表，但没有任何有用的内容，可像前面那样使用`[42]*10`。但更准确的做法是使用`[0]*10`，这将创建一个包含10个零的列表。然而，在有些情况下，你可能想使用表示“什么都没有”的值，如表示还没有在列表中添加任何内容。在这种情况下，可使用None。在Python中，None表示什么都没有。因此，要将列表的长度初始化为10，可像下面这样做

~~~python
>>> sequence = [None] * 10 
>>> sequence 
[None, None, None, None, None, None, None, None, None, None]
~~~

### 2.2.5 成员资格

要检查特定的值是否包含在序列中，可使用运算符in。这个运算符与前面讨论的运算符（如乘法或加法运算符）稍有不同。它检查是否满足指定的条件，并返回相应的值：满足时返回True，不满足时返回False。这样的运算符称为**布尔运算符**，而前述真值称为**布尔值**。布尔表达式将在5.4节详细介绍。

下面是一些in运算符的使用示例：

~~~python
>>> permissions = 'rw' 
>>> 'w' in permissions 
True 
>>> 'x' in permissions 
False 
>>> users = ['mlh', 'foo', 'bar'] 
>>> input('Enter your user name: ') in users 
Enter your user name: mlh 
True 
>>> subject = '$$$ Get rich now!!! $$$' 
>>> '$$$' in subject 
True
~~~

开头两个示例使用成员资格测试分别检查'w'和'x'是否包含在字符串变量permissions中。在UNIX系统中，可在脚本中使用这两行代码来检查对文件的写入和执行权限。接下来的示例检查提供的用户名mlh是否包含在用户列表中，这在程序需要执行特定的安全策略时很有用（在这种情况下，可能还需检查密码）。最后一个示例检查字符串变量subject是否包含字符串'$$$'，这可用于垃圾邮件过滤器中。

> **注意**
>
> 相比于其他示例，检查字符串是否包含'$$$'的示例稍有不同。一般而言，运算符in检查指定的对象是否是序列（或其他集合）的成员（即其中的一个元素），但对字符串来说，只有它包含的字符才是其成员或元素，因此下面的代码完全合理：
>
> ~~~python
> >>> 'P' in 'Python' 
> True
> ~~~
>
> 事实上，在较早的Python版本中，只能对字符串执行这种成员资格检查——确定指定的字符是否包含在字符串中，但现在可使用运算符in来检查指定的字符串是否为另一个字符串的子串。

#### 长度、最小值和最大值

内置函数len、min和max很有用，其中函数len返回序列包含的元素个数，而min和max分别返回序列中最小和最大的元素（对象比较将在5.4.6节的“比较运算符”部分详细介绍）。

~~~python
>>> numbers = [100, 34, 678] 
>>> len(numbers) 
3 
>>> max(numbers) 
678 
>>> min(numbers)
34 
>>> max(2, 3) 
3 
>>> min(9, 3, 2, 5) 
2
~~~

基于前面的解释，这些代码应该很容易理解，但最后两个表达式可能例外。在这两个表达式中，调用max和min时指定的实参并不是序列，而直接将数作为实参。

## 2.3 列表：Python 的主力

前面的示例大量地使用了列表，你明白了它们很有用，但本节主要讨论列表不同于元组和字符串的地方——列表是可变的，即可修改其内容。另外，列表有很多特有的**方法**。

### 2.3.1 函数 list

鉴于不能像修改列表那样修改字符串，因此在有些情况下使用字符串来创建列表很有帮助。为此，可使用函数list。（它实际上是一个类，而不是函数，但眼下，这种差别并不重要。）

~~~python
>>> list('Hello') 
['H', 'e', 'l', 'l', 'o']
~~~

请注意，可将任何序列（而不仅仅是字符串）作为list的参数。

> **提示** 要将字符列表（如前述代码中的字符列表）转换为字符串，可使用下面的表达式：
>
> `''.join(somelist) `
>
> 其中somelist是要转换的列表。这到底是什么意思呢？3.4.3节对此做了说明。

### 2.3.2 基本的列表操作

可对列表执行所有的标准序列操作，如索引、切片、拼接和相乘，但列表的有趣之处在于它是可以修改的。本节将介绍一些修改列表的方式：给元素赋值、删除元素、给切片赋值以及使用列表的方法。（请注意，并非所有列表方法都会修改列表。）

#### 1. 修改列表：给元素赋值

修改列表很容易，只需使用第1章介绍的普通赋值语句即可，但不是使用类似于x = 2这样的赋值语句，而是使用索引表示法给特定位置的元素赋值，如x[1] = 2。

~~~python
>>> x = [1, 1, 1] 
>>> x[1] = 2 
>>> x 
[1, 2, 1]
~~~

> **注意** 不能给不存在的元素赋值，因此如果列表的长度为2，就不能给索引为100的元素赋值。要这样做，列表的长度至少为101。请参阅本章前面的“None、空列表和初始化”一节。

#### 2. 删除元素

从列表中删除元素也很容易，只需使用del语句即可。

~~~python
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl'] 
>>> del names[2] 
>>> names 
['Alice', 'Beth', 'Dee-Dee', 'Earl']
~~~

注意到Cecil彻底消失了，而列表的长度也从5变成了4。除用于删除列表元素外，del语句还可用于删除其他东西。你可将其用于字典（参见第4章）乃至变量，有关这方面的详细信息，请参阅第5章。

#### 3. 给切片赋值

切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。

~~~python
>>> name = list('Perl') 
>>> name 
['P', 'e', 'r', 'l'] 
>>> name[2:] = list('ar') 
>>> name 
['P', 'e', 'a', 'r']
~~~

从上述代码可知，可同时给多个元素赋值。你可能认为，这有什么大不了的，分别给每个元素赋值不是一样的吗？确实如此，但通过使用切片赋值，可将切片替换为长度与其不同的序列。

~~~python
>>> name = list('Perl') 
>>> name[1:] = list('ython') 
>>> name 
['P', 'y', 't', 'h', 'o', 'n']
~~~

使用切片赋值还可在不替换原有元素的情况下插入新元素。

~~~python
>>> numbers = [1, 5] 
>>> numbers[1:1] = [2, 3, 4] 
>>> numbers 
[1, 2, 3, 4, 5]
~~~

在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除切片。

~~~python
>>> numbers 
[1, 2, 3, 4, 5] 
>>> numbers[1:4] = [] 
>>> numbers 
[1, 5]
~~~

你可能猜到了，上述代码与del numbers[1:4]等效。现在，你可自己尝试执行步长不为1（乃至为负）的切片赋值了。

### 2.3.3 列表方法

方法是与对象（列表、数、字符串等）联系紧密的函数。通常，像下面这样调用方法：

`object.method(arguments)`

方法调用与函数调用很像，只是在方法名前加上了对象和句点（第7章将详细阐述方法到底是什么）。列表包含多个可用来查看或修改其内容的方法。

#### 1. append

方法append用于将一个对象附加到列表末尾。

~~~python
>>> lst = [1, 2, 3] 
>>> lst.append(4) 
>>> lst 
[1, 2, 3, 4]
~~~

你可能心存疑虑，为何给列表取lst这样糟糕的名字，而不称之为list呢？我原本是可以这样做的，但你可能还记得，list是一个内置函数(实际上，从Python 2.2起，list就是类型，而不是函数了（tuple和str亦如此）。有关这方面的完整说明，请参阅9.3.2节。)，如果我将前述列表命名为list，就无法调用这个函数。在特定的应用程序中，通常可给列表选择更好的名称。诸如lst等名称确实不能提供任何信息。因此，如果列表为价格列表，可能应该将其命名为prices、prices_of_eggs或pricesOfEggs。

另外请注意，与其他几个类似的方法一样，append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表。这通常正是你想要的，但有时会带来麻烦。我将在本章后面介绍sort时再回过头来讨论这一点。

#### 2. clear

方法clear就地清空列表的内容。

~~~python
>>> lst = [1, 2, 3] 
>>> lst.clear() 
>>> lst 
[]
~~~

这类似于切片赋值语句lst[:] = []。

#### 3. copy

方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。

~~~python
>>> a = [1, 2, 3] 
>>> b = a 
>>> b[1] = 4 
>>> a 
[1, 4, 3]
~~~

要让a和b指向不同的列表，就必须将b关联到a的副本。

~~~python
>>> a = [1, 2, 3] 
>>> b = a.copy() 
>>> b[1] = 4 
>>> a 
[1, 2, 3]
~~~

这类似于使用a[:]或list(a)，它们也都复制a。

#### 4. count

方法count计算指定的元素在列表中出现了多少次。

~~~python
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to') 
2 
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]] 
>>> x.count(1) 
2 
>>> x.count([1, 2]) 
1
~~~

#### 5. extend

方法extend让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提供给方法extend。换而言之，你可使用一个列表来扩展另一个列表。

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a.extend(b) 
>>> a 
[1, 2, 3, 4, 5, 6]
~~~

这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列（这里是a）。在常规拼接中，情况是返回一个全新的序列。

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a + b 
[1, 2, 3, 4, 5, 6] 
>>> a 
[1, 2, 3]
~~~

如你所见，拼接出来的列表与前一个示例扩展得到的列表完全相同，但在这里a并没有被修改。鉴于常规拼接必须使用a和b的副本创建一个新列表，因此如果你要获得类似于下面的效果，拼接的效率将比extend低：

~~~python
>>> a = a + b
~~~

另外，拼接操作并非就地执行的，即它不会修改原来的列表。要获得与extend相同的效果，可将列表赋给切片，如下所示：

~~~python
>>> a = [1, 2, 3] 
>>> b = [4, 5, 6] 
>>> a[len(a):] = b 
>>> a 
[1, 2, 3, 4, 5, 6]
~~~

这虽然可行，但可读性不是很高。

#### 6. index

方法index在列表中查找指定值第一次出现的索引。

~~~python
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni'] 
>>> knights.index('who') 
4 
>>> knights.index('herring') 
Traceback (innermost last): 
 File "<pyshell>", line 1, in ? 
 knights.index('herring') 
ValueError: list.index(x): x not in list
~~~

搜索单词'who'时，发现它位于索引4处。

然而，搜索'herring'时引发了异常，因为根本就没有找到这个单词。

#### 7. insert

方法insert用于将一个对象插入列表。

~~~python
>>> numbers = [1, 2, 3, 5, 6, 7] 
>>> numbers.insert(3, 'four') 
>>> numbers 
[1, 2, 3, 'four', 5, 6, 7]
~~~

与extend一样，也可使用切片赋值来获得与insert一样的效果。

~~~python
>>> numbers = [1, 2, 3, 5, 6, 7] 
>>> numbers[3:3] = ['four'] 
>>> numbers 
[1, 2, 3, 'four', 5, 6, 7]
~~~

这虽巧妙，但可读性根本无法与使用insert媲美。

#### 8. pop

方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。

~~~python
>>> x = [1, 2, 3] 
>>> x.pop() 
3 
>>> x 
[1, 2] 
>>> x.pop(0) 
1 
>>> x 
[2]
~~~

> **注意** pop是唯一既修改列表又返回一个非None值的列表方法。

使用pop可实现一种常见的数据结构——**栈**（stack）。栈就像一叠盘子，你可在上面添加盘子，还可从上面取走盘子。最后加入的盘子最先取走，这被为**后进先出**（LIFO）

push和pop是大家普遍接受的两种栈操作（加入和取走）的名称。Python没有提供push，但可使用append来替代。方法pop和append的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同。

~~~python
>>> x = [1, 2, 3] 
>>> x.append(x.pop()) 
>>> x 
[1, 2, 3]
~~~

>**提示** 要创建先进先出（FIFO）的队列，可使用insert(0, ...)代替append。另外，也可继续使用append，但用pop(0)替代pop()。一种更佳的解决方案是，使用模块collections中的deque。有关这方面的详细信息，请参阅第10章。

#### 9. remove

方法remove用于删除第一个为指定值的元素。

~~~python
>>> x = ['to', 'be', 'or', 'not', 'to', 'be'] 
>>> x.remove('be') 
>>> x 
['to', 'or', 'not', 'to', 'be'] 
>>> x.remove('bee') 
Traceback (innermost last): 
 File "<pyshell>", line 1, in ? 
 x.remove('bee') 
ValueError: list.remove(x): x not in list
~~~

如你所见，这只删除了为指定值的第一个元素，无法删除列表中其他为指定值的元素（这里是字符串'bee'）。

请注意，remove是就地修改且不返回值的方法之一。不同于pop的是，它修改列表，但不返回任何值。

#### 10. reverse

方法reverse按相反的顺序排列列表中的元素（我想你对此应该不会感到惊讶）。

~~~python
>>> x = [1, 2, 3] 
>>> x.reverse() 
>>> x 
[3, 2, 1]
~~~

注意到reverse修改列表，但不返回任何值（与remove和sort等方法一样）。

> **提示** 如果要按相反的顺序迭代序列，可使用函数reversed。这个函数不返回列表，而是返回一个迭代器（迭代器将在第9章详细介绍）。你可使用list将返回的对象转换为列表。
>
> ~~~python
> >>> x = [1, 2, 3] 
> >>> list(reversed(x)) 
> [3, 2, 1] 
> ~~~

#### 11. sort

方法sort用于对列表就地排序(多说一句，从Python 2.3起，方法sort使用的是稳定的排序算法)。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> x.sort() 
>>> x 
[1, 2, 4, 6, 7, 9]
~~~

前面介绍了多个修改列表而不返回任何值的方法，在大多数情况下，这种行为都相当自然（例如，对append来说就如此）。需要强调sort的行为也是这样的，因为这种行为给很多人都带来了困惑。在需要排序后的列表副本并保留原始列表不变时，通常会遭遇这种困惑。为实现这种目标，一种直观（但错误）的方式是像下面这样做：

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = x.sort() # Don't do this! 
>>> print(y) 
None
~~~

鉴于sort修改x且不返回任何值，最终的结果是x是经过排序的，而y包含None。为实现前述目标，正确的方式之一是先将y关联到x的副本，再对y进行排序，如下所示:

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = x.copy() 
>>> y.sort() 
>>> x 
[4, 6, 2, 1, 7, 9] 
>>> y 
[1, 2, 4, 6, 7, 9]
~~~

只是将x赋给y是不可行的，因为这样x和y将指向同一个列表。为获取排序后的列表的副本，另一种方式是使用函数sorted。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> y = sorted(x) 
>>> x 
[4, 6, 2, 1, 7, 9] 
>>> y 
[1, 2, 4, 6, 7, 9]
~~~

实际上，这个函数可用于任何序列，但总是返回一个列表(实际上，函数sorted可用于任何可迭代的对象。可迭代的对象将在第9章详细介绍)。

~~~python
>>> sorted('Python') 
['P', 'h', 'n', 'o', 't', 'y']
~~~

如果要将元素按相反的顺序排列，可先使用sort（或sorted），再调用方法reverse，也可使用参数reverse，这将在下一小节介绍。

#### 12. 高级排序

方法sort接受两个可选参数：key和reverse。这两个参数通常是按名称指定的，称为关键字参数，将在第6章详细讨论。参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数key设置为函数len。

~~~python
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] 
>>> x.sort(key=len) 
>>> x 
['add', 'acme', 'aerate', 'abalone', 'aardvark']
~~~

对于另一个关键字参数reverse，只需将其指定为一个真值（True或False，将在第5章详细介绍），以指出是否要按相反的顺序对列表进行排序。

~~~python
>>> x = [4, 6, 2, 1, 7, 9] 
>>> x.sort(reverse=True) 
>>> x 
[9, 7, 6, 4, 2, 1]
~~~

函数sorted也接受参数key和reverse。在很多情况下，将参数key设置为一个自定义函数很有用。第6章将介绍如何创建自定义函数。

## 2.4 元组：不可修改的序列

与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串也不能修改）。元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组。

~~~python
>>> 1, 2, 3 
(1, 2, 3)
~~~

如你所见，元组还可用圆括号括起（这也是通常采用的做法）。

~~~python
>>> (1, 2, 3) 
(1, 2, 3)
~~~

空元组用两个不包含任何内容的圆括号表示。

~~~python
>>> () 
()
~~~

你可能会问，如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它后面加上逗号。

~~~python
>>> 42 
42 
>>> 42, 
(42,)
>>> (42,) 
(42,)
~~~

最后两个示例创建的元组长度为1，而第一个示例根本没有创建元组。逗号至关重要，仅将值用圆括号括起不管用：(42)与42完全等效。但仅仅加上一个逗号，就能完全改变表达式的值。

~~~python
>>> 3 * (40 + 2) 
126 
>>> 3 * (40 + 2,) 
(42, 42, 42)
~~~

函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组（与list一样，tuple实际上也不是函数，而是类型。而且同样，目前你完全可以不考虑这一点）。如果参数已经是元组，就原封不动地返回它。

~~~python
>>> tuple([1, 2, 3]) 
(1, 2, 3) 
>>> tuple('abc') 
('a', 'b', 'c') 
>>> tuple((1, 2, 3)) 
(1, 2, 3)
~~~

你可能意识到了，元组并不太复杂，而且除创建和访问其元素外，可对元组执行的操作不多。元组的创建及其元素的访问方式与其他序列相同。

~~~python
>>> x = 1, 2, 3 
>>> x[1] 
2 
>>> x[0:2] 
(1, 2)
~~~

元组的切片也是元组，就像列表的切片也是列表一样。为何要熟悉元组呢？原因有以下两个。

- 它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。
- 有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count等方法时例外）。

一般而言，使用列表足以满足对序列的需求。

# 第3章 使用字符串

## 3.1 字符串基本操作

前一章说过，所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的。

## 3.2 设置字符串的格式：精简版

如果你是Python编程新手，可能不会用到所有的Python字符串格式设置选项，因此这里介绍精简版。如果你想了解详情，请参阅接下来的3.3节，否则只需阅读本节，再直接跳到3.4节。

将值转换为字符串并设置其格式是一个重要的操作，需要考虑众多不同的需求，因此随着时间的流逝，Python提供了多种字符串格式设置方法。以前，主要的解决方案是使用字符串格式设置运算符——百分号。这个运算符的行为类似于C语言中的经典函数printf：在%左边指定一个字符串（格式字符串），并在右边指定要设置其格式的值。指定要设置其格式的值时，可使用单个值（如字符串或数字），可使用元组（如果要设置多个值的格式），还可使用字典（这将在下一章讨论），其中最常见的是元组。

~~~python
>>> format = "Hello, %s. %s enough for ya?"
>>> values = ('world', 'Hot') 
>>> format % values
'Hello, world. Hot enough for ya?'
~~~

上述格式字符串中的%s称为**转换说明符**，指出了要将值插入什么地方。s意味着将值视为字符串进行格式设置。如果指定的值不是字符串，将使用str将其转换为字符串。其他说明符将导致其他形式的转换。例如，%.3f将值的格式设置为包含3位小数的浮点数。

这种格式设置方法现在依然管用，且依然活跃在众多代码中，因此你很可能遇到。可能遇到的另一种解决方案是所谓的模板字符串。它使用类似于UNIX shell的语法，旨在简化基本的格式设置机制，如下所示：

~~~python
>>> from string import Template 
>>> tmpl = Template("Hello, $who! $what enough for ya?") 
>>> tmpl.substitute(who="Mars", what="Dusty") 
'Hello, Mars! Dusty enough for ya?'
~~~

包含等号的参数称为关键字参数，第6章将详细介绍这个术语。在字符串格式设置中，可将关键字参数视为一种向命名替换字段提供值的方式。

编写新代码时，应选择使用字符串方法format，它融合并强化了早期方法的优点。使用这种方法时，每个替换字段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息。

在最简单的情况下，替换字段没有名称或将索引用作名称。

~~~python
>>> "{}, {} and {}".format("first", "second", "third") 
'first, second and third' 
>>> "{0}, {1} and {2}".format("first", "second", "third") 
'first, second and third'
~~~

然而，索引无需像上面这样按顺序排列。

~~~python
>>> "{3} {0} {2} {1} {3} {0}".format("be", "not", "or", "to") 
'to be or not to be'
~~~

命名字段的工作原理与你预期的完全相同。

~~~python
>>> from math import pi 
>>> "{name} is approximately {value:.2f}.".format(value=pi, name="π") 
'π is approximately 3.14.'
~~~

当然，关键字参数的排列顺序无关紧要。在这里，我还指定了格式说明符.2f，并使用冒号将其与字段名隔开。它意味着要使用包含2位小数的浮点数格式。如果没有指定.2f，结果将如下：

~~~python
>>> "{name} is approximately {value}.".format(value=pi, name="π") 
'π is approximately 3.141592653589793.'
~~~

最后，在Python 3.6中，如果变量与替换字段同名，还可使用一种简写。在这种情况下，可使用f字符串——在字符串前面加上f。

~~~python
>>> from math import e 
>>> f"Euler's constant is roughly {e}." 
"Euler's constant is roughly 2.718281828459045."
~~~

在这里，创建最终的字符串时，将把替换字段e替换为变量e的值。这与下面这个更明确一些的表达式等价：

~~~python
>>> "Euler's constant is roughly {e}.".format(e=e) 
"Euler's constant is roughly 2.718281828459045."
~~~

## 3.3 设置字符串的格式：完整版