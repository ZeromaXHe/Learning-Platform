# 第一部分 概述

# 第1章 设计与架构究竟是什么

软件设计也是如此。底层设计细节和高层架构信息是不可分割的。它们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。

## 目标是什么

> 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。

一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优良的。如果该系统的每次发布都会提升下一次变更的成本，那么这个设计就是不好的。就这么简单。

## 案例分析

### 乱麻系统的特点

我们在这里看到的是一个典型的乱麻系统。这种系统一般都是没有经过设计，匆匆忙忙被构建起来的。然后为了加快发布的速度，拼命地往团队里加入新人，同时加上决策层对代码质量提升和设计结构优化存在着持续的、长久的忽视，这种状态能持续下去就怪了。

### 管理层视角

### 问题到底在哪里

1. 慢但是稳，是成功的秘诀。
2. 该比赛并不是拼谁开始跑得快，也不是拼谁更有力气的。
3. 心态越急，反而跑得越慢。

现在的软件研发工程师都有点过于自信。哦，当然，他们确实不会偷懒，一点也不。但是他们真正偷懒的地方在于——持续低估那些好的、良好设计的、整洁的代码的**重要性**。

重构的时机永远不会再有了。工程师们忙于完成新功能，新功能做不完，哪有时间重构老的代码？循环往复，系统成了一团乱麻，生产效率持续直线下降，直至为零。

工程师们经常相信的另外一个错误观点是：“在工程中容忍糟糕的代码存在可以短期内加快该工程上线的速度，未来这些代码会造成一些额外的工作量，但是并没有什么大不了。”相信这些鬼话的工程师对自己清理乱麻代码的能力过于自信了。但是更重要的是，他们还忽视了一个自然规律：无论是从短期还是长期来看，**胡乱编写代码的工作速度其实比循规蹈矩更慢**。

测试驱动开发（TDD）

# 第2章 两个价值维度

对于每个软件系统，我们都可以通过行为和架构两个维度来体现它的实际价值。软件研发人员应该确保自己的系统在这两个维度上的实际价值都能长时间维持在很高的状态。不幸的是，他们往往只关注一个维度，而忽视了另外一个维度。更不幸的是，他们常常关注的还是错误的维度，这导致了系统的价值最终趋降为零。

## 行为价值

大部分程序员认为这就是他们的全部工作。他们的工作是且仅是：按照需求文档编写代码，并且修复任何Bug。这真是大错特错。

## 架构价值

软件系统的第二个价值维度，就体现在软件这个英文单词上：software。“ware”的意思是“产品”，而“soft”的意思，不言而喻，是指软件的灵活性。

软件系统必须保持灵活。软件发明的目的，就是让我们可以以一种灵活的方式来改变机器的工作行为。对机器上那些很难改变的工作行为，我们通常称之为**硬件**（hardware）。

为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的**具体形状**（shape）无关。

需求变更的范畴与形状，是决定对应软件变更实施成本高低的关键。

从系统相关方（Stakeholder）的角度来看，他们所提出的一系列的变更需求的范畴都是类似的，因此成本也应该是固定的。但是从研发者角度来看，系统用户持续不断的变更需求就像是要求他们不停地用一堆不同形状的拼图块，拼成一个新的形状。

我们在这里使用了“形状”这个词，这可能不是该词的标准用法，但是其寓意应该很明确。毕竟，软件工程师们经常会觉得自己的工作就是把方螺丝拧到圆螺丝孔里面。

问题的实际根源当然就是系统的架构设计。如果系统的架构设计偏向某种特定的“形状”，那么新的变更就会越来越难以实施。所以，好的系统架构设计应该尽可能做到与“形状”无关。

## 哪个价值维度更重要

如果这个问题由业务部门来回答，他们通常认为系统正常工作很重要。系统开发人员常常也就跟随采取了这种态度。**但是这种态度是错误的**。

## 艾森豪威尔矩阵

艾森豪威尔曾说到：

> 我有两种难题：紧急的和重要的，而紧急的难题永远是不重要的，重要的难题永远是不紧急的。

虽然老调重弹，但其中的道理依然成立。确实，紧急的事情常常没那么重要，而重要的事情则似乎永远也排不上优先级。

软件系统的第一个价值维度：系统行为，是紧急的，但是并不总是特别重要。

软件系统的第二个价值维度：系统架构，是重要的，但是并不总是特别紧急。

业务部门与研发人员经常犯的共同错误就是将第三优先级的事情提到第一优先级去做。换句话说，他们没有把真正紧急并且重要的功能和紧急但是不重要的功能分开。这个错误导致了重要的事被忽略了，重要的系统架构问题让位给了不重要的系统行为功能。

但研发人员还忘了一点，那就是业务部门原本就是没有能力评估系统架构的重要程度的，**这本来就应该是研发人员自己的工作职责**！所以，平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。

## 为好的软件架构而持续斗争

研发团队必须从公司长远利益出发与其他部门抗争。

请记住：如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。

# 第二部分 从基础构件开始：编程范式

编程范式（paradigm）。编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。

# 第3章 编程范式总览

本章将讲述三个编程范式，它们分别是结构化编程（structured programming）、面向对象编程（object-oriented programming）以及函数式编程（functional programming）。

## 结构化编程

结构化编程是第一个普遍被采用的编程范式（但是却不是第一个被提出的），由Edsger Wybe Dijkstra于1968年最先提出。与此同时，Dijkstra还论证了使用goto这样的无限制跳转语句将会损害程序的整体结构。接下来的章节我们还会说到，也是这位Dijkstra最先主张用我们现在熟知的if/then/else语句和do/while/until语句来代替跳转语句的。

我们可以将结构化编程范式归结为一句话：

> 结构化编程对程序控制权的直接转移进行了限制和规范。

## 面向对象编程

说到编程领域中第二个被广泛采用的编程范式，当然就是面向对象编程了。事实上，这个编程范式的提出比结构化编程还早了两年，是在1966年由Ole Johan Dahl和Kriste Nygaard在论文中总结归纳出来的。这两个程序员注意到在ALGOL语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。

在这里，我们也可以用一句话来总结面向对象编程：

> 面向对象编程对程序控制权的间接转移进行了限制和规范。

## 函数式编程

尽管第三个编程范式是近些年才刚刚开始被采用的，但它其实是三个范式中最先被发明的。事实上，函数式编程概念是基于与阿兰·图灵同时代的数学家Alonzo Church在1936年发明的λ演算的直接衍生物。1958年 John Mccarthy利用其作为基础发明了LISP语言。众所周知，λ演算法的一个核心思想是不可变性——某个符号所对应的值是永远不变的，所以从理论上来说，函数式编程语言中应该是没有赋值语句的。大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。

因此，我们在这里可以将函数式编程范式总结为下面这句话：

> 函数式编程对程序中的赋值进行了限制和规范。

## 仅供思考

它们都从某一方面**限制**和规范了程序员的能力。没有一个范式是增加新能力的。

三个编程范式分别限制了goto语句、函数指针和赋值语句的使用。

# 第4章 结构化编程

Dijkstra和他的老板Adriaan van Wijingaarden 曾经讨论过将“程序员”当作终身职业这件事，Dijkstra最担心的是由于没有人认真地对待过编程这件事或者将它当作是一门学术学科对待，他的科研成果可能将不会得到认真对待。而Adriaan则建议Dijkstra：为什么不亲自去开创这门学科呢？

## 可推导性

Dijkstra很早就得出的结论是：编程是一项**难度很大**的活动。一段程序无论复杂与否，都包含了很多细节信息。如果没有工具的帮助，这些细节的信息是远远超过一个程序员的认知能力范围的。

Dijkstra提出的解决方案是采用数学**推导**方法。他的想法是借鉴数学中的公理（Postulate）、定理（Theorem）、推论（Corollary）和引理（Lemma），形成一种欧几里得结构。程序员可以用代码将一些已证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。

Dijkstra在研究过程中发现一个问题：goto语句的某些用法会导致某个模块无法被递归拆分成更小的、可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。

goto语句的其他用法虽然不会导致这种问题，但是Dijkstra意识到它们的实际效果其实和简单的分支结构if-then-else以及循环结构do-while是一致的。如果代码中只采用了这两类控制结构，则一定可以将程序分解成更小的、可证明的单元。

Dijkstra展示了顺序结构的正确性可以通过枚举法证明。

同样的，Dijkstra利用枚举法又证明了分支结构的可推导性。

循环结构的证明过程则有些不同，为了证明一段循环程序的正确性，Dijkstra需要采用**数学归纳法**。

## goto是有害的

1968年，Dijkstra曾经给CACM的编辑写过一封信。Dijkstra在信中具体描绘了他对三种控制结构的看法。

这可捅了个大篓子。

总之，这场火热的争论持续了超过10年。

当然，这场辩论最终还是逐渐停止了。原因很简单：Dijkstra是对的。随着编程语言的演进，goto语句的重要性越来越小，最终甚至消失了。如今大部分的现代编程语言中都已经没有了goto语句。哦，对了，LISP里从来就没有过！

## 功能性讲解拆分

既然结构化编程范式可将模块递归降解拆分为可推导的单元，这就意味着模块也可以按功能进行降解拆分。

## 形式化证明没有发生

当然，形式化的、欧几里得式的数学推导证明并不是证明结构化编程正确性的唯一手段。下面我们来看另外一个十分成功的策略：**科学证明法**。

## 科学来救场

科学理论和科学定律的特点：它们可以被**证伪**，但是没有办法被证明。

科学方法论不需要证明某条结论是正确的，只需要想办法**证明它是错误的**。如果某个结论经过一定的努力无法证伪，我们则认为它在当下是足够正确的。

## 测试

Dijkstra曾经说过“测试只能展示Bug的存在，并不能证明不存在Bug”

这一事实所带来的影响是惊人的。软件开发虽然看起来是在操作很多数学结构，其实不是一个数学研究过程。恰恰相反，软件开发更像是一门科学研究学科，我们通过无法证伪来证明软件的正确性。

# 第5章 面向对象编程

我们首先得弄明白一个问题：究竟什么是面向对象？

对于这个问题，一种常见的回答是“数据与函数的组合”。这种说法虽然被广为引用，但总显得并不是那么贴切，因为它似乎暗示了o.f()与f(o)之间是有区别的，这显然不是事实。面向对象理论是在1966年提出的，当时Dahl和Nygaard主要是将函数调用栈迁移到了堆区域中。数据结构被用作函数的调用参数这件事情远比这发生的时间更早。

另一种常见的回答是“面向对象编程是一种对真实世界进行建模的方式”，这种回答只能算作避重就轻。

还有些人在回答这个问题的时候，往往会搬出一些神秘的词语，譬如**封装**（encapsulation）、**继承**（inheritance）、**多态**（polymorphism）。其隐含意思就是说面向对象编程是这三项的有机组合，或者任何一种支持面向对象的编程语言必须支持这三个特性。

那么，我们接下来可以逐个来分析一下这三个概念。

## 封装

由于面向对象语言为我们方便而有效地封装数据和函数提供了有力的支持，导致封装这个概念经常被引用为面向对象编程定义的一部分。通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。譬如，在实际应用中，类（class）中的公共函数和私有成员变量就是这样。

然而，这个特性其实并不是面向对象编程所独有的。其实C语言也支持完整的封装，下面来看一个简单的C程序：

~~~c
// point.h
struct Point;
struct Point* makePoint(double x, double y);
double distance (struct Point *p1, struct Point *p2);
~~~

~~~c
// point.c
#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
    double x,y;
};

struct Point* makePoint(double x, double y){
    struct Point* p = malloc(sizeof(struct Point));
    p->x = x;
    p->y = y;
    return p;
}

double distance (struct Point* p1, struct Point* p2) {
    double dx = p1->x - p2->x;
    double dy = p1->y - p2->y;
    return sqrt(dx*dx + dy*dy);
}
~~~

显然，使用point.h的程序是没有Point结构体成员的访问权限的。它们只能调用makePoint()函数和distance()函数，但对它们来说，Point这个数据结构体的内部细节，以及函数的具体实现方式都是不可见的。

这正是完美封装——虽然C语言是非面向对象的编程语言。上述C程序是很常见的。在头文件中进行数据结构以及函数定义的前置声明（forward declare），然后在程序文件中具体实现。程序文件中的具体实现细节对使用者来说是不可见的。

而C++作为一种面向对象语言，反而破坏了C的完美封装性。

由于一些技术原因（C++编译器必须要知道每个类实例的大小），C++编译器要求类的成员变量必须在该类的头文件中声明。这样一来，我们的point.h程序随之就改成了这样：

~~~c++
// point.h
class Point {
public:
    Point(double x, double y);
    double distance(const Point& p) const;
    
private:
    double x;
    double y;
}
~~~

~~~c++
// point.cc
#include "point.h"
#include <math.h>

Point::Point(double x, double y)
: x(x), y(y)
{}

double Point::distance(const Point& p) const {
    double dx = x-p.x;
    double dy = y-p.y;
    return sqrt(dx*dx + dy*dy);
}
~~~

好了，point.h文件的使用者现在知道了成员变量x和y的存在！虽然编译器会禁止对这两个变量的直接访问，但是使用者仍然知道了它们的存在。而且，如果x和y变量名称被改变了，point.cc也必须重新编译才行！这样的封装性显然是不完美的。

当然，C++通过在编程语言层面引入public、private、protected这些关键词，部分维护了封装性。但所有这些都是为了解决编译器自身的技术实现问题而引入的hack——编译器由于技术实现原因必须在头文件中看到成员变量的定义。

而Java和C#则彻底抛弃了头文件和实现文件分离的编程方式，这其实进一步削弱了封装性。因为在这些语言中，我们是无法区分一个类的声明和定义的。

由于上述原因，我们很难说强封装是面向对象编程的必要条件。而事实上，有很多面向对象编程语言（例如Smalltalk、Python、JavaScript、Lua、Ruby）对封装性并没有强制性的要求。

面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实际情况是，那些声称自己提供面向对象编程支持的编程语言，相对于C这种完美封装的语言而言，其封装性都被削弱了，而不是加强了。

## 继承

既然面向对象编程语言并没有提供更好的封装性，那么在继承性方面又如何呢？

嗯，其实也就一般般吧。简而言之，继承的主要作用是让我们可以在某个作用域对外部定义的某一组变量与函数进行覆盖。这事实上也是C程序员（不仅是C语言，大部分同时期的编程语言都提供了将某种数据结构伪装成另一种数据结构的特性）早在面向对象编程语言发明之前就一直在做的事了。

下面，看一下刚才的C程序point.h的扩展版：

~~~c
// namedPoint.h
struct NamedPoint;

struct NamedPoint* makeNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);
~~~

~~~c
// namedPoint.c
#include "namedPoint.h"
#include <stdlib.h>

struct NamedPoint {
    double x,y;
    char* name;
};

struct NamedPoint* makeNamePoint(double x, double y, char* name) {
    struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
    p->x = x;
    p->y = y;
    p->name = name;
    return p;
}

void setName(struct NamedPoint* np, char* name) {
    np->name = name;
}

char* getName(struct NamedPoint* np) {
    return np->name;
}
~~~

~~~c
// main.c
#include "point.h"
#include "namedPoint.h"
#include <stdio.h>

int main(int ac, char** av) {
    struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");
    struct NamedPoint* upperRight = makeNamedPoint(1.0, 1.0, "upperRight");
    printf("distance=%f\n", 
           distance(
               (struct Point*) origin, 
               (struct Point*) upperRight));
}
~~~

请仔细观察main函数，这里NamedPoint数据结构是被当作Point数据结构的一个衍生体来使用的。之所以可以这样做，是因为NamedPoint结构体的前两个成员的顺序与Point结构体的完全一致。简单来说，NamedPoint之所以可以被伪装成Point来使用，是因为NamedPoint是Point结构体的一个超集，同时两者共同成员的顺序也是一样的。

上面这种编程方式虽然看上去有些投机取巧，但是在面向对象理论被提出之前，这已经很常见了（这种编程方式到现在也很常见）。其实，C++内部就是这样实现单继承的。

因此，我们可以说，早在面向对象编程语言被发明之前，对继承性的支持就已经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继承这样便利易用，而且，多重继承（multiple inheritance）如果还想用这种方法来实现，就更难了。

同时应该注意的是，在main.c中，程序员必须强制将NamedPoint的参数类型转换为Point，而在真正的面向对象编程语言中，这种类型的向上转换通常应该是隐性的。

综上所述，我们可以认为，虽然面向对象编程在继承性方面并没有开创出新，但是的确在数据结构的伪装性上提供了相当程度的便利性。

回顾一下到目前位置的分析，面向对象编程在封装性上得0分，在继承性上勉强可以得0.5分（满分为1）。

## 多态

在面向对象编程语言被发明之前，我们所使用得编程语言能支持多态吗？

答案是肯定的，请注意下面这段用C语言编写的copy程序：

~~~c
#include <stdio.h>

void copy() {
    int c;
    while((c=getchar()) != EOF)
        putchar(c);
}
~~~

在上述程序中，函数getchar()主要负责从STDIN中读取数据。但是STDIN究竟指代的是哪个设备呢？同样的道理，putchar()主要负责将数据写入STDOUT，而STDOUT又指代的是哪个设备呢？很显然，这类函数其实就具有**多态性**，因为它们的行为依赖于STDIN和STDOUT的具体类型。

这里的STDIN和STDOUT与Java中的接口类似，各种设备都有各自的实现。当然，这个C程序中是没有接口这个概念的，那么getchar()这个调用的动作是如何真正传递到设备驱动程序中，从而读取到具体内容的呢？

其实很简单，UNIX操作系统要求每个IO设备都要提供open、close、read、write和seek这5个标准函数（UNIX系统有很多变体，这里只是举了一个例子）。也就是说，每个IO设备驱动程序对这5种函数的实现在函数调用上必须保持一致。

首先FILE数据结构体中包含了相对应的5个函数指针，分别用于指向这些函数：

~~~c
struct FILE {
    void (*open)(char* name, int mode);
    void (*close)();
    int (*read)();
    void (*write)(char);
    void (*seek)(long index, int mode);
};
~~~

然后，譬如控制台设备的IO驱动程序就会提供这5个函数的实际定义，将FILE结构体的函数指针指向这些对应的实现函数：

~~~c
#include "file.h"

void open(char* name, int mode) {/*...*/}
void close() {/*...*/}
int read() {int c;/*...*/return c;}
void write(char c) {/*...*/}
void seek(long index, int mode) {/*...*/}

struct FILE console = {open, close, read, write, seek};
~~~

现在，如果STDIN的定义是FILE*，并同时指向了console这个数据结构，那么getchar()的实现方式就是这样的：

~~~c
extern struct FILE* STDIN;

int getchar() {
    return STDIN->read();
}
~~~

换句话说，getchar()只是调用了STDIN所指向的FILE数据结构体中的read函数指针指向的函数。

这个简单的编程技巧正是面向对象编程中多态的基础。例如在C++中，类中的每个虚函数（virtual function）的地址都被记录在一个名叫vtable的数据结构里。我们对虚函数的每次调用都要先查下这个表，其衍生类的构造函数负责将该衍生类的虚函数地址加载到整个对象的vtable中。

归根结底，多态其实不过就是函数指针的一种应用。自从20世纪40年代末期冯·诺伊曼架构诞生那天起，程序员们就一直在使用函数指针模拟多态了。也就是说，面向对象编程在多态方面没有提出任何新概念。

当然了，面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多态变得更安全、更便于使用了。

用函数指针显式实现多态的问题就在于函数指针的危险性。毕竟，函数指针的调用依赖于一系列需要人为遵守的约定。程序员必须严格按照固定约定来初始化函数指针，并同样严格地按照约定来调用这些指针。只要有一个程序员没有遵守这些约定，整个程序就会产生极其难以跟踪和消除的Bug。

面向对象编程语言为我们消除了人工遵守这些约定的必要，也就等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统C程序员可以去做以前不敢想的事情。综上所述，我们认为面向对象编程其实是对程序间接控制权的转移进行了约束。

### 多态的强大性

IO设备变成了copy程序的插件。

程序应该**与设备无关**。

### 依赖反转

我们可以想象一下在安全和便利的多态支持出现之前，软件是什么样子的。在这里，源代码层面的以来不可避免地要跟随程序的控制流。

如你所见，main函数为了调用高层函数，它就必须能够看到这个函数所在的模块。在C中，我们会通过#include来实现，在Java中则通过import来实现，而在C#中则用的是using语句。总之，每个函数的调用方都必须要引用被调用方所在的模块。

显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为决定了控制流，而控制流则决定了源代码的依赖关系。

但一旦我们使用了多态，情况就不一样了

~~~mermaid
classDiagram
	class I {
		<I>
		+F()
	}
	class ML1 {
		+F()
	}
	HL1 --> I
	ML1 --|> I
	HL1 ..> ML1
~~~

在图5.2中，模块HL1调用了ML1模块中的F()函数，这里的调用是通过源代码级别的接口来实现的。当然在程序实际运行时，接口这个概念是不存在的，HL1会调用ML1中的F()函数（这种调用是隐性、间接进行的）。

注意模块ML1和接口I在源代码上的依赖关系（或者叫继承关系），该关系的方向和控制流正好是相反的，我们称之为**依赖反转**。这种反转对软件架构设计的影响是非常大的。

事实上，通过利用面向编程语言所提供的这种完全便利的多态实现，无论我们面对**怎样的源代码级别的依赖关系，都可以将其反转**。

通过这种方法，软件架构师可以**完全控制**采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。

这就是面向对象编程的好处，同时也是面向对象编程这种范式的核心本质——至少对一个软件架构师来说是这样的。

这种能力有什么用呢？在下面的例子中，我们可以用它来让数据库模块和用户界面模块都依赖于业务逻辑模块，而非相反。

~~~mermaid
graph LR
	用户界面-->业务逻辑
	数据库-->业务逻辑
	业务逻辑-.->用户界面	
	业务逻辑-.->数据库
	
	
~~~

这意味着我们让用户界面和数据库都成为业务逻辑的插件。也就是说，业务逻辑模块的源代码不需要引入用户界面和数据库这两个模块。

这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或者部署单元（例如jar文件、DLL文件、Gem文件等）了，这些组件或者部署单元的依赖关系与源代码的依赖关系是一致的，业务逻辑组件也不会依赖于用户界面和数据库这两个组件。

于是，业务逻辑组件就可以**独立于用户界面和数据库来进行部署**了，我们对用户界面或数据库的修改将不会对业务逻辑产生任何影响，这些组件都可以被分别独立地部署。

简单来说，当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件，这就是**独立部署能力**。

如果系统中所有组件都可以独立部署，那它们就可以由不同的团队并行开发，这就是所谓的**独立开发能力**。

# 第6章 函数式编程

## 整数平方

如果使用Java语言，代码如下：

~~~java
public class Squint {
    public static void main(String args[]) {
        for(int i=0; i<25; i++)
            System.out.println(i*i);
    }
}
~~~

下面我们改用Clojure语言来写这个程序，Clojure是LISP语言的一种衍生体，属于函数式编程语言。其代码如下：

~~~clojure
(println (take 25 (map (fn[x](* x x))(range))))
~~~

如果读者对LISP不熟悉，这段代码可能看起来很奇怪。没关系，让我们换一种格式，用注释来说明一下吧：

~~~clojure
(println;______________________输出
    (take 25;__________________前25
          (map (fn[x](* x x));_求平方
               (range))));_____整数
~~~

我们讨论它的主要目标是要凸显出Clojure和Java这两种语言之间的巨大区别。在Java程序中，我们使用的是**可变量**，即变量i，该变量的值会随着程序执行的过程而改变，故被称为循环控制变量。而Clojure程序中是不存在这种变量的，变量x一旦被初始化之后，就不会再被更改了。

这句话有点出人意料：函数式编程语言中的变量（Variable）是**不可变**（Vary）的。

## 不可变性与软件架构

为什么不可变性是软件架构设计需要考虑的重点呢？为什么软件架构师要操心变量的可变性呢？答案显而易见：所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题。

换句话说，一切并发应用遇到的问题，一切由于使用多线程、多处理器而引起的问题，如果没有可变变量的话都不可能发生。

作为一个软件架构师，当然应该要对并发问题保持高度关注。我们需要确保自己设计的系统在多线程、多处理器环境中能稳定工作。所以在这里，我们实际应该要问的问题是：不可变性是否实际可行？

如果我们能忽略存储器和处理器在速度上的限制，那么答案是肯定的。否则的话，不可变性只有在一定情况下是可行的。

下面让我们来看一下它具体该如何做到可行。

## 可变性的隔离

一种常见方式是将应用程序，或者是应用程序的内部服务进行切分，划分为可变的和不可变的两种组件。不可变组件用纯函数的方式来执行任务，期间不更改任何状态。这些不可变的组件将通过与一个或多个非函数式组件通信的方式来修改变量状态。

# 第三部分 设计原则

# 第四部分 组件构建原则

# 第14章 组件耦合

## 稳定依赖原则

> 依赖关系必须要指向更稳定的方向。

通过遵循稳定依赖原则（SDP），我们就可以确保自己设计中那些容易变更的模块不会被那些难于修改的组件所依赖。

### 稳定性

### 稳定性指标

究竟该如何来量化一个组件的稳定性呢？其中一种方法是计算所有入和出的依赖关系。通过这种方法，我们就可以计算出一个组件的位置稳定性（positional stability）。

- Fan-in：入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量。
- Fan-out：出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。
- I：不稳定性，I=Fan-out/(Fan-in + Fan-out)。该指标的范围是[0,1]，I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的。

稳定依赖原则（SDP）的要求是让每个组件的I指标都必须大于其所依赖组件的I指标。也就是说，组件结构依赖图中各组件的I指标必须要按其依赖关系方向递减。

### 并不是所有组件都应该是稳定的

如果一个系统中的所有组件都处于最高稳定性状态，那么系统就一定无法再进行变更了，这显然不是我们想要的。事实上，我们设计组件架构图的目的就是要决定应该让哪些组件稳定，让哪些组件不稳定。

### 抽象组件

读者可能会觉得创造新组件这种做法挺奇怪的。因为这样的组件中几乎不包含任何可执行的代码！但事实上，这种做法在C#或者Java这种静态类型语言中是非常普遍的，而且也必须这样做。因为这些抽象组件通常会非常稳定，可以被那些相对不稳定的组件依赖。

而当我们使用Ruby和Python这种动态类型语言时，这些抽象接口事实上并不存在，因此也就没有对它们的依赖。动态类型语言中的依赖关系是非常简单的，因为其依赖反转的过程并不需要声明和继承接口。

## 稳定抽象原则

> 一个组件的抽象化程度应该与其稳定性保持一致。

### 高阶策略应该放在哪里