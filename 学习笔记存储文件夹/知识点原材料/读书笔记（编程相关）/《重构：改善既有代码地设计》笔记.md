# 第1章 重构，第一个案例

## 1.1 起点

## 1.2 重构的第一步

第一个步骤永远相同：我得为即将修改的代码建立一组可靠的测试环境。

## 1.3 分解并重组statement()

长的离谱的statement()。代码块越小，代码的功能越容易管理，代码的处理和移动也就越轻松。

找出代码的逻辑泥团并运用Extract Method

我得在这段代码里找出函数内的局部变量和参数。不会被修改的变量都可以被我当成参数传入新的函数，至于会被修改的变量就需格外小心。如果只有一个变量会被修改，我可以把它当做返回值。

修改变量名称	代码的清晰度

### 搬移"金融计算"代码

函数应该放在它所使用的数据的所属对象内。	运用Move Method.	调整代码使之适应新家，然后重新编译

"适应新家"意味着要去掉参数。此外我还要在搬移时同时变更函数名称

下一个步骤是找出程序中对旧函数的所有引用点，并修改它们，让它们改用新函数

下一件事是去掉旧函数。

有时候我会保留旧函数，让它调用新函数。如果旧函数是一个public函数，我又不想修改其他类的接口，这便是一种有用的手法。

Replace Temp With Query。

我喜欢尽量除去这一类临时变量。临时变量往往引发问题，它们会导致大量参数被传来传去，而其实完全没有这种必要

### 提炼“常客积分计算”代码

Extract Method重构手法

### 去除临时变量

Replace Temp with Query，并利用查询函数（query method）来取代临时变量。

## 1.4 运用多态取代与价格相关的条件逻辑

问题的第一部分是switch语句。最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。

### 终于……我们来到继承

我们有数种影片类型，它们以不同的方式回答相同的问题。这听起来很像子类的工作。我们可以建立Movie三个子类，每个都有自己的计费法。

这样一来，我就可以用过多态来取代switch语句了。很遗憾的是这里有一个小问题，不能这么干。一部影片可以在生命周期内修改自己的分类，一个对象却不能在生命周期内修改自己所属的类。不过还是有一个解决方法：State模式。

加入这一层间接性，我们就可以在Price对象内进行子类化动作，于是便可在任何必要时刻修改价格。

State还是Strategy？

为了引入State模式，我使用了三个重构手法。首先运用Replace Type Code with State/Strategy。将类型相关的行为移到State模式内。然后运用Move Method将switch语句移到Price类。最后运用Replace Conditional with Polymorphism去掉switch语句。

首先我要使用Replace Type Code with State/Strategy。第一步是针对类型代码使用Self Encapsulate Field，确保任何时候都通过取值函数和设值函数来访问类型代码。

## 1.5 结语

# 第2章 重构原则

## 2.1 何谓重构

第一个定义是名词形式

重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

“重构”的另一个用法是动词形式

重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

我的定义还需要向两方面扩展。首先，重构的目的是使软件更容易被理解和修改。你可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小的变化，或不造成变化。与之形成对比的是性能优化。和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

我要强调的第二点是：重构不会改变软件可观察的行为——重构之后软件功能一如以往。

### 两顶帽子

使用重构技术开发软件时，你把自己的时间点分配给两种截然不同的行为：添加新功能，以及重构。添加新功能时，你不应该修改既有代码，只管添加新功能。通过测试（并让测试正常运行），你可以衡量自己的工作进度。重构时你就不能再添加新功能，只管改进程序结构。此时你不应该添加任何测试，只在绝对必要（用以处理接口变化）时才修改测试。

## 2.2 为何重构

### 重构改进软件设计

如果没有重构，程序的设计会逐渐腐败变质。代码结构的流失是累积性的。经常性的重构可以帮助代码维持自己该有的形态。

完成同样一件事，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句在做同样的事。因此改进设计的一个重要方向就是消除重复代码。	如果消除重复代码，你就可以确定所有事物和行为在代码中只表述一次，这正式优秀设计的根本。

### 重构使软件更容易理解

除了计算机外，你的源码还有其他读者：几个月后可能会有另一位程序员尝试读懂你的代码并做一些修改。

很多时候那个未来的开发者就是我自己。

这种可理解性还有另一方面的作用。我利用重构来协助我理解不熟悉的代码。每当看到不熟悉的代码，我必须试着理解其用途。

Ralph Johnson把这种“早期重构”描述为“擦掉窗户上的污垢，使你看得更远”。研究代码时我发现，重构把我带到更高的理解层次上。如果没有重构，我达不到这种层次。

### 重构帮助找到bug

对代码的理解，可以帮助我找到bug。

Kent Beck经常形容自己的一句话：“我并不是一个伟大的程序员，我只是个有一些优秀习惯的好程序员。”重构能帮助我更有效地写出强健的代码。

### 重构提高编程速度

前面的一切都归结到这最后一点：重构帮助你更快速地开发程序。

良好的设计是快速开发的根本。

## 2.3 何时重构

重构应该随时随地进行。

### 三次法则

Don Roberts给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

事不过三，三则重构。

### 添加功能时重构

最常见的重构时机就是我想给软件添加新特性的时候。此时，重构的直接原因往往是为了帮助我理解需要修改的代码——这些代码可能是别人写的，也可能是我自己写的。

在这里，重构的另一个原动力是：代码的设计无法帮助我轻松添加我所需要的特性。

### 修补错误时重构

调试过程中运用重构，多半是为了让代码更具可读性。

### 复审代码时重构

很多公司都会做常规的代码复审，因为这种活动可以改善开发状况。这种活动有助于在开发团队中传播知识，也有助于较有经验的开发者把知识传递给比较欠缺经验的人，并帮助很多人理解大型软件系统中的更多部分。代码复审对于编写清晰代码也很重要。

重构可以帮助我复审别人的代码。

重构还可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立刻实现。

## 2.4 怎么对经理说

在复审过程中使用重构就是一个不错的方法。大量研究结果显示，技术复审是减少错误、提高开发速度的一条重要途径。

当然，很多经理嘴巴上说自己“质量驱动”，其实更多是“进度驱动”。这种情况下我会给他们一个较有争议的建议：不要告诉经理！

软件开发者都是专业人士。对于快速创造软件，重构可带来巨大帮助。受进度驱动的经理要我尽可能快速完事，至于怎么完成，那就是我的事了。我认为最快的方式就是重构，所以我就重构。

```
间接层和重构——Kent Beck
大多数重构都为程序引入了更多间接层。
间接层是一柄双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一对象，程序会愈加难以阅读。
基于这个观点，你会希望尽量减少间接层。
别急，伙计！间接层的某些价值：
- 允许逻辑共享
- 分开解释意图和实现
- 隔离变化
- 封装条件逻辑
重构游戏最常见的变量：你如何看待你自己的程序。找出一个缺乏“间接层利益”之处，在不修改现有行为的前提下，为它加入一个间接层。现在你获得了一个更有价值的程序，因为它有较高的质量，让我们在明天（未来）受益。
请将这个方法与“小心翼翼的事前设计”做个比较。推测性设计总是试图在任何一行代码诞生之前就先让系统拥有所有优秀质量，然后程序员将代码塞进这个强健的骨架中就行了。这个过程的问题在于：太容易猜错。
还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。这种间接层常以中介函数形式出现。你本来希望在不同地点共享它，或让它表现出多态性，最终却只在一处用到。
```

（***笔记注解：***感觉上面文章翻译很垃圾，重构游戏原文我推测肯定是gaming译作"博弈"，讨论的是程序员需要权衡的利弊问题）

## 2.5 重构的难题

### 数据库

重构经常出问题的一个领域就是数据库。绝大多数商用程序都与它们背后的数据库结构紧密耦合在一起，这也是数据库结构如此难以修改的原因之一。另一个原因是数据迁移（migration）。就算你非常小心地将系统分层，将数据库结构和对象模型间的依赖降至最低，但数据库结构的改变还是让你不得不迁移所有的数据，这可能是件漫长而繁琐的工作。

在非对象数据库中，解决这个问题的方法之一就是：在对象模型和数据库模型之间插入一个分隔层，这就可以隔离两个模型各自的变化。升级某一模型时无需同时升级另一模型，只需升级上述的分隔层即可。这样的分隔层会增加系统复杂度，但可以给你带来很大的灵活度。如果你同时拥有多个数据库，或如果数据库模型较为复杂使你难以控制，那么即使不进行重构，这分隔层也是很重要的。

你无需一开始就插入分隔层，可以在发现对象模型变得不稳定时再产生它，这样你就可以为你的改变找到最好的平衡点。

对于开发者而言，对象数据库既有帮助也有妨碍。

### 修改接口

对于接口要特别谨慎——如果接口被修改了，任何事情都可能发生。

一直对重构带来困扰的一件事就是：许多重构方法的确会修改接口。像Rename Method这么简单的重构方法所做的一切就是修改接口。

只有当需要修改的接口被那些"找不到，即使找到也不能修改"的代码使用时，接口的修改才会成为问题。如果情况真是如此，我就会说：这个接口是个已发布接口（published interface）——比公开接口（public interface）更进一步。接口一旦发布，你就再也没法仅仅修改调用者而能够安全地修改接口了。

如何面对那些必须修改“已发布接口”的重构方法？

如果重构方法改变了已发布接口，你必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。	请尽量这么做：让旧接口调用新接口。	你还应该使用Java提供的deprecation（不建议使用）设施，将旧接口标记为deprecated。

这个过程的一个好例子就是Java容器类（集合类, Collection classes）。Java 2 的新容器取代了原先一些容器。

我们有另一个选择：不要发布接口。	代码所有权

不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅。

Java还有一种特别的接口修改：在throws子句中添加一个异常。

### 难以通过重构手法完成的设计改动

先想象重构的情况。

### 何时不该重构

有时候既有代码太混乱，重构它还不如重新写一个来的简单。作出这种决定很困难，我承认我也没有什么好准则可以判断何时应该放弃重构。

重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作。

一个折中方法就是：将“大块头软件”重构为封装良好的小型组件。然后你就可以逐一对组件做出“重构或重建”的决定。

另外，如果项目已近最后期限，你也应该避免重构。

## 2.6 重构与设计

重构肩负一项特殊使命：它和设计彼此互补。

极限编程

## 2.7 重构与性能

三种编写快速软件的方法。其中最严格的的是时间预算法，这通常只用于性能要求极高的实时系统。

第二种方法是持续关注法。这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。

第三种性能提升法就是利用上述90%统计数据。你编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段——那通常是在开发后期。一旦进入该阶段，你再按照某个特定程序来调整程序性能。

“发现热点、去除热点”

## 2.8 重构起源何处

重构（refactoring）

最早认识重构重要性的两个人是Ward Cunningham和Kent Beck，他们早在20世纪80年代就开始使用Smalltalk，那是一个特别适合重构的环境。

Ward和Kent的思想对Smalltalk社群产生了极大影响，重构概念也成为Smalltalk文化中一个重要元素。

# 第3章 代码的坏味道

## 3.1 Duplicated Code（重复代码）

如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合而为一，程序会变得更好。

最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。	Extract Method

另一种常见情况就是“两个互为兄弟的子类内含相同表达式”。	Extract Method，然后Pull Up Method将它推入超类内。如果代码只是相似，并非完全相同，那么就得运用Extract Method将相似部分和差异部分割开，构成单独一个函数。然后你可能发型可以运用Form Template Method获得一个Template Method设计模式。如果有些函数以不同的算法做相同的事，你可以选择其中较清晰的一个，并使用Substitute Algorithm将其他函数的算法替换掉。

如果两个毫不相关的类出现Duplicated Code，你应该对其中一个使用Extract Class。将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类。但是重复代码所在的函数也可能的确只应该属于某个类，另一个类只能调用它，抑或这个函数可能属于第三个类，而另两个类应该引用这第三个类。你必须决定这个函数放在哪儿最合适，并确保它安置后就不会再在其他任何地方出现。

## 3.2 Long Method（过长函数）

“间接层”所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。

很久以前程序员就已经认识到：程序越长越难理解。早期的编程语言中，子程序调用需要额外开销，这使得人们不乐意使用小函数。现代OO语言几乎已经完全免除了进程内的函数调用开销。

最终的效果就是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就要把需要说明的东西写进一个独立函数中，并以其用途（而非实现方法）命名。

百分之九十九的场合里，要把函数变小，只需使用Extract Method。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。

如果函数内有大量参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用Extract Method，最终就会把许多参数和临时变量当做参数，传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常使用Replace Temp with Query来消除这些临时元素。Introduce Parameter Object和Preserve Whole Object则可以将过长的参数列变得简洁一些。

如果你这么做了，仍然还有太多临时变量和参数，那就应该使用我们的杀手锏：Replace Method with Method Object.

如何确定该提炼那一段代码呢？一个很好的技巧：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离

条件表达式和循环常常也是提炼的信号。你可以使用Decompose Conditional处理条件表达式。至于循环，你应该将循环和其内的代码提炼到一个独立函数中。

## 3.3 Large Class（过大的类）

如果想利用单个类做太多事情，其内往往就会出现太多实例变量。

你可以运用Extract Class将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。	如果这个组件适合作为一个子类，你会发现Extract Subclass往往比较简单。

有时候类并非在所有时刻都使用所有实例变量。果真如此，你或许可以多次使用Extract Class或Extract Subclass。

先确定客户端如何使用它们，然后运用Extract Interface为每一种使用方式提炼出一个接口。

如果你的Large Class是个GUI类	Duplicate Observed Data

## 3.4 Long Parameter List（过长参数列）

有了对象，你就不必把函数需要的所有东西都以参数传递给它了，只需传给它足够的、让函数能从中获得自己需要的东西就行了。	面向对象程序中的函数，其参数列通常比在传统程序中短得多。

如果向已有对象发出一条请求就可以取代一个参数，那么你应该激活重构手法Replace Parameter with Method。	你还可以运用Preserve Whole Object将来自同一对象的一对数据收集起来，并以该对象替换它们。如果某些数据缺乏合理的对象归属，可使用Introduce Parameter Object为它们制造出一个“参数对象”。

这里有一个重要的例外：有时候你明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。

## 3.5 Divergent Change（发散式变化）

如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。	为此，你应该找出某特定原因而造成的所有变化，然后运用Extract Class将它们提炼到另一个类中。

## 3.6 Shotgun Surgery（霰弹式修改）

Shotgun Surgery类似 Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同类内做出许多小修改，你所面临的坏味道就是Shotgun Surgery。

这种情况下你应该使用Move Method和Move Field把所有需要修改的代码放进同一个类。如果眼下没有合适的类可以安置这些代码，就创造一个。通常可以运用Inline Class把一系列相关行为放进同一个类。这可能造成少量Divergent Change，但你可以轻松处理它。

Divergent Change是指“一个类受多种变化的影响”，Shotgun Surgery则是指“一种变化引发多个类相应修改”。这个两种情况下你都会希望整理代码，使“外界变化”与“需要修改的类”趋于一一对应。

## 3.7 Feature Envy（依恋情节）

函数对某个类的兴趣高过对自己所处类的兴趣。这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：把这个函数移至另一个地点。你应该使用Move Method把它移到它该去的地方。有时函数中只有一部分受这种依恋之苦，这时候你应该使用Extract Method把这部分提炼到独立函数中，再使用Move Method带它去它的梦中家园。

当然，并非所有情况都这么简单。一个函数往往会用到几个类的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。如果先以Extract Method将这个函数分解为数个较小函数并分别置放于不同地点，上述步骤也就比较容易完成了。

有几个复杂精巧的模式破坏了这个规则。说起这个话题，Strategy和Visitor立刻跳入我的脑海。Self Delegation也在此列。使用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。Strategy和Visitor使你得以轻松修改函数行为，因为它们将少量需被覆写的行为隔离开来——当然也付出了“多一层间接性”的代价。

## 3.8 Data Clumps（数据泥团）

这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用Extract Class将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用Introduce Parameter Object或Preserve Whole Object为它减肥。

## 3.9 Primitive Obsession （基本类型偏执）

对象的一个极大价值在于：它们模糊（甚至打破）了横亘于基本数据和体积较大类之间的界限。你可以轻松编写出一些与语言内置（基本）类型无异的小型类。

对象技术的新手通常不愿意在小任务上运用小对象。	你可以运用Replace Data with Object将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。（***笔记注释***：翻译的人怕不是对炙手可热这个词有什么误解。顺便多吐槽一点——你敢不敢全文都用英文原文表示算了……）如果想要替换的数据值是类型码，而它并不影响行为，则可以运用Replace Type Code with Class将它换掉。如果你有与类型码相关的条件表达式，可运用Replace Type Code with Subclass或Replace Type Code with State/Strategy加以处理。

如果你有一组应该总是被放在一起的字段，可运用Extract Class。如果你在参数列中看到基本型数据，不妨试试Introduce Parameter Object。如果你发现自己正从数组中挑选数据，可运用Replace Array with Object。

## 3.10 Switch Statements（switch惊悚现身）

面向对象程序的一个最明显特征就是：少用switch（或case）语句。从本质上说，switch语句的问题在于重复。	面向对象中的多态概念可为此带来优雅的解决办法。

大多数时候，一看到switch语句，你就应该考虑以多态来替换它。	应该使用Extract Method将switch语句提炼到一个独立函数中，再以Move Method将它搬移到需要多态性的那个类里。此时你必须决定是否使用Replace Type Code with Subclass 或 Replace Type Code with State/Strategy。一旦这样完成继承结构之后，你就可以运用Replace Conditional with Polymorphism了。

如果你只是在单一函数中有些选择事项，且并不想改动它们，那么多态有点杀鸡用牛刀了。这种情况下，Replace Parameter with Explicit Methods是个不错的选择。如果你选择条件之一是null，可以试试Introduce Null Object。

## 3.11 Parallel Inheritance Hierarchies（平行继承体系）

Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是闻到了这种坏味道。

消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用Move Method 和 Move Field，就可以将引用端的继承体系消弭于无形。

## 3.12 Lazy Class(冗赘类)

你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值其身价，它就应该消失。	如果某些子类没有做足够的工作，试试Collapse Hierarchy。对于几乎没用的组件，你应该以Inline Class对付它们。

## 3.13 Speculative Generality（夸夸其谈未来性）

如果你的某个抽象类其实没有太大作用，请运用Collapse Hierarchy。不必要的委托可运用Inline Class除掉。如果函数的某些参数未被用上，可对它实施Remove Parameter。如果函数名称带有多余的抽象意味，应该对它实施Rename Method，让它现实一些。

如果函数或类的唯一用户是测试用例，这就飘出了坏味道Speculative Generality。如果你发现这样的函数或类，请把它们连同其测试用例一并删掉。但如果它们的用途是帮助测试用例检测正当功能，当然必须刀下留人。

## 3.14 Temporary Field （令人迷惑的暂时字段）

有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。

请使用Extract Class给这个可怜的孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家。也许你还可以使用Inheritance Null Object在“变量不合法”的情况下创建一个Null对象，从而避免写出条件式代码。

如果类中有一个复杂算法，需要好几个变量，往往就可能导致坏味道Temporary Field的出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进字段中。但是这些字段只在使用该算法时才有效，其他情况下只会让人迷惑。这时候你可以利用Extract Class把这些变量和其相关函数提炼到一个独立类中。提炼后的新对象将是一个函数对象。

## 3.15 Message Chains（过度耦合的消息链）

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串getThis()或一长串临时变量。

这时候你应该使用Hide Delegate。你可以在消息链不同位置进行这种重构方法。理论上可以重构消息链上任何一个对象，但这么做往往会把一系列对象（intermediate object）都变成Middle Man。通常更好的选择是：先观察消息链最终得到的对象是用来干嘛的，看看能否以Extract Method把使用该对象的代码提炼到一个独立函数中，再运用Move Method 把这个函数推入消息链。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就加一个函数来做这件事。

有些人把任何函数链都视为坏东西，我们不这样想。

## 3.16 Middle Man（中间人）

封装往往伴随委托。

但是人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用Remove Middle Man，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用Inline Method把它们放进调用端。如果这些Middle Man还有其他行为，可以运用Replace Delegation with Inheritance把它变成实责对象的子类，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。

## 3.17 Inappropriate Intimacy（狎昵关系）

两个类过于亲密，花费太多时间探究彼此的private成分。

你可以采用Move Method和Move Field帮它们划清界限，从而减少狎昵行径。你也可以看看是否可以运用Change Bidirectional Association to Unidirectional 让其中一个类对另一个斩断情丝。如果两个类实在是情投意合，可以运用Extract Class把两者的共同点提炼到一个安全地点，让它们坦荡地使用这个新类。或者也可以尝试运用Hide Delegate让另一个类为它们传递相思情。

继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独自生活了，请运用Replace Inheritance with Delegation 让它离开继承体系。

## 3.18 Alternative Classes with Different Interfaces（异曲同工的类）

如果两个函数做同一件事，却有着不同签名，请运用Rename Method根据它们的用途重新命名。但这往往不够，请反复运用Move Method 将某些行为移入类，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可运用Extract Superclass让自己赎点罪。

## 3.19 Incomplete Library Class（不完美的库类）

复用常被视为对象的终极目的。不过我们认为，复用的意义经常被高估——大多数对象只要够用就好。

如果你只想修改库类的一两个函数，可以运用Introduce Foreign Method；如果想要添加一大堆的额外行为，就得运用Introduce Local Extension。

## 3.20 Data Class（幼稚的数据类）

所谓的Data Class是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。这些类早期可能拥有public 字段，果真如此你应该在别人注意到它们之前，立刻运用Encapsulate Field将它们封装起来。如果这些类内含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用Encapsulate Collection把它们封装起来。对于那些不该被其他类修改的字段，请运用Removing Setting Method。

然后，找出这些取值/设值函数被其他类运用的地点。尝试以Move Method把那些调用行为搬移到Data Class来。如果无法搬移整个函数，就运用Extract Method产生一个可被搬移的函数。不久以后你就可以运用Hide Method把这些取值/设值函数隐藏起来了。

## 3.21 Refused Bequest（被拒绝的遗赠）

子类应该继承超类的函数和数据。但如果它们不想继承或不需要继承，又该怎么办呢？

按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用Push Down Method 和 Push Down Field把所有用不到的函数下推给那个兄弟。这样一来，超类就只持有所有子类共享的东西。你常常会听到这样的建议：所有的超类都应该是抽象（abstract）的。

我们不建议你每次都这么做。	如果Refused Bequest引起困惑和问题，请遵循传统忠告。但不必认为你每次都必须这么做。十有八九这种坏味道很淡，不值得理睬。

如果子类复用了超类的行为（实现），但却不愿意支持超类的接口，Refused Bequest的坏味道就会变得浓烈。拒绝继承超类的实现，这一点我们不介意；但如果拒绝继承超类的接口，我们不以为然。不过即使你不愿意继承接口，也不要胡乱修改继承体系，应该运用Replace Inheritance with Delegation来达到目的。

## 3.22 Comments（过多的注释）

你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。

Comments可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构方法把坏味道去除。完成之后我们常常发现：注释已经变得多余了，因为代码已经清楚说明了一切。

如果你需要注释来解释一块代码做了什么，试试Extract Method；如果函数已经提炼出来，但还是需要注释来解释其行为，试试Rename Method；如果你需要注释说明某些系统的需求规格，试试Introduce Assertion。

如果你不知道该做什么，这才是注释的良好运用时机。

# 第4章 构筑测试体系

如果你想进行重构，首要前提就是拥有一个可靠的测试环境。

编写优良的测试程序，可以极大提高我的编程速度，即使不进行重构也是一样如此。

## 4.1 自测试代码的价值

编写测试程序，意味着要写很多额外代码。除非你确切体验到这种方法对编程速度的提升，否则自我测试就显不出它的意义。

实际上，撰写测试代码的最有用时机是在开始编程之前。当你需要添加特性的时候，先写相应测试代码。听起来离经叛道，其实不然。编写测试代码还能使你把注意力集中于接口而非实现（这永远是件好事）。预先写好的测试代码也为你的工作安上一个明确的结束标志：一旦测试代码正常运行，工作就可以结束了。

频繁进行测试是极限编程的重要一环。

重构前我们首先必须改造这些代码，使其能够自我测试。

Java之中的测试惯用手法是testing main，意思是每个类都应该有一个用于测试的main()。这是一个合理的习惯（尽管并不那么值得赞许），但可能不好操控。这种做法的问题是很难轻松运行多个测试。另一种做法是：建立一个独立类用于测试，并在一个框架中运行它，使测试工作更轻松。

## 4.2 JUnit 测试框架

（本书所用的JUnit版本已经非常古老，很多用法早已过时。请读者自行下载最新版本的JUnit，并参考相关文档来复现这些例子。——译者注）

第一件工作是设置测试夹具（test fixture），也就是用于测试的对象样本。

```
频繁地运行测试。每次编译请把测试也考虑进去——每天至少执行每个测试一次
```

### 单元测试和功能测试

JUnit框架的用途是单元测试，所以我应该讲讲单元测试（Unit Test）和功能测试（Functional Test）之间的差异。我一直挂在嘴边的其实是单元测试，编写这些测试的目的是为了提高程序员的生产率。	单元测试是高度局部化的东西，每个测试类都隶属于单一包。它能够测试其他包的接口，除此以外它将假设其他包一切正常。

功能测试就完全不同。它们用来保证软件能够正常运作。它们从客户的角度保障质量，并不关心程序员的生产力。它们应该由一个喜欢寻找bug的独立团队来开发。这个团队应该使用重量级工具和技术来帮助自己开发良好的功能测试。

一般而言，功能测试尽可能把整个系统当作一个黑箱。

```
每当你收到bug报告，请先写一个单元测试来暴露bug。
```

## 4.3 添加更多测试

我遵循的风格是：观察类该做的所有事情，然后针对任何一项功能的任何一种可能失败情况，进行测试。这不同于某些程序员提倡的“测试所有public函数”。	我不会去测试那些仅仅读写一个字段的访问函数，因为它们太简单了，不太可能出错。

这一点很重要，因为如果你撰写过多测试，结果往往测试量不够。	测试的要诀是：测试你最担心出错的部分。这样你就能从测试工作中得到最大利益。

```
编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。
```

测试的一项重要技巧就是“寻找边界条件”。

```
考虑可能出错的边界条件，把测试火力集中在那儿。
```

“寻找边界条件”也包括寻找特殊的、可能导致测试失败的情况。对于文件相关测试，空文件是个不错的边界条件。

随着测试类愈来愈多，你可以生成另外一个类，专门用来包含由其他测试类所组成的测试套件。

当测试数量达到一定程度之后，继续增加测试带来的效益就会呈现递减态势，而非持续递增。

对象技术有个微妙处：继承和多态会让测试变得比较困难，因为将有许多种组合需要测试。

测试代码和产品代码之间有个区别：你可以放心地复制、编辑测试代码。

# 第5章 重构列表

## 5.1 重构的记录格式

每个重构方法都有如下五个部分：

名称（name）

概要（summary）简单介绍此重构方法的适用情景，以及它所做的事情。

动机（motivation）为你介绍“为什么需要这个重构”和“什么情况下不该使用这个重构”

做法（mechanics）

范例（examples）

## 5.2 寻找引用点

（现在主流的Java IDE（例如Eclipse和IntelliJ IDEA）都能相当准确地找到程序元素的引用点。但如果使用Java外的编程语言，仍然可能用到本节所介绍的技巧。）

最好的帮手是一个适当的文本查找工具。许多编程环境都允许你在一个或一组文件中进行文本查找，而查找目标的可访问级则会告诉你需要查找的文件范围。

不要盲目地查找-替换。

在强类型语言中，你可以让编译器帮助你捕捉漏网之鱼。你往往可以直接删除旧部分，让编译器帮你找出因此而被悬挂起来的引用点。但是这种技巧也存在问题。

首先，如果被删除的部分在继承体系中声明不止一次，那么编译器也会被迷惑。尤其是当你处理一个被覆写多次的函数时，情况更是如此。

第二个问题是：编译器可能太慢，从而使你的工作失去效率。

第三个问题是：编译器无法找到通过反射机制而得到的引用点。这也是我们应该小心使用反射的原因之一。

## 5.3 这些重构手法有多成熟

# 第6章 重新组织函数

几乎所有时刻，问题都源于Long Methods(过长函数)。这很讨厌，因为它们往往包含太多信息，这些信息又被函数错综复杂的逻辑掩盖，不易鉴别。对付过长函数，一项重要的重构手法就是Extract Method，它把一段代码从原先函数中提取出来，放进一个单独函数中。Inline Method正好相反：将一个函数调用动作替换为该函数本体。如果在进行多次提炼之后，意识到提炼所得的某些函数并没有做任何实际事情，或如果需要回溯恢复原先函数，我就需要Inline Method。

Extract Method 最大的困难就是处理局部变量，而临时变量则是其中一个主要的困难源头。处理一个函数时，我喜欢运用Replace Temp with Query 去掉所有可去掉的临时变量。如果很多地方使用了某个临时变量，我就会先运用Split Temporary Variable 将它变得比较容易替换。

但有时候临时变量实在太混乱，难以替换。这时候我就需要使用Replace Method with Method Object。它让我可以分解哪怕最混乱的函数，代价则是引入一个新类。

参数带来的问题比临时变量稍微少一些，前提是你不在函数内赋值给它们。如果你已经这样做了，就得使用Remove Assignment to Parameter。

函数分解完毕后，我就可以知道如何让它工作得更好。也许我还会发现算法可以改进，从而使代码更清晰。这时我就使用Substitute Algorithm引入更清晰的算法。

## 6.1 Extract Method(提炼函数)

你有一段代码可以被组织在一起并独立出来。

将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

### 动机

Extract Method 是我最常用的重构方法之一。当我看见一个过长的函数或者一段需要注释才能让人理解用途的代码，我就会将这段代码放进一个独立函数中。

有几个原因造成我喜欢简短而命名良好的函数。首先，如果每个函数的粒度都很小，那么函数被复用的机会就更大；其次，这会使高层函数读起来就像一系列注释；再次，如果函数都是细粒度，那么函数的覆写也会容易一些。

一个函数多长才算合适？在我看来，长度不是问题，关键在于函数名称和函数本体之间的语义距离。如果提炼可以强化代码的清晰度，那就去做，就算函数名称比提炼出来的代码还长也无所谓。

### 做法

- 创建一个新函数，根据这个函数的意图来对它命名
- 将提炼出的代码从源函数复制到新建的目标函数中。
- 仔细检查提炼出的代码，看看其中是否引用了“作用域限于源函数”的变量（包括局部变量和源函数参数）
- 检查是否有“仅用于被提炼代码段”的临时变量。如果有，在目标函数中将它们声明为临时变量。
- 检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，并将结果赋值给相关变量。如果很难这样做，或如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动地提炼出来。你可能需要先使用Split Temporary Variable，然后再尝试提炼。也可以使用Replace Temp with Query将临时变量消灭掉。
- 将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。
- 处理完所有局部变量之后，进行编译。
- 在源函数中，将被提炼代码段替换为对目标函数的调用。
- 编译，测试

### 范例：无局部变量

### 范例：有局部变量

局部变量最简单的情况是：被提炼代码段只是读取这些变量的值，并不修改它们。这种情况下我可以简单地把它们作为参数传给目标函数。

如果局部变量是个对象，而被提炼代码段调用了会对该对象造成修改的函数，也可以如法炮制。你同样只需将这个对象作为参数传递给目标函数即可。只有在被提炼代码段真的对一个局部变量赋值的情况下，你才必须采取其他措施。

### 范例：对局部变量再赋值

如果被提炼代码段对局部变量赋值，问题就变得复杂了。这里我们只讨论临时变量的问题。如果你发现源函数的参数被赋值，应该马上使用Remove Assignments to Parameters。

被赋值的临时变量也分为两种情况。较简单的情况是：这个变量只在被提炼的代码段中使用。果真如此，你可以将这个临时变量的声明移到被提炼代码段中，然后一起提炼出去。另一种情况是：被提炼代码段之外的代码也使用了这个变量。这又分为两种情况：如果这个变量在被提炼代码段之后未再被使用，你只需要直接在目标函数中修改它就可以了；如果被提炼代码段之后的代码还使用了这个变量，你就需要让目标函数返回该变量改变后的值。

这时候，你可能会问：“如果需要返回的变量不止一个，又该怎么办呢？”

有几种选择。最好的选择通常是：挑选另一块代码来提炼。

临时变量往往为数众多，甚至会使提炼工作举步维艰。这种情况下，我会尝试先运用Replace Temp with Query 减少临时变量。如果即使这么做了提炼依旧困难重重，我就会动用Replace Method with Method Object，这个重构手法不在乎代码中有多少临时变量，也不在乎你如何使用它们。

## 6.2 Inline Method（内联函数）

一个函数的本体与名称同样清楚易懂。

在函数调用点插入函数本体，然后移除该函数。

### 动机

有时候你会遇到某些函数，其内部代码和函数名称一样清晰易读。也可能你重构了该函数，使得其内容和其名称同样清晰。果真如此，你就应该去掉这个函数，直接使用其中的代码。

另一种需要使用Inline Method的情况是：你手上有一群组织不甚合理的函数。你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。Kent Beck发现，实施Replace Method with Method Object之前先这么做，往往可以获得不错的效果。

如果别人使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成我在这些委托动作之间晕头转向，那么我通常都会使用Inline Method。

### 做法

- 检查函数，确定它不具有多态性。
- 找出这个函数的所有被调用点。
- 将这个函数的所有调用点都替换为函数本体。
- 编译，测试。
- 删除该函数的定义。

对于递归调用、多返回点、内联至另一个对象中而该对象并无提供访问函数……    我之所以不写这些特殊情况，原因很简单：如果你遇到了这样的复杂情况，那么就不应该使用这个重构手法。

## 6.3 Inline Temp（内联临时变量）

你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构方法。

将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。

### 动机

Inline Temp多半是作为Replace Temp with Query的一部分使用的，所以真正的动机出现在后者那儿。唯一单独使用Inline Temp的情况是：你发现某个临时变量被赋予某个函数调用的返回值。一般来说，这样的临时变量不会有任何危害，可以放心地把它留在那儿。但如果这个临时变量妨碍了其他的重构手法，例如Extract Method，你就应该将它内联化。

### 做法

- 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用。
- 如果这个临时变量并未被声明为final，那就将它声明为final，然后编译。
- 找到该临时变量的所有引用点，将它们替换为“为临时变量赋值”的表达式。
- 每次修改后，编译并测试。
- 修改完所有引用点之后，删除该临时变量的声明和赋值语句。
- 编译，测试。

## 6.4 Replace Temp with Query（以查询取代临时变量）

你的程序以一个临时变量保存某一表达式的运算结果。

将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

### 动机

临时变量的问题在于：它们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。

Replace Temp with Query往往是你运用Extract Method前必不可少的一个步骤。局部变量会使代码难以被提炼，所以你应该尽可能把它们替换为查询式。

这个重构手法较为简单的情况是：临时变量只被赋值一次，或者赋值给临时变量的表达式不受其他条件影响。其他情况比较棘手，但也有可能发生。你可能需要先运用Split Temporary Variable或Separate Query from Modifier使情况变得简单些，然后再替换临时变量。如果你想替换的临时变量是用来收集结果的（例如循环中的累加值），就需要将某些程序逻辑（例如循环）复制到查询函数去。

### 做法

首先是简单情况：

- 找出只赋值一次的临时变量。
- 将该临时变量声明为final。
- 编译。
  *（这可以确保该临时变量的确只被赋值一次）*
- 将“对该临时变量赋值”的语句的等号右侧部分提炼到一个独立函数中。
  *（首先将函数声明为private。日后你可能会发现有更多类需要使用它，那时放松对它的保护也很容易。）*
  *（确保提炼出来的函数无任何副作用，也就是说该函数并不修改任何对象内容，如果它有副作用，就对它进行Separate Query from Modifier）*
- 编译，测试。
- 在该临时变量身上实施Inline Temp。

运用此手法，你可能会担心性能问题。和其他性能问题一样，我们现在不管它，因为它十有八九根本不会造成任何影响。若是性能真的出了问题，你也可以在优化时期解决它。代码组织良好，你往往能够发现更有效的优化方案：如果没有进行重构，好的优化方案就可能与你失之交臂。如果性能实在太糟糕，要把临时变量放回去也是很容易的。

### 范例

## 6.5 Introduce Explaining Variable（引入解释性变量）

你有一个复杂的表达式。

将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。

### 动机

表达式可能非常复杂而难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。

在条件逻辑中，Introduce Explaining Variable 特别有价值：你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。使用这项重构的另一种情况是，在较长算法中，可以运用临时变量来解释每一步运算的意义。

Introduce Explaining Variable是一个很常见的重构手法，但我得承认，我并不常用它。我几乎总是尽量使用Extract Method来解释一段代码的意义。毕竟临时变量只在它所处的那个函数中才有意义，局限性较大，函数则可以在对象的整个生命中都有用，并且可被其他对象使用。但有时候，当局部变量使Extract Method难以进行时，我就使用Introduce Explaining Variable。

### 做法

- 声明一个final临时变量，将待分解之复杂表达式的一部分动作的运算结果赋值给它。
- 将表达式中的“运算结果”这一部分，替换为上述临时变量。
  *（如果替换这一部分在代码中重复出现，你可以每次一个，逐一替换）*
- 编译，测试。
- 重复上述过程，处理表达式的其他部分。

### 范例

### 运用Extract Method处理上述范例

那么，应该在什么时候使用Introduce Explaining Variable呢？答案是：在Extract Method 需要花费更大工作量时。如果我处理的是一个拥有大量局部变量的算法，那么使用Extract Method绝非易事。

## 6.6 Split Temporary Variable（分解临时变量）

你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。

针对每次赋值，创造一个独立、对应的临时变量。

### 动机

如果临时变量承担多个责任，它就应该被替换（分解）为多个临时变量，每个变量只承担一个责任。

### 做法

- 在待分解临时变量的声明及其第一次被赋值处，修改其名称。
- 将新的临时变量声明为final。
- 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量。
- 编译，测试。
- 逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值前的引用点。

### 范例

## 6.7 Remove Assignment to Parameters(移除对参数的赋值)

代码对一个参数进行赋值。

以一个临时变量取代该参数的位置。

### 动机

在Java中，不要对参数赋值。

### 做法

- 建立一个临时变量，把待处理的参数值赋予它。
- 以“对参数的赋值”为界，将其后所有对此参数的引用点，全部替换为“对此临时变量的引用”。
- 修改赋值语句，使其改为对新建之临时变量赋值。
- 编译，测试。

### 范例

还可以为参数加上关键词final，从而强制它遵循“不对参数赋值”这一惯例。

### Java的按值传递

## 6.8 Replace Method with Method Object（以函数对象取代函数）

你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。

将这个函数放进一个单独的对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。

### 动机

局部变量的存在会增加函数分解难度。

### 做法

- 建立一个新类，根据待处理函数的用途，为这个类命名。
- 在新类中建立一个final字段，用以保存原先大型函数所在的对象。我们将这个字段称为“源对象”。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存之。
- 在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数。
- 在新类中建立一个compute()函数。
- 将原函数的代码复制到compute()函数中。如果需要调用源对象的任何函数，请通过源对象字段调用。
- 编译。
- 将旧函数的函数本体替换为这样一条语句：“创建上述新类的一个对象，而后调用其中的compute()函数。”

### 范例

## 6.9 Substitute Algorithm（替换算法）

你想要把某个算法替换为另一个更清晰的算法。

将函数本体替换为另一个算法。

### 动机

### 做法

- 准备好另一个（替换用）算法，让它通过编译。
- 针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束。
- 如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准。

# 第7章 在对象之间搬移特性

常常我只需要使用Move Method和Move Field简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会先使用Move Field，再使用Move Method。

类往往会因为承担过多责任而变得臃肿不堪。这种情况下，我会使用Extract Class将一部分责任分离出去。如果一个类变得太“不负责任”，我就会使用Inline Class 将它融入另一个类。如果一个类使用了另一个类，运用Hide Delegate将这种关系隐藏起来通常是有帮助的。有时候隐藏委托类会导致拥有者的接口经常变化，此时需要使用Rename Middle Man。

本章的最后两项重构——Introduce Foreign Method和Introduce Local Extension比较特殊。只有当我不能访问某个类的源码，却又想把其他责任移进这个不可修改的类时，我才会使用这两个重构手法。如果我想加入的只是一或两个函数，就会使用Introduce Foreign Method；如果不止一两个函数，就使用Introduce Local Extension。

## 7.1 Move Method（搬移函数）

你的程序中，有个函数与其所驻类之外的另一个类进行更多交流；调用后者，或被后者调用。

在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。

### 动机

### 做法

