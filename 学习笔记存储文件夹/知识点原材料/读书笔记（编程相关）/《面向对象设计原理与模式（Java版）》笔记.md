# 第1章 面向对象设计与实现的优雅性

## 1.1 存在的问题

## 1.2 软件工程

软件工程传统上将软件开发过程分为各个阶段，包括需求说明和分析阶段、设计阶段、实现阶段以及维护阶段。

## 1.3 设计优雅软件的标准

1. 可用性——是否便于用户的使用？
2. 完整性——是否能满足所有用户的需求？
3. 健壮性——是否能从容地处理意外情形并且避免崩溃？
4. 高效性——是否能在合理的时间内利用合理的空间和其他资源进行必要的计算？
5. 可伸缩性——是否能在问题呈数量级增长时仍能正确、高效地运行？
6. 可读性——是否对于其他编程人员而言，拥有易于理解的设计和编码？
7. 可重用性——是否能在另一个完全不同的配置下使用？
8. 简洁性——是否拥有足够简洁的设计和实现？
9. 可维护性——是否能在不引入新的错误的情况下发现和改正已有错误？
10. 可扩充性——是否能在不破坏代码的前提下，简便地通过增加或删除功能来增强或限制软件整体功能？

## 1.4 说明

# 第2章 面向对象的基础知识

## 2.1 面向对象编程与非面向对象编程

### 2.1.1 面向对象编程与非面向对象编程简介

### 2.1.2 面向对象语言

### 2.1.3 面向对象编程的优点

## 2.2 Java中的类、对象、变量和方法

## 2.3 插入语：Java中的类方法和类变量

### 2.3.1 类变量及类方法简介

### 2.3.2 Java中的类变量及其使用

### 2.3.3 Java中的类方法及其使用

## 2.4 UML类图简介

统一建模语言（Unified Modeling Language，UML）

## 2.5 实现继承

### 2.5.1 特殊化

### 2.5.2 Java中的Object父类

在Java中，所有没有显式继承其他类的类都隐式继承了Object类。因此，所有的Java类要么直接继承了Object类，要么间接通过继承链中一个或多个中间类继承了Object类。这意味着，所有的类都自动继承了Object类的方法：clone、equals、finalize、getClass、hashcode、notify、notifyAll、toString以及三个版本的wait。

### 2.5.3 特殊化的另一种使用

### 2.5.4 泛化

### 2.5.5 Java中的单继承

## 2.6 类型、子类型和接口继承

### 2.6.1 类型

### 2.6.2 多态

### 2.6.3 多态的价值

## 2.7 接口与抽象类

## 2.8 动态方法调用

## 2.9 重载与重写

同一个类中两个相同方法名、不同参数列表（更精确地说，不同的参数类型列表——与参数名称无关）的方法将导致方法名的重载。这意味着同一类中的两个完全不同的方法使用了相同的方法名。注意，重载发生在一个类的内部，指的是两个或多个有同样方法名但却具有不同参数列表的方法。这与重写不同，重写发生在父类与子类之间，并且与这两个类中每个类的一个方法相关，这两个方法具有完全相同的签名。

## 2.10 控制对方法和数据的访问

# 第3章 优雅性与实现继承

## 3.1 关于继承的四个观点

### 3.1.1 代码重用观点

### 3.1.2 Is-A观点

### 3.1.3 公共接口观点

### 3.1.4 多态观点

## 3.2 代码重用的充分性

## 3.3 代码重用联合Is-A关系的充分性

这里的问题在于子类并不具有与父类一致的行为。而这个一致性对于优雅的代码而言则是必需的。

> **指导原则**
>
> 相似的接口（也就是相似的方法签名）对于优雅的子类/父类或者类/接口关系而言是不充分的；一致的行为同样是必需的。作为子类，B类尤其不能在继承了A类的方法后让这些方法失效或者将这些行为改变得面目全非。

这个指导原则也可以表述为惊讶原则。

> **指导原则（最小惊讶原则）**
>
> 如果客户认为他有一个对A类型的对象的引用，而实际上那却是一个对A的子类型B类型的对象的应用，那么他将消息传递给这个对象后，该对象的行为应该不能让客户感到惊讶。

> **Liskov替代原则（Liskov Substitution Principle, LSP）**
>
> 让B类称为A类的子类或者让B类实现A接口是可接受的，当且仅当，对于A和B的接口中的每个方法，B的方法可以接受所有A的方法能接受（或更多）的值作为输入，并且使用这些值进行和A的方法相同（或更多）的行为。

## 3.4 代码重用、Is-A关系以及公共接口的充分性

> **指导原则**
>
> 如果B类模型化了A类扮演的角色，尤其是暂时的角色，那么B类不应该成为A类的子类。实际上，B类的对象应该具有指向A类对象的引用。

## 3.5 Has-A关系和UML关联关系

## 3.6 代码重用、Is-A关系、公共接口以及多态的充分性

## 3.7 使用实现继承的代价

继承的一个缺点就是读者要追溯执行流程变得十分困难，尤其是在一个具有很多世代的深度继承树之中，其树的底层方法的代码分散在高层的祖先当中。

继承的另一个问题就是所有子类都是和父类紧密联系的。这个耦合是基于如下事实：为了确保子类的某些行为，子类需要了解很大一部分的父类的方法的实现。

## 3.8 示例：人、女人和男人

## 3.9 示例：绘制多边形

## 3.10 示例：排序

## 3.11 Java中数组的子类化

## 3.12 回顾：继承与引用

# 第4章 优雅性与方法

## 4.1 编码风格和命名约定

## 4.2 方法与分解

## 4.3 内聚方法

## 4.4 结构良好的对象和类不变式

## 4.5 内部文档

内部文档（internal documentation）为查看源代码的人服务的。这些文档需要提供无法从代码本身得到的信息。

## 4.6 外部文档

外部文档（external documentation）是为无法查看或者不关心源代码的人服务的。它描述了公共类、接口、方法、域和程序包以及它们的使用方法。

## 4.7 案例分析：重写Java中的equals方法

## 4.8 案例分析：重写Java中的clone方法

## 4.9 重构

# 第5章 优雅性和类

## 5.1 开始寻找类和类之间的关系

### 5.1.1 提取名词和动词

一个获取某设计的候选类的极其简单的初始方式，就是研究项目的规范并提取出所有的名词。每个名词都会对应着一个潜在的对象或类。类似地，通过提取动词，可以得到对象地潜在动作或行为。

### 5.1.2 使用应用领域的概念

使用名词和动词技术的一个问题，就是它过多地依赖于规范中使用的特殊词汇。

### 5.1.3 使用CRC卡片

CRC代表“类，责任和交互”（class，responsibility，and collaboration）

### 5.1.4 类协议

## 5.2 最大化内聚度

## 5.4 避免冗余

## 5.5 完整一致的协议

## 5.6 回顾：可变性与不可变性

## 5.7 为改变而设计

开闭原则（Open-Closed Principle）

## 5.8 迪米特法则

迪米特法则（Law of Demeter）

狎昵关系（inappropriate intimacy）

如果遇到代码采用的是长消息链，违背了迪米特法则的情况，当想要通过重构来使其满足该法则时，应该怎么办呢？有许多可以采用的重构，包括隐藏委托（Hide Delegate）、提炼方法（Extract Method）和搬移方法（Move Method）。重要的是，您需要重新考虑您的设计，来查看是否具有这样一个链，并且考虑如何避免这样的链。

迪米特法则实际上应该被称为“指导原则”（guideline）而不是“法则”（law）。它并不是绝对需要遵循的。否则，这将会给类的邻居增加巨大的负担，因为所有对它们的邻居的请求都要首先通过它们进行处理。

# 第6章 Money类的简单案例研究