# 第1章 可伸展的语言

Scala语言的名称来自于“可伸展的语言”。之所以这样命名，是因为它被设计成可以随着使用者的需求而扩展。Scala的应用范围很广，从编写简单脚本，到建立大型系统。

## 1.1 与你一同成长的语言

## 1.2 是什么让Scala具有可扩展性？

与其他常见语言相比，Scala在把面向对象和函数式编程熔合为一体的语言设计方面要做得更多。比方说，其他语言或许分别有对象和方法这样两个不同的概念，而在Scala里，函数就是对象。函数类型是能够被子类继承的类。看上去这似乎只是出于学术美感的考虑，但它从深层次上影响了可扩展性。实际上，如果没有这种函数和对象的联合，前面演示的actor的设想也将无从实现。本节将浏览Scala融合面向对象和函数概念的方法。

### Scala是面向对象的

尽管面向对象编程已经在很长一段时间里成为主流，但仍然鲜有语言能在Smalltalk之后推动这种构造原则到逻辑结论的转化。举例来说，许多语言允许非对象值的存在，如Java里面的原始值。或者它们允许不隶属于任何对象的静态字段和方法。这些对纯理想化面向对象编程的背叛最初看起来完全无害，但令人头疼的事情还在后面，情况会变得复杂并限制了可扩展性。

相反，Scala是纯粹的面向对象语言：每个值都是对象，每个操作都是方法调用。

如果说到组装对象，Scala比多数别的语言更胜一筹。Scala的特质（trait）就是其中一例。特质就像Java的接口，但可以有方法实现及字段。可以通过混入组装（mixin composition）构造对象，从而带有了类的成员并加入了若干特质的成员。这样的构造方式，可以让不同用途的类包装不同的特质。这看上去有点儿像多重继承，但在细节上是有差异的。与类不同，特质可以把一些新的功能加入还未定义的超类中。这使得特质比类更具有“可加性”。尤为重要的是，它可以避免在多重继承里，通过若干不同渠道继承相同类时发生的经典的“菱形继承”问题。

### Scala是函数式的

函数式编程有两种指导理念，第一种理念是函数是头等值。

函数式编程的第二种理念是程序的操作应该把输入值映射为输出值而不是就地修改数据。Scala库在Java API之上定义了更多的不可变数据类型。例如，Scala有不可变的列表、元组、映射表和集。

函数式编程第二种理念的另一种解释是，方法不应有任何副作用（side effect）。方法与其所在环境交流的唯一方式应该是获得参数和返回结果。

函数式语言鼓励使用不可变数据结构和指称透明的方法。甚至有些函数式语言必须依赖于它们。Scala不强迫使用函数式的风格。必要的情况下，可以写成指令形式（imperative），用可变数据或有副作用的方法调用。但是Scala有更好的函数式编程方式做替代，因此通常可以轻松地避免使用它们。

## 1.3 为什么选择Scala？

本节将讨论其中最重要的四个：兼容性、简洁、高层抽象和高级的静态类型化。

### Scala是兼容的

Scala程序会被编译成JVM的字节码。Scala代码可以调用Java方法，访问Java字段，继承自Java类和实现Java接口。

与Java的全交互操作性的另一个方面是Scala大量重用了Java类型。

Scala代码同样可以由Java代码调用。

### Scala是简洁的

首先，Scala的语法避免了一些束缚Java程序的固定写法。例如，Scala里的分号是可选的，且通常不写。

另一个有助于Scala简洁性的因素是类型推断。重复的类型信息可以被忽略，因此程序变得更有条理和易读。

但减少代码的关键或许是现成的代码库。

### Scala是高级的

### Scala是静态类型的

静态类型系统可以根据保存和计算的值的类型认定变量和表达式类型。Scala是一种具有非常高级的静态类型系统的语言。它以Java的内嵌类型系统为基础，允许使用范型（generics）参数化类型，用交集（intersection）组合类型及抽象类型（abstract type）隐藏类型细节。这都为自建类型打下了坚实的基础，从而能够设计出即安全又能灵活使用的接口。

**可检验属性**。静态类型系统可以保证消除某些运行时的错误。例如可以保证：布尔型不会与整数型相加；私有变量不会从类的外部被访问；用正确数量的参数调用了函数；字符串集只能加入字符串。

**安全的重构**。静态类型系统让你可以非常有信心地去变动代码基础的安全网。试想一个给方法新增参数的重构实例。在静态类型语言中，你可以完成修改，重编译你的系统并简单地修改所有引起类型错误的代码行。一旦完成了这些，你可以确信已经发现了所有需要修改的地方。

**文档**。静态类型是被编译器检查过正确性的程序文档。

## 1.4 Scala的根源

在最表层，Scala采用了Java和C#语法的大部分，而它们大部分借自于对C和C++语法的改变。

Scala也从其他语言中借鉴了许多地方。它的统一对象模型由Smalltalk建立，后来又被Ruby发扬光大。他的通用嵌套的思想（几乎所有的Scala里的结构都能被嵌套进其他结构）还出现在Algol、Simula和最近的Beta和gbeta中。它的方法调用和字段选择的统一访问原则来自于Eiffel。它函数式编程的处理方式在骨子里与以SML、OCaml和F#为代表的ML家族语言很接近。许多Scala标准库里面的高阶函数同样也出现在ML或Haskell中。Scala的隐式参数灵感激发自Haskell的类型类；它们用一种更经典的面向对象设定获得了类似的结果。Scala基于actor的并发库几乎全是Erlang的思想。

# 第2章 Scala入门初探

## 2.1 第一步 学习使用Scala解释器

## 2.2 第二步 变量定义

scala有两种变量，val和var。val类似于Java里的final变量。一旦初始化了，val就不能再被赋值。相反，var如同Java里面的非final变量，可以在它的生命周期中被多次赋值。

Java的变量类型写在名称之前，相反，Scala的变量类型写在其名称之后，用冒号分隔。如：

~~~scala
scala> val msg2: java.lang.String = "Hello again, world!"
msg2: java.lang.String = Hello again, world!
~~~

想在解释器中跨行输入语句的话，只要一行行写进去即可。如果输到行尾还没结束，解释器将在下一行回应一个竖线。

如果你发现了一些错误而解释器仍在等着更多的输入，你可以通过按两次回车键取消掉

## 2.3 第三步 函数定义

我们已经学过了Scala变量的使用方法，接下来学习如何写Scala的函数。如下：

~~~scala
scala> 	def max(x: Int, y: Int): Int = {
    		if (x > y) x
    		else y
		}
max: (Int,Int)Int
~~~

Unit指的是函数没有有效的返回值。Scala的Unit类型比较类似于Java的void类型，而且实际上Java里返回void的方法都会被映射为返回Unit的Scala方法。因此，结果类型为Unit的方法，并非为了得到返回值，而是为了其他的运行效果（side effect）。

如果想要离开解释器，输入`:quit`或者`:q`

## 2.4 第四步 编写Scala脚本