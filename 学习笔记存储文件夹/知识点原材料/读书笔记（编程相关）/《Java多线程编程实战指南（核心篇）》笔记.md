# 第1章 走进Java世界中的线程

## 1.1 进程、线程与任务

进程（Process）是程序的运行实例。例如，一个运行的Eclipse就是一个进程。进程与程序之间的关系就好比播放中的视频（如《摩登时代》这部电影）与相应的视频文件（如MP4文件）之间的关系，前者从动态的角度刻画事物而后者从静态的角度刻画事物。运行一个Java程序的实质是启动一个Java虚拟机进程，也就是说一个运行的Java程序就是一个Java虚拟机进程。

进程是程序向操作系统申请资源（如内存空间和文件句柄）的基本单位。线程（Thread）是进程中可独立执行的最小单位。例如，一个实现从服务器上下载大文件功能的程序为了提高其文件下载效率可以使用多个线程，这些线程各自独立地从服务器上下载大文件的一段数据。

一个进程可以包含多个线程。同一个线程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。

线程所要完成的计算就被称为任务，特定的线程总是在执行着特定的任务。任务代表线程所要完成的工作，它是一个相对的概念。一个任务可以是从服务器上下载一个文件、解压缩一批文件、解压缩一个文件、监视某个文件的最后修改时间等。这些任务也正是相应线程存在的理由。

## 1.2 多线程编程简介

### 1.2.1 什么是多线程编程

函数式编程（Functional Programming）中的函数是基本抽象单位，面向对象编程中的类（Class）是基本抽象单位。类似地，多线程编程就是以线程为基本抽象单位的一种编程范式（Paradigm）。但是，多线程编程和面向对象编程是可以相容的，即我们可以在面向对象编程的基础上实现多线程编程，事实上Java平台中的一个线程就是一个对象。

### 1.2.2 为什么使用多线程

为什么使用多线程进行编程？弄清楚这个问题有助于我们在实践中做到有的放矢，不至于为了使用多线程而使用多线程。下面我们通过几个多线程编程的典型例子去直观感受一下多线程编程。

某款音乐播放手机软件在其启动的时候会专门启动一个线程用于在用户的手机存储中查找音乐文件，然后自动将这些文件名添加到名为“本地音乐”的播放列表。由于从手机存储器（如SD卡）查找特定的文件（音乐文件）是一个相对慢的操作，我们不希望该操作使得该软件启动时显得卡顿。因此，搜索手机本地音乐文件这个任务使用专门的一个线程执行比将其放在负责界面显示的线程（Event Loop线程）中执行给用户带来的体验要好。

Web服务器（如Apache Tomcat）常常在同一时间内会收到多个HTTP请求。为了避免一个请求的处理快慢影响到其他请求的处理，绝大多数服务器都会采用一些专门的线程（工作者线程）负责请求处理，这些线程各自处理分配给它的请求，从而使得一个请求处理的快慢不会对其他请求的处理产生影响（当然，这里的“不影响”是相对的）。这有点像快餐店在点餐顾客多的情况下多开几条点餐线，以减少每个顾客的等待时间。

某系统需要从指定的日志文件中统计出一些信息。而待统计的日志文件中的每个文件可包含上万条记录。若要统计几十个这样的日志文件就会涉及几十万甚至上百万条记录的读取和处理。而读取日志文件所涉及的I/O操作又是一个比较慢的操作。因此，这里我们可以使用一个专门的线程负责日志文件的读取。另外，再使用专门的一个线程去负责对读取到内存中的日志记录数据进行统计。这样，使用多线程编程可以使得该统计工具的统计效率尽可能高。

## 1.3 Java线程API简介

Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。

### 1.3.1 线程的创建、启动与运行

在Java平台中创建一个线程就是创建一个Thread类（或其子类）的实例。为了讨论的方便，本书后面提到的线程与Thread实例如无特别说明指的是同一概念。

每个线程都有其要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或者通过该方法进行调用，因此run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。

运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为此，我们首先要启动线程。Thread类的start方法的作用是启动相应线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器（Scheduler）决定的。因此，start方法调用结束并不意味着相应线程已经开始运行，这个线程可能稍后才被运行，甚至也可能永远不会被运行。

Thread类的两个常用的构造器是：Thread() 和 Thread(Runnable target)。相应地，Java语言中创建线程有两种方式。一种是使用上述第1个构造器：定义Thread类的子类，在该子类中覆盖（Override）run方法并在该方法中实现线程任务处理逻辑；另一种是使用上述第2个构造器：创建一个java.lang.Runnable接口的实例，并在该实例的run方法中实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建（new）一个Thread类的实例。

在Java平台中，每个线程均可以有自己的名字，这个名字便于我们（人）区分不同的线程。



不管是采用哪种方式创建线程，一旦线程的run方法执行（由Java虚拟机调用）结束，相应的线程的运行也就结束了。当然，run方法执行结束包括正常结束（run方法返回）以及代码中抛出异常而导致的中止。运行结束的线程所占用的资源（如内存空间）会如同其他Java对象一样被Java虚拟机垃圾回收。

线程属于“一次性用品”，我们不能通关重新调用一个已经运行结束的线程的start方法来使其重新运行。事实上，start方法也只能够被调用一次，多次调用同一个Thread实例的start方法会导致其抛出IllegalThreadStateException异常。

在Java平台中，一个线程就是一个对象，对象的创建离不开内存空间的分配。创建一个线程与创建其他类型的Java对象所不同的是，Java虚拟机会为每个线程分配调用栈（Call Stack）所需的内存空间。调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码（Native Code，通常是C代码）的调用。另外，Java平台中的每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。因此相对来说，创建线程对象比创建其他类型的对象的成本要高一些。

Java平台中的任意一段代码（比如一个方法）总是由确定的线程负责执行的，这个线程就相应地被称为这段代码的执行线程。同一段代码可以被多个线程执行。	任意一段代码都可以通过调用`Thread.currentThread()`来获取这段代码的执行线程，这个线程就被称为当前线程。由于同一段代码可以被多个线程执行，因此当前线程是相对的，即概念层次上的当前线程（即Thread.currentThread()的返回值）在代码实际运行的时候可能对应着不同的线程（对象）。这就好比大家都自称“本人”（当前线程），“本人”这个词由张三来说就是指张三（线程X），而由李四来说则指李四（线程Y）。

我们知道线程的run方法总是由java虚拟机直接调用的。尽管如此，Java语言并不阻止我们直接调用run方法，这是因为：首先，线程在Java平台中也是一个对象，其次毕竟run方法也是一个public方法。但是，多数情况下我们不能这样做，因为这样做有违创建线程（对象）的初衷。

因此，如果我们没有启动线程而是在应用代码中直接调用线程的run方法的话，那么这个线程的run方法其实运行在当前线程（即run方法的调用方代码的执行线程）之中而不是运行在其自身线程之中，从而违背了创建线程的初衷。

### 1.3.2 Runnable接口

Runnable接口只定义了一个方法，该方法的声明如下：

~~~java
public void run()
~~~

Runnable接口可以被看作对任务进行的抽象，任务的处理逻辑就体现在run方法中。Thread类实际上是Runnable接口的一个实现类，其对Runnable接口的实现如下所示：

~~~java
public void run(){
    if (target != null) {
        target.run();
    }
}
~~~

可见，Thread类的run方法中实现的逻辑是如果target不为null，那么就调用target.run()，否则它什么也不做。其中，实例变量target的类型为Runnable。如果相应的线程实例是通过构造器Thread(Runnable target)创建的，那么target的值为构造器中参数值，否则target的值为null。因此，Thread类所实现的任务处理逻辑是要么什么也不做（target为null）。要么直接执行target所引用的Runnable实例所实现的任务处理逻辑。Thread类的run方法的这种处理逻辑决定了创建线程的两种方式：一种是在Thread子类的run方法中直接实现任务处理逻辑，另一种是在一个Runnable实例中实现任务处理逻辑，该逻辑由Thread类的run方法负责调用。

>扩展阅读 线程两种创建方式的区别
>
>从面向对象编程的角度来看：第1种创建方式（创建Thread类的子类）是一种基于继承（Inheritance）的技术，第2种创建方式（以Runnable接口实例为构造器参数直接通过new创建Thread实例）是一种基于组合（Composition）的技术。由于组合相对继承来说，其类和类之间的耦合性（Coupling）更低，因此它也更加灵活。一般我们认为组合是优先选用的技术。
>
>从对象共享的角度来看：第2种创建方式意味着多个线程实例可以共享同一个Runnable实例。在某些情况下这可能导致程序的运行结果出乎我们的意料。
>
>从对象创建成本的角度来看：Java中的线程实例是一个“特殊”的Runnable实例，因为在创建它的时候Java虚拟机会为其分配调用栈空间、内核线程等资源。因此，创建一个线程实例比起创建一个普通的Runnable实例来说，其成本要相对昂贵一点。所以，如果创建Runnable实例再将其作为方法参数传递给其他对象使用（JDK标准库中有不少API都使用了Runnable接口）而不必利用它来创建相应的线程（即第2种线程创建方式）即可满足我们的计算需要，那么就不要创建线程实例。

### 1.3.3 线程属性

线程的属性包括线程的编号（ID）、名称（Name）、线程类别（Daemon）和优先级（Priority），详情如表所示

| 属性               | 属性类型及用途                                               | 只读属性 | 重要注意事项                                                 |
| ------------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 编号（ID）         | 类型：long。用于标识不同的线程。不同的线程拥有不同的编号     | 是       | 某个编号的线程运行结束后，改编号可能被后续创建的线程使用。不同线程拥有的编号虽然不同，但是这种编号的唯一性只在Java虚拟机的一次运行有效。也就是说重启一个Java虚拟机（如重启Web服务器）后，某些线程的编号可能与上次Java虚拟机运行的某个线程的编号一样，因此该属性的值不适合用作某种唯一标识，特别是作为数据库中的唯一标识（如主键） |
| 名称（Name）       | 类型：String。面向人（而非机器）的一个属性，用于区分不同的线程。默认值与线程的编号有关，默认值的格式为：“Thread-线程编号”，如“Thread-0” | 否       | Java并不禁止我们将不同的线程的名称属性设置为相同的值。尽管如此，设置线程的名称属性有助于代码调试和问题定位 |
| 线程类别（Daemon） | 类型：boolean。值为true表示相应的线程为守护线程，否则表示相应的线程为用户线程。该属性的默认值与相应线程的父线程的该属性的值相同 | 否       | 该属性必须在相应线程启动之前设置，即对setDaemon方法的调用必须在对start方法的调用之前，否则setDaemon方法会抛出IllegalThreadStateException异常。负责一些关键任务处理的线程不适宜设置为守护线程 |
| 优先级（Priority） | 类型：int。该属性本质上是给线程调度器的提示，用于表示应用程序希望哪个线程能够优先得以运行。Java定义了1~10的10个优先级。默认值一般为5（表示普通优先级）。对于具体的一个线程而言，其优先级的默认级与其父线程（创建该线程的线程）的优先级值相等 | 否       | 一般使用默认优先级即可。不恰当地设置该属性值可能导致严重的问题（线程饥饿） |

通过名称属性，我们可以为每个线程设置一个便于区分不同线程的名称。虽然Java虚拟机并不要求每个线程的名称都不同，但是设置该属性有助于程序调试和问题定位。因此，我们建议为每个线程都设置一个简短而又能够体现其作用或其实现的功能的名称。

线程的属性除了编号外，其他属性都是可读写的属性，即Thread类提供了相应的get方法和set方法用于读取或者设置相应的属性。例如，getName方法可返回线程的名称属性值而setName方法则可以设置线程的名称属性值。

Java线程的优先级属性本质上只是一个给线程调度器的提示信息，以便于线程调度器决定优先调度哪些线程运行。它并不能保证线程按照其优先级高低的顺序运行。注意，Java线程的优先级使用不当或者滥用则可能导致某些线程永远无法得到运行，即产生了线程饥饿（Thread Starvation）。因此，线程的优先级并不是设置得越高越好；一般情况下使用普通优先级即可，即不必设置线程的优先级属性。

按照线程是否会阻止Java虚拟机正常停止，我们可以将Java中的线程分为守护线程（Daemon Thread）和用户线程（User Thread，也称非守护线程）。线程的daemon属性用于表示相应线程是否为守护线程。用户线程会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束（即Thread.run()调用未结束）的情况下才能正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。

如果Java虚拟机是被强制停止的，比如在Linux系统下使用kill命令强制终止一个Java虚拟机进程，那么即使是用户线程也无法阻止Java虚拟机的停止。

### 1.3.4 Thread类的常用方法

join方法的作用相当于执行该方法的线程和线程调度器说：“我得先暂停一下，等到另外一个线程运行结束后我才能继续（干活）。”我们会在第5章中进一步讲解该方法。

yield静态方法的作用相当于执行该方法的线程对线程调度器说：“我现在不急，如果别人需要处理器资源的话先给他用吧。当然，如果没有其他人要用，我也不介意继续占用。”

### 1.3.5 Thread类的一些废弃方法

| 方法    | 功能                   |
| ------- | ---------------------- |
| stop    | 停止线程的运行         |
| suspend | 暂停线程的运行         |
| resume  | 使被暂停的线程继续运行 |

## 1.4 无处不在的线程

## 1.5 线程的层次关系

Java平台中的线程不是孤立的，线程与线程之间总是存在一些联系。假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的子线程，相应地线程A就被称为线程B的父线程。子线程所执行的代码还可以创建其他线程，因此一个子线程也可以是其他线程的父线程。所以，父线程、子线程是一个相对的称呼。

线程间的这种父子关系就被称为线程的层次关系。由于Java虚拟机创建的main线程（也被称为主线程）负责执行Java程序的入口方法main方法，因此main方法中直接创建的线程都是main线程的子线程。这些子线程所执行的代码又可能创建其他线程。因此，这就形成了Java程序的线程层次关系。

在Java平台中，一个线程是否是一个守护线程默认取决于其父线程：默认情况下父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。另外，父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon方法，将相应的线程设置为守护线程（或者用户线程）。

一个线程的优先级默认值为该线程的父线程的优先级，即如果我们没有设置或者更改一个线程的优先级，那么这个线程的优先级的值与父线程的优先级的值相等。

不过，Java平台中并没有API用于获取一个线程的父线程，或者获取一个线程的所有子线程。并且，父线程和子线程之间的生命周期也没有必然的联系。比如父线程运行结束后，子线程可以继续运行，子线程运行结束也不妨碍其父线程继续运行。

习惯上，我们也称某些子线程为工作者线程（Worker Thread）或者后台线程（Background Thread）。工作者线程通常是其父线程创建来用于专门负责某项特定任务的执行的。

## 1.6 线程的生命周期状态

在Java语言中，一个线程从其创建、启动到运行结束的整个生命周期可能经历若干状态。

~~~mermaid
graph TB
	NEW --> RUNNABLE
	RUNNABLE --发起阻塞式I/O操作--> BLOCKED
	BLOCKED --阻塞式I/O操作结束--> RUNNABLE
	RUNNABLE --申请锁--> BLOCKED
	BLOCKED --获得锁--> RUNNABLE
	RUNNABLE --Object.wait调用--> WAITING
	WAITING --Object.notify/notifyAll调用--> RUNNABLE
	RUNNABLE --Thread.join调用--> WAITING
	WAITING --被等待线程终止--> RUNNABLE
	RUNNABLE --LockSupport.park调用--> WAITING
	WAITING --LockSupport.unpark Object调用--> RUNNABLE
	RUNNABLE --Thread.sleep long 调用--> TIMED_WAITING
	RUNNABLE --Object.wait long 调用--> TIMED_WAITING
	RUNNABLE --LockSupport.parkNanos/parkUntil调用--> TIMED_WAITING
	TIMED_WAITING --等待超时--> RUNNABLE
	RUNNABLE---->TERMINATED
	
	subgraph RUNNABLE_
	READY --被线程调度器选中--> RUNNING
	RUNNING --Thread.yield调用--> READY
	end
~~~

Java线程的状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。Thread.getState()的返回值类型Thread.State是一个枚举类型（Enum）。Thread.State所定义的线程状态包括以下几种。

- **NEW**：一个已创建而未启动的线程处于该状态。由于一个线程实例只能能够启动一次，因此一个线程只可能有一次处于该状态。
- **RUNNABLE**：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。前者表示处于该状态的线程可以被线程调度器（Scheduler）进行调度而使之处于RUNNING状态。后者表示处于该状态的线程正在运行，即相应线程对象的run方法所对应的指令正在由处理器执行。执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。处于READY子状态的线程也被称为活跃线程。
- **BLOCKED**：一个线程发起一个阻塞式I/O（Blocking I/O）操作后，或者申请一个由其他线程持有的独占资源（比如锁）时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源。当阻塞式I/O操作完成时，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。
- **WAITING**：一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。能够使其执行线程变更为WAITING状态的方法包括：Object.wait()、Thread.join() 和 LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()/notifyAll()和LockSupport.unpark(Object)。
- **TIMED_WAITING**：该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。
- **TERMINATED**：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。

一个线程在其整个生命周期中，只可能有一次处于NEW状态和TERMINATED状态。

## 1.7 线程的监视

一个真实的Java系统运行时往往有上百个线程在运行，如果没有相应的工具能够对这些线程进行监视，那么这些线程对于我们来说就成了黑盒。而我们在开发过程中进行代码调试、定位问题甚至是定位线上环境（生产环境）中的问题时往往都需要将线程变为白盒，即我们要能够知道系统中特定时刻存在哪些线程、这些线程处于什么状态以及这些线程具体是在做什么事情这些信息。

对线程进行监视的主要途径是获取并查看程序的线程转储（Thread Dump）。一个程序的线程转储包含了获取这个线程转储的那一刻该线程的线程信息。这些信息包括程序中有哪些线程以及这些线程的具体信息。Java程序的线程转储包含的线程具体信息包括线程的属性（ID、名称、优先级等）、生命周期状态、线程的调用栈（Call Stack）以及锁（第3章会介绍这个概念）的相关信息等。通过查看调用栈我们就能够了解线程的执行情况（具体在干些什么）。

获取线程转储的方法如表所示

| 平台          | 获取途径                                               | 备注                                                         |
| ------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 平台无关      | 执行命令：jstack -l PID                                | ①PID为Java程序的进程ID。Java程序的进程ID可以使用JDK的jps命令（可执行文件是JDK主目录/bin/jps）或者Linux的ps命令来获取。<br/>②jstack是Oracle JDK自带的一个工具，其可执行文件是：JDK主目录/bin/jstack；Windows版JDK自JDK 1.6开始提供该工具 |
|               | 单机图形化工具jvisualvm中的Thread Dump按钮             | ③jvisualvm是Oracle JDK自带的一个工具，其可执行文件是：JDK主目录/bin/jvisualvm |
|               | 使用图形化工具Java Mission Control（JMC）              | ④JMC是Oracle JDK 1.8开始自带的一个工具，其可执行文件是：JDK主目录/bin/jmc。JMC支持Eclipse插件 |
| 特定于Linux   | 执行命令：kill -3 PID                                  |                                                              |
|               | 在启动Java程序的控制台中按下“CTRL+\”组合键             |                                                              |
| 特定于Windows | 在启动Java程序的命令行提示窗口中按下“CTRL+Break”组合键 |                                                              |

## 1.8 多线程编程简单运用实例

## 1.9 多线程编程的优势和风险

多线程编程具有以下优势：

- 提高系统的吞吐率（Throughput）。多线程编程使得一个进程中可以有多个并发（Concurrent，即同时进行的）的操作。例如，当一个线程因为I/O操作而处于等待时，其他线程仍然可以执行其操作。
- 提高响应性（Responsiveness）。在使用多线程编程的情况下，对于GUI软件（如桌面应用程序）而言，一个慢的动作（比如从服务器上下载一个大的文件）并不会导致软件的界面出现被“冻住”的现象而无法响应用户的其他操作；对于Web应用程序而言，一个请求的处理慢了并不会影响其他请求的处理。
- 充分利用多核（Multicore）处理器资源。如今多核处理器的设备越来越普及，就算是手机这样的消费类设备也普遍使用多核处理器。实施恰当的多线程编程有助于我们充分利用设备的多核处理器资源，从而避免了资源浪费。
- 最小化对系统资源的使用。一个进程中的多个线程可以共享其所在进程所申请的资源（如内存空间），因此使用多个线程相比于使用多个进程进行编程来说，节约了对系统资源的使用。
- 简化程序的结构。线程可以简化复杂应用程序的结构。

多线程编程也有自身的问题与风险，包括以下几个方面。

- 线程安全（Thread Safe）问题。多个线程共享数据的时候，如果没有采取相应的并发访问控制措施，那么就可能产生数据一致性问题，如读取脏数据（过期的数据）、丢失更新（某些线程所做的更新被其他线程所做的更新覆盖）等。
- 线程活性（Thread Liveness）问题。一个线程从其创建到运行结束的整个生命周期会经历若干状态。从单个线程的角度来看，RUNNABLE状态时我们所期望的状态。但实际上，代码编写不当可能导致某些线程一直处于等待其他线程释放锁的状态（BLOCKED状态），即产生了死锁（Deadlock）。例如，线程T1拥有锁L1，并试图去获取锁L2，而此时线程T2拥有锁L2而试图去获得锁L1，这就导致线程T1和T2一直处于等待对方释放锁而一直又得不到锁的状态。当然，一直忙碌的线程也可能会出现问题，它可能面临活锁（Livelock）问题，即一个线程一直在尝试某个操作但就是无法进展，这就好比小猫一直追着自己的尾巴咬却一直咬不到的情形。另外，线程是一种稀缺的计算资源，一个系统所拥有的处理器数量相比于该系统中存在的线程数量而言总是少之又少的。某些情况下可能出现线程饥饿（Starvation）的问题，即某些线程永远无法获取处理器执行的机会而永远处于RUNNABLE状态的READY子状态。
- 上下文切换（Context Switch）。处理器从执行一个线程转向执行另外一个线程的时候操作系统所需要做的一个动作被称为上下文切换。由于处理器资源的稀缺性，因此上下文切换可以被看作多线程编程的必然副产物，它增加了系统的消耗，不利于系统的吞吐率。
- 可靠性。多线程编程一方面可以有利于可靠性，例如某个线程意外提前终止了，但这并不影响其他线程继续其处理。另一方面，线程是进程的一个组件，它总是存在于特定的进程中，如果这个进程由于某种原因意外提前终止，比如某个Java进程由于内存泄漏导致Java虚拟机崩溃而意外终止，那么该进程中所有的线程也就随之而无法继续运行。因此，从提高软件可靠性的角度来看，某些情况下可能要考虑多进程多线程的编程方式，而非简单的单进程多线程方式。

# 第2章 多线程编程的目标与挑战

## 2.1 串行、并发与并行

假设我们有3件事情（事情A、事情B和事情C）要完成，完成每件事情所需的时间包括实际投入时间（如做准备活动所需的时间）和等待的时间，完成这些事情所需的时间为：事情A耗时15分钟（实际投入5分钟，等待10分钟）、事情B耗时10分钟（实际投入2分钟，等待8分钟）、事情C耗时10分钟（实际投入10分钟，无等待耗时）。那么，我们有3种方式来完成这几件事情。

串行（Sequential），先开始做事情A，待其完成之后再开始做事情B，依此类推，直到事情C完成。这实际上顺序逐一完成几件事情，只需要投入一个人。在这种方式下3件事情总共耗时35（15+10+10）分钟。

并发（Concurrent）。这种方式也可以只投入一个人。这个人先开始做事情A，事情A的准备活动做好后（此时消耗了5分钟)，在等待A完成的这段时间内他开始做事情B。为事情B的准备活动花了2分钟之后，在等待事情B完成的这段时间内他开始做事情C，直到10分钟之后事情C完成。这整个过程实际上是以交替的方式利用等待某件事情完成的时间来做其他事情。在这种方式下3件事情总共耗时17（5+2+10）分钟，这比第1种方式节约了一半多的时间。

并行（Parallel）。这种方式需要投入3个人，每个人负责完成其中一件事情。这3个人在同一时刻开始齐头并进地完成这些事情。在这种方式下3件事情总共耗时15分钟（取决于耗时最长的那件事情所需的时间），比并发的方式节约了2分钟的时间。

可见，并发是串行的反面，并发往往可以提高我们对事情的处理效率，即一段时间内可以处理或者完成更多的事情。而并行是一种更为严格、理想的并发，即并行可以被看作并发的一个特例。并发往往是带有部分串行的并发，而并发的极致就是并行（Parallel）。

从软件的角度来说，并发就是在一段时间内以交替的方式去完成多个任务，而并行就是以齐头并进的方式去完成多个任务。并发与上述生活种的并发并无本质的区别，不过二者还存在一些差异。首先，现实世界种的一个人可以以并发的方式去完成几件事情，而软件要以并发的方式去完成几个任务往往需要借助多个线程（而不是一个线程）。其次，软件世界中的并发也未必就比串行的处理效率更高或者效率提高得那么明显，这点在本书的后面内容中会体现出来。

从硬件的角度来说，在一个处理器一次只能够运行一个线程的情况下，由于处理器可以使用时间片（Time-slice）分配的技术来实现在同一段时间内运行多个线程，因此一个处理器就可以实现并发。而并行则需要靠多个处理器在同一时刻各自运行一个线程来实现。

多线程编程的实质就是将任务的处理方式由串行改为并发，即实现并发化，以发挥并发的优势。而现实是以并发的方式对任务进行处理的过程也存在一些挑战，这点正是本章后续几节的主题。

如果一个任务的处理方式可以由串行改为并发（或者并行），那么我们就称这个任务是可并发化（或者可并行化）的。但是，有的任务的处理方式则可能必须是串行的。例如，在Java平台中读取一个文件就是串行的。

## 2.2 竞态

多线程编程中经常遇到的一个问题就是对于同样的输入，程序的输出有时候是正确的而有时候却是错误的。这种一个计算结果的正确性与时间有关的现象就被称为竞态（Race Condition）。

### 2.2.1 二维表分析法：解释竞态的结果

> **术语定义**
>
> 状态变量（State Variable）：即类的实例变量、静态变量。
>
> 共享变量（Shared Variable）：即可以被多个线程共同访问的变量。共享变量中的“共享”强调的是“可以被共享”的可能性，因此称呼一个变量为共享变量并不表示该变量一定会被多个线程访问。状态变量由于可以被多个线程共享，因此也被称为共享变量。

可见，nextSequence()是导致上述竞态的直接因素。进一步来说，导致竞态的常见因素是多个线程在没有采取任何控制措施的情况下并发地更新、读取同一个共享变量。nextSequence()所访问的实例变量sequence就是这样一个例子：多个线程（业务线程）通过调用nextSequence()并发地访问sequence，显然这些线程没有采取任何控制措施。

nextSequence() 中的语句“sequence++”看起来像是一个操作，它实际上相当于如下伪代码所代表的3个指令：

~~~java
load(sequence, r1); //指令①：将变量sequence的值从内存读到寄存器r1
increment(r1); //指令②：将寄存器r1的值增加1
store(sequence, r1); //指令③：将寄存器r1的内容写入变量sequence所对应的内存空间
~~~

竞态（Race Condition）是指计算的正确性依赖于相对时间顺序（Relative Timing）或者线程的交错（Interleaving）。根据这个定义可知，竞态不一定就导致计算结果的不正确，它只是不排除计算结果时而正确时而错误的可能。

竞态往往伴随着读取脏数据（Dirty Read）问题，即线程读取到一个过时的数据，丢失更新（Lost Update）问题，即一个线程对数据所做的更新没有体现在后续其他线程对该数据的读取上。而上述的二维表分析法是分析竞态问题的一种简单而有效的方法。

> **注意**
>
> 竞态不一定就导致计算结果的不正确，它只是不排除计算结果时而正确时而错误的可能。

### 2.2.2 竞态的模式与竞态产生的条件

从上述竞态典型实例中我们可以提炼出竞态的两种模式：read-modify-write(读-改-写)和check-then-act（检测而后行动）。

read-modify-write(读-改-写)操作，该操作可以被细分为这样几个步骤：读取一个共享变量的值（read），然后根据该值做一些计算（modify），接着更新该共享变量的值（write）。例如，在清单2-1中，nextSequence()中的“sequence++”就是read-modify-write模式的一个实例。“sequence++”实际上相当于如下伪代码表示的几个指令的组合。

~~~java
load(sequence, r1); //指令①：将变量sequence的值从内存读到寄存器r1（读取共享变量值）
increment(r1); //指令②：将寄存器r1的值增加1（根据共享变量值做一些计算）
store(sequence, r1); //指令③：将寄存器r1的内容写入变量sequence所对应的内存空间（更新共享变量）
~~~

一个线程在执行完指令①之后到开始（或者正在）执行指令②的这段时间内其他线程可能已经更新了共享变量（sequence）的值，这就使得该线程在执行指令②时使用的是共享变量的旧值（读脏数据）。接着，该线程把根据这个旧值计算出来的结果更新到共享变量，而这又使得其他线程对该共享变量所做的更新被“覆盖”，即造成了更新丢失。

check-then-act（检测而后行动）操作，该操作可以被细分为这样几个步骤：读取某个共享变量的值，根据该变量的值决定下一步的动作是什么。例如，在清单2-1中，nextSequence()中的if-else语句就是该模式的一个实例。

~~~java
if (sequence >= 999) { // 子操作①check：检测共享变量的值
    sequence = 0;
} else {
    sequence++;
}
~~~

一个线程在执行完子操作①到开始（或者正在）执行子操作②的这段时间内，其他线程可能已经更新了共享变量的值而使得if语句中的条件变为不成立，那么此时该线程仍然会执行子操作②，尽管这个子操作所需的前提（if语句中的条件）实际上并未成立！读者也可以根据二维表分析法自行分析多个线程并发执行上述代码的时候可能导致丢失更新和脏数据的问题。

从上述分析中我们可以总结出竞态产生的一般条件。设O1和O2是并发访问共享变量V的两个操作，这两个操作并非都是读操作。如果一个线程在执行O1期间（开始执行而未执行结束）另一个线程正在执行O2，那么无论O2是在读取还是更新V都会导致竞态。从这个角度来看，竞态可以被看作访问（读取、更新）同一组共享变量的多个线程所执行的操作相互交错（Interleave），比如一个线程读取共享变量并以该共享变量为基础进行计算的期间另外一个线程更新了该共享变量的值而导致的干扰（读取脏数据）或者冲突（丢失更新）的结果。

对于局部变量（包括形式参数和方法体内定义的变量），由于不同的线程各自访问的是各自的那一份局部变量，因此局部变量的使用不会导致竞态！

synchronized关键字会使其修饰的方法在任一时刻只能够被一个线程执行，这使得该方法涉及的共享变量在任一时刻只能够有一个线程访问（读、写），从而避免了这个方法的交错执行而导致的干扰，这样就消除了竞态。第3章会详细解释synchronized。

## 2.3 线程安全性

一般而言，如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是线程安全（Thread-safe）的，相应的我们称这个类具有线程安全性（Thread Safety）。反之，如果一个类在单线程环境下运作正常而在多线程环境下则无法正常运作，那么这个类就是非线程安全的。因此，一个类如果能够导致竞态，那么它就是非线程安全的；而一个类如果是线程安全的，那么它就不会导致竞态。

使用一个类的时候我们必须先弄清楚这个类是否是线程安全的。因为这关系到我们如何正确使用这些类。Java标准库中的一些类如ArrayList、HashMap和SimpleDateFormat，都是非线程安全的，在多线程环境下直接使用它们可能导致一些非预期的结果，甚至是一些灾难性的结果。比如，多线程环境下多个线程共享同一个HashMap实例（而不采取任何控制措施）可能导致死循环（表现为主机上的某个处理器使用率一直为100%）和内存泄漏（最后可能导致Java虚拟机崩溃）。一般来说，Java标准库中的类在其API文档（JavaDoc）中会说明其是否是线程安全的（没有说明其是否是线程安全的，则可能是也可能不是线程安全的）。

从线程安全的定义上我们不难看出，如果一个线程安全的类在多线程环境下能够正常运作，那么它在单线程环境下也能正常运作。既然如此，那为什么不干脆把所有的类都做成线程安全的呢？是否将一个类做成线程安全的，从某种程度上来说是一个设计上的权衡的结果或决定：一方面，一个类是否需要是线程安全的与这个类预期被使用的方式有关，比如，我们希望一个类总是只能被一个线程独自使用，那么就没有必要将这个类做成线程安全的。其次，把一个类做成线程安全的往往是有额外代价的。

一个类如果不是线程安全的，我们就说它在多线程环境下直接使用存在线程安全问题。线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。

## 2.4 原子性

原子（Atomic）的字面意思是不可分割的（Indivisible）。对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有原子性（Atomicity）。

所谓“不可分割”，其中一个含义是指访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。

设O1和O2是访问共享变量V的两个原子操作，这两个操作并非都是读操作。那么一个线程执行O1期间（开始执行而未执行完毕），其他线程无法执行O2。也就是说，访问同一组共享变量的原子操作是不能能够被交错的，这就排除了一个线程执行一个操作期间另外一个线程读取或者更新该操作所访问的共享变量而导致的干扰（读脏数据）和冲突（丢失更新）的可能。这就是“不可分割”的第二个含义。由此可见，使一个操作具备原子性也就消除了这个操作导致竞态的可能性。

理解原子操作这个概念还需要注意以下两点。

- 原子操作是针对访问共享变量的操作而言的。也就是说，仅涉及局部变量访问的操作无所谓是否是原子的，或者干脆把这一类操作都看成原子操作。
- 原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多线程环境下有意义。换言之，单线程环境下一个操作无所谓是否具有原子性，或者我们干脆把这一类操作都看成原子操作。

> **提示**
>
> 原子操作多线程环境下的一个概念，它是针对访问共享变量的操作而言的。原子操作的“不可分割”包括以下两层含义。
>
> - 访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。
> - 访问同一组共享变量的原子操作是不能够被交错的。

总的来说，Java中有两种方式来实现原子性。一种是使用锁（Lock）。锁具有排他性，即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的专门CAS（Compare-and-Swap）指令，CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件（处理器和内存）这一层次实现的，它可以被看作“硬件锁”。

在Java语言中，long型和double型以外的任何类型的变量的写操作都是原子操作，即对基础类型（long/double除外，仅包括byte、boolean、short、char、float和int）的变量和引用型变量的写操作都是原子的。这点由Java语言规范（JLS，Java Language Specification）规定，由Java虚拟机具体实现。

对long/double型变量的写操作由于Java语言规范并不保障其具有原子性，因此在多个线程并发访问同一long/double型变量的情况下，一个线程可能会读取到其他线程更新该变量的“中间结果”。

尽管如此，Java语言规范特别地规定对于volatile关键字修饰的long/double型变量的写操作具有原子性。因此，我们只需要用volatile关键字修饰清单2-6中的共享变量value，就可以保障对该变量的写操作的原子性。

volatile关键字仅能够保障变量写操作的原子性，它并不能保障其他操作（比如read-modify-write操作和check-then-act操作）的原子性。第3章会进一步介绍该关键字。

Java语言中针对任何变量的读操作都是原子操作。

从原子操作的“不可分割”特性可知，使一个操作具有原子性就可以消除该操作导致竞态的可能性。因此，我们可以将read-modify-write操作和check-then-act操作转换为原子操作来消除竞态。

竞态模式中的read-modify-write操作本身不是原子操作，但是我们可以使用Java语言提供的机制使其具有原子性。例如，synchronized关键字

竞态模式中的check-then-act操作本身不是原子操作。同样地，我们也可以使用与将read-modify-write操作转换为原子操作同样的方法将这种操作转换为原子操作，即使其具有原子性。

## 2.5 可见性

# 第3章 Java线程同步机制

## 3.3 内部锁：synchronized关键字

Java平台中的任何一个对象都有唯一一个与之关联的锁。这种锁被称为监视器（Monitor）或者内部锁（Intrinsic Lock）。内部锁是一种排他锁，它能够保障原子性、可见性和有序性。

内部锁是通过synchronized关键字实现的。synchronized关键字可以用来修饰方法以及代码块（花括号“{}”包裹的代码）。

synchronized关键字修饰的方法就被称为**同步方法**（Synchronized Method）。synchronized修饰的静态方法就称为**同步静态方法**，synchronized修饰的实例方法就被称为**同步实例方法**。同步方法的整个方法体就是一个临界区。

synchronized关键字修饰的代码块被称为**同步块**（Synchronized Block），其语法如下所示：

~~~java
synchronized(锁句柄) {
    // 在此代码块中访问共享数据
}
~~~

synchronized关键字所引导的代码块就是临界区。**锁句柄**是一个对象的引用（或者能够返回对象的表达式）。例如，锁句柄可以填写为this关键字（表示当前对象）。习惯上我们也直接称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的**引导锁**。相应地，我们称呼相应的同步块为该**锁引导的同步块**。

同步实例方法相当于以“this”为引导锁的同步块。

作为锁句柄的变量通常采用final修饰。这是因为锁句柄变量的值一旦改变，会导致执行同一个同步块的多个线程实际上使用不同的锁，从而导致竞态。有鉴于此，通常我们会使用private修饰作为锁句柄的变量。

> **注意**
>
> 作为锁句柄的变量通常采用private final修饰，如：private final Object lock = new Object();

同步静态方法相当于以当前类对象（Java中的类本身也是一个对象）为引导锁的同步块。例如同步静态方法：

~~~java
public class SynchronizedMethodExample{
    public static synchronized void staticMethod() {
        // 在此访问共享数据
    }
    // ...
}
~~~

相当于

~~~java
public class SynchronizedMethodExample{
    public void staticMethod() {
        synchronized (SynchronizedMethodExample.class){
	        // 在此访问共享数据
    	}
    }
    // ...
}
~~~

线程在执行临界区代码的时候必须持有该临界区的引导锁。一个线程执行到同步块（同步方法也看作同步块）时必须先申请该同步块的引导锁，只有申请成功（获得）该锁的线程才能够执行相应的临界区。一个线程执行完临界区代码后引导该临界区的锁就会被自动释放。在这个过程中，线程对内部锁的申请与释放的动作由Java虚拟机负责代为实施，这也正是synchronized实现的锁被称为内部锁的原因。

内部锁的使用并不会导致锁泄漏。这是因为Java编译器（javac）在将同步块代码编译为字节码的时候，对临界区中可能抛出的而程序代码中又未捕获的异常进行了特殊（代为）处理，这使得临界区的代码即使抛出异常也不会妨碍内部锁的释放。

### 内部锁的调度

Java虚拟机会为每个内部锁分配一个入口集（Entry Set），用于记录等待获得相应内部锁的线程。多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程（即申请锁的操作成功），而其他申请者的申请操作会失败。这些申请失败的线程并不会抛出异常，而是会被暂停（生命周期状态变为BLOCKED）并被存入相应锁的入口集中等待再次申请锁的机会。入口集中的线程就被称为相应内部锁的等待线程。当这些线程申请的锁被其持有线程释放的时候，该锁的入口集中的一个任意线程会被Java虚拟机唤醒，从而得到再次申请锁的机会。由于Java虚拟机对内部锁的调度仅支持非公平调度，被唤醒的等待线程占用处理器运行时可能还有其他新的活跃线程（处于RUNNABLE状态，且未进入过入口集）与该线程抢占这个被释放锁，因此被唤醒的线程不一定就能成为该锁的持有线程。另外，Java虚拟机如何从一个锁的入口集中选择一个等待线程，作为下一个可以参与再次申请相应锁的线程，这个细节与Java虚拟机的具体实现有关：这个被选中的线程有可能是入口集中等待时间最长的线程，也可能是等待时间最短的线程，或者完全是随机的一个线程。因此，我们不能依赖这个具体的选择算法。

# 第4章 牛刀小试：玩转线程

## 4.5 合理设置线程数

在本章的第一个案例中，工作者线程的数量是通过程序的参数指定的。线程数不宜过小，线程数过小可能导致无法充分利用处理器资源；线程数也不宜过大，线程数过大会增加上下文切换以及其他开销。那么，我们如何设置一个合理的线程数呢？在回答这个问题之前，我们先看一下线程数与多线程程序相对于单线程程序的提速（Speedup）之间的关系。

### 4.5.1 Amdahl's定律

Amdahl's定律（Amdahl's Law）描述了线程数与多线程程序相对于单线程程序的提速之间的关系。在一个处理器上一个时刻只能够运行一个线程的情况下，处理器的数量就等同于并行线程的数量。设处理器的数量为N，程序中必须串行（即无法并发化）的部分耗时占程序全部耗时的比率为P，那么将这样一个程序改为多线程程序，我们能够获得的理论上的最大提速$S_{max}$与N、P之间的关系就是Amdahl's 定律内容，如下4-2所示。
$$
S_{max} = \frac{1}{P+\frac{1-P}{N}}
$$
了解该公式的推导过程有助于我们更好地理解多线程编程的本质。我们知道，一个程序的算法中有些部分是可以并行化的，而有些部分则只能够是串行的。设P为这个程序的串行部分的耗时比率，T(1)为该程序的单线程版运行总耗时，T(N)为该程序的多线程版运行总耗时，那么将该程序由单线程改为多线程所得到的提速$S_{max}$可以表示为：
$$
S_{max} = \frac{T(1)}{T(N)}
$$
为方便起见，设T(1)为1，则该程序中的串行部分耗时为P，可并行部分耗时为1-P。将这个程序改为多线程程序的时候，该程序的可并行部分耗时会被N个并行线程平均分摊，因此该程序的多线程版的并行部分总耗时为(1-P)/N（串行部分仍然是P！）。由此，我们可以得出T(N) = P + (1-P)/N。将 T(N) 及 T(1) = 1 代入式（4-2）即可得到Amdahl‘s 定律的公式表示。

从上述推导过程可以看出，多线程程序的提速主要来自多个线程对程序中可并行化部分的耗时均摊。

由Amdahl's定律的公式可知：
$$
\lim_{N\rightarrow\infty} S_{max} = \lim_{N\rightarrow\infty} \frac{1}{P+\frac{1-P}{N}} = \frac{1}{P}
$$
即当N趋向于无穷大的时候，$S_{max}$趋向于1/P。由此可见，最终决定多线程程序提速的因素是整个计算中串行部分的耗时比率P，而不是线程数N！P的值越大，即程序中不可并行化的部分所占比率越大，那么提速越小。因此，为使多线程程序能够获得较大的提速，我们应该从算法入手，减少程序中必须串行的部分，而不是仅寄希望于增加线程数（或者处理器的数目）！

### 4.5.2 线程数设置的原则

设$N_{cpu}$表示一个系统的处理器数目，$N_{cpu}$的具体值可以通过如下Java代码获取：

~~~java
int nCPU = Runtime.getRuntime().availableProcessors();
~~~

线程数的合理值可以根据如下规则设置。

- 对于CPU密集型线程，考虑到这类线程执行任务时消耗的主要是处理器资源，我们可以将这类线程的线程数设置为$N_{cpu}$个。因为CPU密集型线程也可能由于某些原因（比如缺页中断/Page Fault）而被切出，此时为了避免处理器资源浪费，我们也可以为这类线程设置一个额外的线程，即将线程数设置为$N_{cpu}+1$。
- 对于I/O密集型线程，考虑到I/O操作可能导致上下文切换，为这样的线程设置过多的线程数会导致过多的额外系统开销。因此如果一个这样的工作者线程就足以满足我们的要求，那么就不要设置更多的线程数。例如，在本章的第2个实战案例中我们仅使用一个工作者线程去负责所有日志文件的读取。如果一个工作者线程仍然不够用，那么我们可以考虑将这类线程的数量设置为$2 \times N_{cpu}$。这是因为I/O密集型线程在等待I/O操作返回结果时是不占用处理器资源的，因此我们可以为每个处理器安排一个额外的线程以提高处理器资源的利用率。

> **提示**
>
> 对于CPU密集型线程，线程数通常可以设置为$N_{cpu}+1$；对于I/O密集型线程，优先考虑将线程数设置为1，仅在一个线程不够用的情况下将线程数向$2\times N_{cpu}$靠近。

商用软件往往会规定某个软件在其运行过程中对处理器的使用率不能超过某个阈值（如75%）。因此，如果要进一步“精确”地设置线程数，我们可能需要考虑目标处理器使用率，即我们期望软件运行过程中会保持多少平均CPU使用率。另外，如果任务本身是混合型而不太好将其拆分成CPU密集型和I/O密集型地子任务的话，也可以考虑不拆分。此时，我们可以参考式（4-5）来设置线程数：
$$
N_{threads} = N_{cpu} \times U_{cpu} \times (1+\frac{WT}{ST})
$$
其中，$N_{threads}$为线程数的合理大小，$N_{cpu}$为CPU数目，$U_{cpu}$为目标CPU使用率（$0 \lt U_{cpu} \leq 1$），WT（Wait Time）为程序花费在等待（例如等待I/O操作结果）上的时长，ST（Service Time）为程序实际占用处理器执行计算的时长。在实践中，我们可以使用jvisualvm提供的监控数据计算出WT/ST的值。

# 第5章 线程间协作

## 5.1 等待与通知：wait/notify

一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为**等待**（Wait）。一个线程更新系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为**通知**（Notify）。

### 5.1.1 wait/notify的作用与用法

在Java平台中，Object.wait()/Object.wait(long) 以及 Object.notify()/Object.notifyAll() 可用于实现等待和通知：Object.wait()的作用是使其执行线程被暂停（其生命周期状态变更为WAITING），该方法可用来实现等待；Object.notify()的作用使唤醒一个被暂停的线程，调用该方法可实现通知。相应地，Object.wait()的执行线程就被称为**等待线程**；Object.notify()的执行线程就被称为**通知线程**。由于Object类是Java中任何对象的父类，因此使用Java中的任何对象都能够实现等待与通知。

使用Object.wait()实现等待，其代码模板如下伪代码所示：

~~~java
//在调用wait方法前获得相应对象的内部锁
synchronized(someObject) {
    while(保护条件不成立) {
        //调用Object.wait()暂停当前线程
        someObject.wait();
    }
    
    // 代码执行到这里说明保护条件已经满足
    // 执行目标动作
    doAction();
}
~~~

其中，保护条件是一个包含共享变量的布尔表达式。当这些共享变量被其他线程（通知线程）更新之后使相应的保护条件得以成立时，这些线程会通知等待线程。由于一个线程只有在持有一个对象的内部锁的情况下才能够调用该对象的wait方法，因此Object.wait()调用总是放在相应对象所引导的临界区之中。包含上述模板代码的方法被称为**受保护方法**（Guarded Method）。受保护方法包括3个要素：保护条件、暂停当前线程和目标动作。

设someObject为Java中任意一个类的实例，因执行someObject.wait()而被暂停的线程就称为对象someObject上的**等待线程**。由于同一个对象的同一个方法（someObject.wait()）可以被多个线程执行，因此一个对象可能存在多个等待线程。someObject上的等待线程可以通过其他线程执行someObject.notify()来唤醒。someObject.wait()会以原子操作的方式使其执行线程（当前线程）暂停并使该线程释放其所持有的someObject对应的内部锁。当前线程被暂停的时候其对someObject.wait()调用并未返回。其他线程在该线程所需的保护条件成立的时候执行相应的notify方法，即someObject.notify()可以唤醒someObject上的一个（任意的）等待线程。被唤醒的等待线程在其占用处理器继续运行的时候，需要再次申请someObject对应的内部锁。被唤醒的线程在其再次持有someObject对应的内部锁的情况下继续执行someObject.wait()中剩余的指令，直到wait方法返回。

等待线程只在保护条件不成立的情况下才执行Object.wait()进行等待，即在执行Object.wait()前我们需要判断保护条件是否成立（当然，此时保护条件也是有可能成立的）。另外，等待线程在其被唤醒，继续运行到其再次持有相应对象的内部锁的这段时间内，由于其他线程可能抢先获得相应的内部锁并更新了相关共享变量而导致该线程所需的保护条件再次不成立，因此Object.wait()调用返回之后，我们需要再次判断此时保护条件是否成立。所以，对保护条件的判断以及Object.wait()调用应该放在循环语句之中，以确保目标动作只有在保护条件成立的情况下才能够执行！

另外，等待线程对保护条件的判断以及目标动作的执行必须是一个原子操作，否则可能产生静态——目标动作被执行前的那一刻其他线程对共享变量的更新又使得保护条件重新不成立。因此，目标动作的执行必须和保护条件的判断以及Object.wait()调用放在同一个对象所引导的临界区中。

> **注意**
>
> - 等待线程对保护条件的判断、Object.wait()的调用总是应该放在相应对象所引导的临界区中的一个循环语句之中。
> - 等待线程对保护条件的判断、Object.wait()的执行以及目标动作的执行必须放在同一个对象（内部锁）所引导的临界区之中。
> - Object.wait()暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显式锁并不会因此被释放。

使用Object.notify()实现通知，其代码模板如下伪代码所示：

~~~java
synchronized (someObject) {
    // 更新等待线程的保护条件涉及的共享变量
    updateSharedState();
    // 唤醒其他线程
    someObject.notify();
}
~~~

包含上述模板代码的方法被称为通知方法，它包含两个要素：更新共享变量、唤醒其他线程。由于一个线程只有在持有一个对象的内部锁的情况下才能够执行该对象的notify方法，因此Object.notify()调用总是放在相应对象内部锁所引导的临界区之中。也正是由于Object.notify()要求其执行线程必须持有该方法所属对象的内部锁，因此Object.wait()在暂停其执行线程的同时必须释放相应的内部锁；否则通知线程无法获得相应的内部锁；否则通知线程无法获得相应的内部锁，也就无法执行相应对象的notify方法来通知等待线程！Object.notify()的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，而Object.notify()本身并不会将这个内部锁释放。因此，为了使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们要尽可能地将Object.notify()调用放在靠近临界区结束的地方。等待线程被唤醒之后占用处理器继续运行时，如果有其他线程持有了相应对象的内部锁，那么这个等待线程可能又会再次被暂停，以等待再次获得相应内部锁的机会，而这会导致上下文切换。

调用Object.notify()所唤醒的线程仅是相应对象上的一个任意等待线程，所以这个被唤醒的线程可能不是我们想要唤醒的那个线程。因此，有时候我们需要借助Object.notify()的兄弟——Object.notifyAll()，它可以唤醒相应对象上的所有等待线程。由于等待线程和通知线程在其实现等待和通知的时候必须是调用同一个对象的wait方法、notify方法，而这两个方法都要求其执行线程必须持有该方法所属对象的内部锁，因此等待线程和通知线程是同步在同一对象之上的两种线程。

> **注意**
>
> 等待线程和通知线程必须调用同一个对象的wait方法、notify方法来实现等待和通知。调用一个对象的notify方法所唤醒的线程仅是该对象上的一个任意等待线程。notify方法调用应该尽可能地放在靠近临界区结束的地方。

> **扩展阅读** Object.wait()/notify()的内部实现
>
> 我们知道Java虚拟机会为每个对象维护一个入口集（Entry Set）用于存储申请该对象内部锁的线程。此外，Java虚拟机还会为每个对象维护一个被称为等待集（Wait Set）的队列，该队列用于存储该对象上的等待线程。Object.wait()将当前线程暂停并释放相应内部锁的同时会将当前线程（的引用）存入该方法所属对象的等待集中。执行一个对象的notify方法会使该对象的等待集中的一个任意线程被唤醒。被唤醒的线程仍然会停留在相应对象的等待集之中，直到该线程再次持有相应内部锁的时候（此时Object.wait()调用尚未返回）Object.wait()会使当前线程从其所在的等待集移除，接着Object.wait()调用就返回了。Object.wait()/notify()实现的等待/通知中的几个关键动作，包括将当前线程加入等待集、暂停当前线程、释放锁以及将唤醒后的等待线程从等待集中移除等，都是在Object.wait()中实现的。Object.wait()的部分内部实现相当于如下伪代码：
>
> ~~~java
> public void wait() {
>     // 执行线程必须持有当前对象对应的内部锁
>     if(!Thread.holdsLock(this)){
>         throws new IllegalMonitorStateException();
>     }
>     
>     if(当前线程不在等待集中){
>         // 将当前线程加入当前对象的等待集中
>         addToWaitSet(Thread.currentThread());
>     }
>     
>     atomic {
>         // 原子操作开始
>         // 释放当前对象的内部锁
>         releaseLock(this);
>         // 暂停当前线程
>         block(Thread.currentThread()); // 语句①
>         // 原子操作结束
>     }
>     
>     // 再次申请当前对象的内部锁
>     aquireLock(this); // 语句②
>     // 将当前线程从当前对象的等待集中移除
>     removeFromWaitSet(Thread.currentThread());
>     return; // 返回
> }
> ~~~
>
> 等待线程在语句①被执行之后就被暂停了。被唤醒的线程在其占用处理器继续运行的时候会继续执行其暂停前调用的Object.wait()中的其他指令，即从上述代码中的语句②开始继续执行：先再次申请Object.wait()所属对象的内部锁，接着将当前线程从相应的等待集中移除，然后Object.wait()调用才返回！

### 5.1.2 wait/notify的开销及问题

下面我们看wait/notify实现的等待/通知时可能遇到的问题及其解决方法。

- 过早唤醒（Wakeup too soon）问题。设一组等待/通知线程同步在对象someObject之上，初始状态下所有保护条件都不成立。接着，线程N1更新了共享遍历state1使得保护条件1得以成立，此时为了唤醒使用该保护条件的所有等待线程（线程W1和线程W2），N1执行了someObject.notifyAll()。由于someObject.notifyAll()唤醒的是someObject上的所有等待线程，因此这时线程W2也会被唤醒。然而W2所使用的保护条件2此时并没有成立，这就使得该线程被唤醒之后仍然需要继续等待。这种等待线程在其所需的保护条件并未成立的情况下被唤醒的现象就被称为过早唤醒（Wakeup too soon）。过早唤醒使得那些本来无须被唤醒的等待线程也被唤醒了，从而造成资源浪费。过早唤醒问题可以利用JDK 1.5 引入的java.util.concurrent.locks.Condition 接口来解决，5.2节会介绍该接口。
- 信号丢失（Missed Signal）问题。如果等待线程在执行Object.wait() 前没有先判断保护条件是否已然成立，那么有可能出现这种情形——通知线程在该等待线程进入临界区之前就已经更新了相关共享变量，使得相应的保护条件成立并进行了通知，但是此时等待线程还没有被暂停，自然也就无所谓唤醒了。这就可能造成等待线程直接执行Object.wait()而被暂停的时候，该线程由于没有其他线程进行通知而一直处于等待状态。这种现象就相当于等待线程错过了一个本来“发送”给他的“信号”，因此被称为**信号丢失**（Missed Signal）。只要将对保护条件的判断和Object.wait()调用放在一个循环语句之中就可以避免上述场景的信号丢失。信号丢失的另外一个表现在应该调用Object.notify()的地方却调用了Object.notify()。比如，对于使用同一个保护条件的多个等待线程，如果通知线程在侦测到这个保护条件成立后调用的是Object.notify()，那么这些等待线程最多只有一个线程能够被唤醒，甚至一个也没有被唤醒——被唤醒的线程是Object.notify()所属对象上使用其他保护条件的一个等待线程！也就是说，尽管通知线程在调用Object.notify()前可能考虑（判断）了某个特定的保护条件是否成立，但是Object.notify()本身在其唤醒线程时是不考虑任何保护条件的！这就可能使得通知线程执行Object.notify()进行的通知对于使用相应保护条件的等待线程来说丢失了。这种情形下，避免信号丢失的一个方法是在必要的时候使用Object.notifyAll()来通知。总的来说，信号丢失本质上是一种代码错误，而不是Java标准库API自身的问题。
- 欺骗性唤醒（Spurious Wakeup）问题。等待线程也可能在没有其他任何线程执行Object.notify()/notifyAll() 的情况下被唤醒。这种现象被称为**欺骗性唤醒**（Spurious Wakeup）。由于欺骗性唤醒的作用，等待线程被唤醒的时候该线程所需的保护条件可能仍然未成立，因为此时没有任何线程对相对共享变量进行过更新。可见，欺骗性唤醒也会导致过早唤醒。欺骗性唤醒虽然在实践中出现的概率非常低，但是由于操作系统是允许这种现象产生的，因此 Java 平台同样也允许这种现象的存在。欺骗性唤醒是Java平台对操作系统妥协的一种结果。只要我们将对保护条件的判断和Object.wait() 调用行放在一个循环语句之中，欺骗性唤醒就不会对我们造成实际的影响。
  欺骗性唤醒和信号丢失问题的规避方法前文已经提及：将等待线程对保护条件的判断、Object.wait()的调用放在相应对象所引导的临界区中的一个循环语句之中即可。
- 上下文切换问题。wait/notify的使用可能导致较多的上下文切换。
  - 首先，等待线程执行Object.wait() 至少会导致该线程对相应对象内部锁的两次申请与释放。通知线程在执行Object.notify()/notifyAll() 时需要持有相应对象的内部锁，因此 Object.notify()/notifyAll() 调用会导致一次锁的申请。而锁的申请与释放可能导致上下文切换。
  - 其次，等待线程从被暂停到唤醒这个过程本身就会导致上下文切换。
  - 再次，被唤醒的等待线程在继续运行时需要再次申请相应对象的内部锁，此时等待线程可能需要和相应对象的入口集中的其他线程以及其他新来的活跃线程（即申请相应的内部锁且处于RUNNABLE状态的线程）争用相应的内部锁，而这又可能导致上下文切换。
  - 最后，过早唤醒问题也会导致额外的上下文切换，这是因为被过早唤醒的线程仍然需要继续等待，即再次经历被暂停和唤醒的过程。

以下方法有助于避免或者减少 wait/notify 导致过多的上下文切换。

- 在保证程序正确性的前提下（5.1.3节会介绍），使用Object.notify() 替代 Object.notifyAll()。Object.notify()调用不会导致过早唤醒，因此减少了相应的上下文切换开销。
- 通知线程在执行完 Object.notify()/notifyAll() 之后尽快释放相应的内部锁。这样可以避免被唤醒的线程在 Object.wait() 调用返回前再次申请相应内部锁时，由于该锁尚未被通知线程释放而导致该线程被暂停（以等待再次获得锁的机会）。

### 5.1.3 Object.notify()/notifyAll()的选用

Object.notify() 可能导致信号丢失这样的正确性问题，而 Object.notifyAll() 虽然效率不太高（把不需要唤醒的等待线程也给唤醒了），但是其在正确性方面有保障。因此实现通知的一种比较流行的保守性方法是优先使用 Object.notifyAll() 以保障正确性，只有在有证据表明使用Object.notify()足够的情况下才使用Object.notify()——Object.notify() 只有在下列条件全部满足的情况下才能够用于替代notifyAll方法。

**条件1** 一条通知仅需要唤醒至多一个线程。这一点容易理解，但是光满足这一点还不足以用Object.notify() 去替代 Object.notifyAll()。在不同的等待线程可能使用不同的保护条件的情况下，Object.notify() 唤醒的一个任意线程可能并不是我们需要唤醒的那一个（种）线程。因此，这个问题还需要通过满足条件2来排除。

**条件2** 相应对象的等待集中仅包含同质等待线程。所谓**同质等待线程**指这些线程使用同一个保护条件，并且这些线程在Object.wait() 调用返回之后的处理逻辑一致。最为典型的同质线程是使用同一个Runnable接口实例创建的不同线程（实例）或者从同一个Thread子类的new出来的多个实例。

> **注意**
>
> Object.notify()唤醒的是其所属对象上的一个任意等待线程。Object.notify() 本身在唤醒线程时是不考虑保护条件的。 Object.notifyAll() 方法唤醒的是其所属对象上的所有等待线程。使用Object.notify() 替代 Object.notifyAll() 时需要确保以下两个条件同时得以满足：
>
> - 一次通知仅需要唤醒至多一个线程。
> - 相应对象上的所有等待线程都是同质等待线程。

### 5.1.4 wait/notify 与 Thread.join()

Thread.join() 可以使当前线程等待目标线程结束之后才继续运行。Thread.join()还有另外一个如下声明的版本：

~~~java
public final void join(long millis) throws InterruptedException
~~~

join(long) 允许我们指定一个超时时间。如果目标线程没有在指定的时间内终止，那么当前线程也会继续运行。join(long) 实际上就是使用了 wait/notify 来实现的，如下所示：

~~~java
public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;
    
    if(millis < 0){
        throw new illegalArgumentException("timeout value is negative");
    }
    
    if(millis == 0){
        while(isAlive()){
            wait(0);
        }
    } else {
        while(isAlive()){
            long delay = millis - now;
            if(delay <= 0){
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
~~~

join(long) 是一个同步方法。它检测到目标线程未结束的时候会调用 wait 方法来暂停当前线程，直到目标线程已终止。这里，当前线程相当于等待线程，其所需的保护条件是“目标线程已终止”（Thread.isAlive()为false）。Java虚拟机会在目标线程的run方法运行结束后执行该线程（对象）的notifyAll方法来通知所有的等待线程。可见这里的目标线程充当了同步对象的角色，而Java虚拟机中notifyAll方法的执行线程则是通知线程。另外，join(long)正是按照清单5-2所展示的实现等待超时空控制的方法来使用 wait(long) 方法的。

Thread.join() 调用相当于 Thread.join(0) 调用。

## 5.2 Java条件变量

总的来说，Object.wait()/notify()过于底层，并且还存在过早唤醒问题以及Object.wait(long)无法区分其返回是由于等待超时还是被通知线程唤醒等问题。但是，了解wait/notify 有助于我们理解和维护现有系统，以及学习和使用JDK 1.5 中引入的新的标准库类 java.util.concurrent.locks.Condition 接口。

Condition接口可作为wait/notify的替代品来实现等待/通知，它为解决过早唤醒问题提供了支持，并解决了Object.wait(long) 不能区分其返回是否是由等待超时而导致的问题。Condition接口定义的await方法、signal方法和signalAll方法分别相当于Object.wait()、Object.notify() 和 Object.notifyAll()。

Lock.newCondition() 的返回值就是一个Condition实例，因此调用任意一个显式锁实例的newCondition 方法可以创建一个相应的Condition接口。Object.wait()/notify()要求其执行线程持有创建该Condition实例的显式锁。Condition实例也被称为**条件变量**（Condition Variable）或者**条件队列**（Condition Queue），每个Condition实例内部都维护了一个用于存储等待线程的队列（等待队列）。设 cond1 和 cond2 是两个不同的Condition实例，一个线程执行cond1.wait()会导致其被暂停（线程生命周期状态变更为WAITING）并被存入cond1的等待队列。cond1.signal() 会使 cond1 的等待队列中的一个任意线程被唤醒。cond1.signalAll()会使cond1的等待队列中的所有线程被唤醒，而cond2的等待队列中的任何一个线程不受此影响。

Condition接口的使用方法与wait/notify 的使用方法相似，如下代码模板所示：

~~~java
class ConditionUsage {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    public void aGuaredMethod() throws InterruptedException {
        lock.lock();
        try {
            while (保护条件不成立) {
                condition.await();
            }
            // 执行目标动作
            doAction();
        } finally {
            lock.unlock();
        }
    }
    
    private void doAction() {
        // ...
    }
    
    public void anNotificationMethod() throws InterruptedException {
        lock.lock();
        try {
            // 更新共享变量
            changeState();
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
    
    private void changeState() {
        // ...
    }
}
~~~

可见，Condition.await()/signal() 的执行线程需要持有创建相应条件变量的显式锁。对保护条件的判断、Condition.await()的调用也同样放在一个循环语句之中，并且该循环语句与目标动作的执行放在同一个显示锁所引导的临界区之中，这同样也是考虑到了欺骗性唤醒问题、信号丢失问题。Condition.await() 与 Object.wait() 类似，它使当前线程暂停的同时也使当前线程释放其持有的相应显式锁，并且这时 Condition.await() 调用也同样未返回。被唤醒的等待线程继续运行的时候也需要再次申请相应的显式锁，被唤醒的等待线程再次获得相应的显式锁后 Condition.await() 调用才返回。上述模板代码中的 aGuaredMethod 方法是一个受保护方法，anNotificationMethod 方法是一个通知方法。

应用代码是这样解决过早唤醒问题的：在应用代码这一层次上建立保护条件与条件变量之间的对应关系，即让使用不同保护条件的等待线程调用不同的条件变量的await方法来实现其等待；并让通知线程在更新了共享变量之后，仅调用涉及了这些共享变量的保护条件所对应的条件变量的signal/signalAll 方法来实现通知。

> **注意**
>
> Condition接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量之间的对应关系，即使用不同的保护条件的等待线程需要调用不同的条件变量的await方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的signal/signalAll 方法来实现通知。

Condition接口还解决了 Object.wait(long) 存在的问题 —— Object.wait(long) 无法区分其返回是由于等待超时还是被通知的。 Condition.awaitUtil(Date deadline) 可以用于实现带超时时间限制的等待，并且该方法的返回值能够区分该方法调用是由于等待超时而返回还是由于其他线程执行了相应条件变量的signal/signalAll方法而返回。Condition.awaitUtil(Date deadline)的唯一参数 deadline 表示等待的最后期限（Deadline）。过了这个时间点就算等待超时。Condition.awaitUtil(Date) 返回值 true表示进行的等待尚未达到最后期限，即此时方法的返回是由于其他线程执行了相应条件变量的signal/signalAll 方法。由于Condition.await()/awaitUtil(Date) 与 Object.wait() 类似，等待线程因执行Condition.awaitUtil(Date) 而被暂停的同时，其持有的相应显式锁（即创建相应条件变量的显式锁）也会被释放，等待线程被唤醒之后得以继续运行时需要再次申请相应的显式锁，然后等待线程对Condition.await()/awaitUtil(Date) 的调用才能够返回。在等待线程被唤醒到其再次申请相应的显式锁的这段时间内，其他线程（或者通知线程本身）可能已经抢先获得相应的显式锁并在其临界区中更新了相应共享变量而使得等待线程所需的保护条件重新不成立。因此，Condition.awaitUtil(Date) 返回 true（等待未超时）的情况下我们可以选择继续等待，如清单5-3所示。

~~~java
public class TimeoutWaitWithCondition {
    private static final Lock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();
    private static boolean ready = false;
    protected static final Random random = new Random();
    
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread() {
            @Override
            public void run() {
                for (;;) {
                    lock.lock();
                    try {
                        ready = random.nextInt(100) < 5 ? true : false;
                        if (ready) {
                            condition.signal();
                        }
                    } finally {
                        lock.unlock();
                    }
                    
                    // 使当前线程暂停一段（随机）时间
                    Tools.randomPause(500);
                } // for 循环结束
            }
        };
        t.setDaemon(true);
        t.start();
        waiter(1000);
    }
    
    public static void waiter(final long timeOut) throws InterruptedException {
        if (timeOut < 0) {
            throw new IllegalArgumentException();
        }
        // 计算等待的最后期限
        final Date deadline = new Date(System.currentTimeMillis() + timeOut);
        // 是否继续等待
        boolean continueToWait = true;
        lock.lock();
        try {
            while (!ready) {
                Debug.info("still not ready, continue to wait:%s", continueToWait);
                // 等待未超时，继续等待
                if (!continueToWait) {
                    // 等待超时退出
                    Debug.error("Wait timed out, unable to execution target action!");
                    return;
                }
                continueToWait = condition.awaitUtil(deadline);
            } // while 循环结束
            
            // 执行目标动作
            guarededAction();
        } finally {
            lock.unlock();
        }
    }
    
    private static void guarededAction() {
        Debug.info("Take some action.");
        // ...
    }
}
~~~

在上述代码中，我们根据系统当前时间和等待超时时间限制（timeOut）来计算出等待的最后期限（deadline）,并以此为参数去调用Condition.awaitUtil(Date)。这里Condition.awaitUtil(Date) 调用与 Condition.await() 调用一样，也要放在一个循环语句之中。如果 Condition.awaitUtil(Date) 调用返回 false（表示等待超时），那么等待方法就直接返回，否则等待方法可以继续等待。

使用条件变量所产生的开销与wait/notify 方法基本相似；不过由于条件变量的使用可以避免过早唤醒问题，因此其使用导致的上下文切换要比 wait/notify 少一些。

## 5.3 倒计时协调器：CountDownLatch

Thread.join() 实现的是一个线程等待另外一个线程结束。有时候一个线程可能只需要等待其他线程执行的特定操作结束即可，而不必等待这些线程终止。当然，此时我们也可以使用条件变量来实现。不过，此时我们可以使用更加直接的工具类——java.util.concurrent.CountDownLatch。

CountDownLatch 可以用来实现一个（或者多个）线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为**先决操作**。

CountDownLatch 内部会维护一个用于表示未完成的先决操作数量的计数器。CountDownLatch.countDown()每被执行一次就会使相应实例的计数器值减少1。CountDownLathc.await() 相当于一个受保护方法，其保护条件为“计数器值为0”（代表所有先决操作已执行完毕），目标操作是一个空操作。因此，当计数器值不为0时 CountDownLatch.await() 的执行线程会被暂停，这些线程就被称为相应 CountDownLatch 上的等待线程。CountDownLatch.countDown() 相当于一个通知方法，它会在计数器值达到 0 的时候唤醒相应实例上的所有等待线程。计数器的初始值是在CountDownLatch的构造参数中指定的，如下声明所示：

~~~java
public CountDownLatch(int count)
~~~

count 参数用于表示先决操作的数量或者需要被执行的次数。当计数器的值达到 0 之后，该计数器的值就不再发生变化。此时，调用CountDownLatch.countDown() 并不会导致异常的抛出，并且后续执行 CountDownLatch.await()的线程也不会被暂停。因此，CountDownLatch的使用是一次性的：一个CountDownLatch实例只能够实现一次等待和唤醒。

可见，CountDownLatch内部封装了对“全部先决操作已执行完毕”（计数器值为0）这个保护条件的等待与通知逻辑，因此客户端代码在使用CountDownLatch实现等待/通知的时候调用await、countDown方法都无须加锁。

~~~java
public class ServerStarter {
    public static void main(String[] args) {
        // 省略其他代码
        
        // 启动所有服务
        ServiceManager.startServices();
        
        // 执行其他操作
        
        // 在所有其他操作执行结束后，检查服务启动状态
        boolean allIsOK;
        // 检测全部服务的启动状态
        allIsOK = ServiceManager.checkServiceStatus();
        
        if (allIsOK) {
            System.out.println("All services were successfully started!");
            // 省略其他代码
        } else {
            // 个别服务启动失败，退出JVM
            System.err.println("Some service(s) failed to start, exiting JVM...");
            System.exit(1);
        }
        // ...
    }
}
~~~

~~~java
public class ServiceManager {
    static volatile CountDownLatch latch;
    static Set<Service> services;
    
    public static void startServices() {
        services = getServices();
        for(Service service: services) {
            service.start();
        }
    }
    
    public static boolean checkServiceStatus() {
        boolean allIsOK = true;
        // 等待服务启动结束
        try {
            latch.await();
        } catch (InterruptedException e) {
            return false;
        }
        
        for (Service service : services){
            if(!service.isStarted()){
                allIsOK = false;
                break;
            }
        }
        
        return allIsOK;
    }
    
    static Set<Service> getServices() {
        // 模拟实际代码
        latch = new CountDownLatch(3);
        HashSet<Service> servicesSet = new HashSet<Service>();
        servicesSet.add(new SampleServiceC(latch));
        servicesSet.add(new SampleServiceA(latch));
        servicesSet.add(new SampleServiceB(latch));
        return servicesSet;
    }
}
~~~

~~~java
public abstract class AbstractService implements Service {
    protected boolean started = false;
    protected final CountDownLatch latch;
    
    public AbstractService(CountDownLatch latch) {
        this.latch = latch;
    }
    
    @Override
    public boolean isStarted() {
        return started;
    }
    
    // 留给子类实现的抽象方法，用于实现服务器的启动逻辑
    protected abstract void doStart() throws Exception;
    
    @Override
    public void start() {
        new ServiceStarter().start();
    }
    
    @Override
    public void stop() {
        // 默认什么也不做
    }
    
    class ServiceStarter extends Thread {
        @Override
        public void run() {
            final String serviceName = AbstractService.this.getClass().getSimpleName();
            Debug.info("Starting %s", serviceName);
            try {
                doStart();
                started = true;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
                Debug.info("Done Starting %s", serviceName);
            }
        }
    }
}
~~~

如果CountDownLatch内部计数器由于程序的错误而永远无法达到0，那么相应实例上的等待线程会一直处于WAITING状态。避免该问题的出现有两种方法。

其一，确保所有CountDownLatch.countDown() 调用都位于代码中正确的位置。例如本案例，如果我们把CountDownLatch.countDown() 调用放在 doStart() 调用之后而不是finally块中（见清单5-6），那么某个服务启动过程中出现异常（如运行时异常）会导致main线程执行到ServiceManager.checkServiceStatus()时，该线程一直处于WAITING状态。

其二，等待线程在等待先决操作完成的时候指定一个时间限制。此时我们可以使用CountDownLatch.await() 的另外一个版本，其声明如下：

~~~java
public boolean await(long timeout, TimeUnit unit) throws InterruptedException
~~~

CountDownLatch.await(long, TimeUnit) 允许指定一个超时时间，在该时间内如果相应CountDownLatch 实例的计数器值仍然未达到 0， 那么所有执行该实例的await 方法的线程都会被唤醒。该方法的返回值可用于区分其返回是否是由于等待超时。

> **注意**
>
> CountDownLatch 内部计数器值达到0后其值就恒定不变，后续执行该CountDownLatch实例的await方法的任何一个线程都不会被暂停。为了避免等待线程永远被暂停，CountDownLatch.countDown()调用必须放在代码中总是可以被执行到的地方，例如finally块中。

对于同一个CountDownLatch 实例 latch，latch.countDown() 的执行线程在执行该方法之前所执行的任何内存操作对等待线程在latch.await() 调用返回之后的代码是可见的且有序的。

前文我们说过CountDownLatch 的构造器中的参数既可以表示先决操作的数量，也可以表示先决操作需要被执行的次数。在上述实战案例中，CountDownLatch 的构造器中的参数的含义就属于前者。而后者表示我们可以在一个线程中多次调用同一个CountDownLatch 实例的countDown 方法，以使相应实例的内部计数器值达到 0，如清单5-7所示。

~~~java
public class CountDownLatchExample {
    private static final CountDownLatch latch = new CountDownLatch(4);
    private static int data;
    
    public static void main(String[] args) throws InterruptedException {
        Thread workerThread = new Thread() {
            @Override
            public void run() {
                for (int i = 1; i < 10; i++) {
                    data = i;
                    latch.countDown();
                    // 使当前线程暂停（随机）一段时间
                    Tools.randomPause(1000);
                }
            }
        };
        workerThread.start();
        latch.await();
        Debug.info("It's done. data=%d", data);
    }
}
~~~

我们在创建 CountDownLatch 实例 latch 的时候指定的构造器参数为4。尽管 latch.countDown() 一共会被子线程workerThread 执行 10 次，但是该程序的输出总是如下：

~~~
It's done. data=4
~~~

这里程序输出的 data 为 4 而不是 10 是由于：首先， latch.countDown() 被 workerThread 执行了 4 次之后，main 线程对 latch.countDown() 的调用就返回了，从而使该线程被唤醒。其次，workerThread 在执行 latch.countDown() 前所执行的操作（更新共享变量 data）的结果对等待线程（main 线程）从 latch.await() 返回之后的代码可见，因此 main 线程被唤醒时能够读取到此前 workerThread 在 latch.countDown() 调用返回前的操作结果——data被更新为 4。

这里，latch.countDown() 被 workerThread 执行的次数大于4次并不会导致异常，也不会导致latch内部状态（计数器值）的变更。

## 5.4 栅栏（CyclicBarrier）



# 第6章 保障线程安全的设计技术

## 6.4 我有我地盘：线程持有对象

如果多个线程需要共享同一个非线程安全对象，那么我们往往需要借助锁来保障线程安全。事实上，我们也可以选择不共享非线程安全对象——对于一个非线程安全对象，每个线程都创建一个该对象的实例，各个线程仅访问各自创建的实例，且一个线程不能访问另外一个线程创建的实例。这种各个线程创建各自的实例，一个实例只能被一个线程访问的对象就被称为**线程特有对象**（TSO，Thread Specific Object），相对应的线程就被称为该线程特有对象的**持有线程**。线程特有对象既保障了对非线程安全对象的访问的线程安全，又避免了锁的开销。另外，对于特定类型的线程特有对象，一个线程往往只需要该对象的一个实例，这个实例可以被该线程（同一个线程）所执行的多个方法（包括不同类的方法）共享，因此线程持有对象也有利于减少对象的创建次数。线程持有对象可能是有状态对象，但是由于这个对象并不会被多个线程共享，因此线程特有对象也具有固有的线程安全性。

`ThreadLocal<T>`类相当于线程访问其线程特有对象的代理（Proxy），即各个线程通过这个对象可以创建并访问各自的线程特有对象，其类型参数T指定了相应线程特有对象的类型。一个线程可以使用不同的ThreadLocal实例来创建并访问其不同的线程特有对象。多个线程使用同一个`ThreadLocal<T>`实例所访问到的对象是类型T的不同实例，即这些线程各自的线程特有对象实例。因此，ThreadLocal类也可以理解为当前线程访问其线程特有对象的代理对象，这种代理与被代理的关系如图6-2所示

~~~mermaid
graph LR
	subgraph ThreadLocal1
		n11(.)
		n12(.)
		n13(.)
	end
	subgraph ThreadLocal2
		n21(.)
		n22(.)
		n23(.)
	end
	线程1-->n11-.->tsoX1
	线程1-->n21-.->tsoY1
	线程2-->n12-.->tsoX2
	线程2-->n22-.->tsoY2
	线程3-->n13-.->tsoX3
	线程3-->n23-.->tsoY3
~~~

从图6-2可以看出，ThreadLocal实例为每个访问它的线程（即当前线程）都关联了一个该线程的线程特有对象。换句话说，每个`ThreadLocal<T>`实例都有一个（且只有一个）当前线程的持有对象T的实例与之关联，这种关联关系就像一个变量总是有一个（且只有一个）值与之关联一样（尽量变量的值是可以改变的），因此ThreadLocal实例也被称为**线程局部变量**（Thread-local Variable）。ThreadLocal类的方法如表6-1所示。

| 方法                       | 功能                                                         |
| -------------------------- | ------------------------------------------------------------ |
| public T get()             | 获取与该线程局部变量关联的当前线程的线程特有对象             |
| public void set(T value)   | 重新关联该线程局部变量所对应的当前线程的线程持有对象         |
| protected T initialValue() | 该方法的返回值（对象）就是初始状态下该线程局部变量所对应的当前线程的线程特有对象 |
| public void remove()       | 删除该线程局部变量与相应的当前线程的线程特有对象之间的关联关系 |

设tlVar为任意一个线程局部变量。初始状态下，tlVar并没有与之关联的线程特有对象。当一个线程初次执行tlVar.get()的时候，tlVar.get()会调用tlVar.initialValue()。tlVar.initialValue()的返回值就会成为tlVar所关联的当前线程（即tlVar.get()的执行线程）的线程特有对象。这个线程后续再次执行 tlVar.get() 所返回的线程特有对象始终都是同一个对象（即tlVar.initialValue()的返回值），除非这个线程中途执行了tlVar.set(T)。由于ThreadLocal的initialValue方法的返回值为null，因此要设置线程局部变量关联的初始线程特有对象。我们需要创建ThreadLocal的子类（通常是匿名子类）并在子类中覆盖（Override）initialValue方法，然后在该方法中返回初始线程特有对象。从Java 8开始，ThreadLocal 引入了一个名为withInitial的静态方法，该方法使得我们能够用一个Lambda表达式（返回值）作为相应线程局部变量所关联的初始线程特有对象。例如，清单6-7中的线程局部变量SDF的初始值可写作`ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd"))`。

使用ThreadLocal，我们可以将清单6-5中的非线程安全Servlet改造成线程安全的，如清单6-7所示。在这个例子中，ThreadLocal不仅使我们在无须借助锁的情况下实现了线程安全，还减少了对象创建的次数——doPost方法的各个执行线程各自仅创建各自的一个SimpleDateFormat实例。相反，如果我们直接在doPost方法中创建并使用SimpleDateFormat实例的话固然可以确保线程安全，但是那样就意味着每次执行doPost方法都会导致新的SimpleDateFormat实例被创建。

~~~java
public class ServletWithThreadLocal extends HttpServlet {
    final static ThreadLocal<SimpleDateFormat> SDF = new ThreadLocal<SimpleDateFormat>() {
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd");
        }
    };
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        final SimpleDateFormat sdf = SDF.get();
        String strExpiryDate = req.getParameter("expirtyDate");
        try (PrintWriter pwr = resp.getWritter()) {
            sdf.parse(strExpiryDate);
            // 省略其他代码
            pwr.printf("[%s]expirtyDate:%s", Thread.currentThread().getName(), strExpiryDate);
        } catch (ParseException e) {
            throw new ServletException(e);
        } // try结束
    }
}
~~~

线程局部变量通常是会被声明为某个类的静态变量，正如清单6-7所示。这是因为：如果把线程局部变量声明为某个类的实例变量，那么每创建该类的一个实例都会导致新的ThreadLocal实例被创建。这就可能导致当前线程中同一个类型的线程持有对象会被多次创建。而这即便不会导致错误，也会导致重复创建对象带来的浪费。

> **注意**
>
> ThreadLocal实例通常会被作为某个类的静态字段使用。

由于线程安全的对象内部往往需要使用锁，因此，多个线程共享线程安全的对象可能导致锁的争用。所以，有时候为了避免锁的争用导致的开销（主要是上下文切换），我们也特意将线程安全的对象作为线程特有对象来使用，从而避免了锁的开销，又减少了对象创建的次数。

JDK 1.7中引入的标准库类java.util.concurrent.ThreadLocalRandom的初衷与该案例所要实现的目标相似。ThreadLocalRandom也是Random的一个子类，它相当于`ThreadLocal<Random>`。不过，ThreadLocalRandom所产生的随机数并非强随机数。

### 6.4.1 线程特有对象可能导致的问题及其规避

使用线程特有对象可能会导致如下几个问题：

- 退化与数据错乱。由于线程和任务之间可以是一对多的关系，即一个线程可以先后执行多个任务，因此线程特有对象就相当于一个线程所执行的多个任务之间的共享对象。如果线程持有对象是个有状态对象且其状态会随着相应线程所执行的任务而改变，那么这个线程所执行的下一个任务可能“看到”来自前一个任务的数据，而这个数据可能与该任务并不匹配，从而导致数据错乱。因此，在一个线程可以执行多个任务的情况下（比如在生产者-消费者模式中）使用线程特有对象，我们需要确保每个任务的处理逻辑被执行前相应的线程特有对象的状态不受前一个被执行的任务影响。这通常可以通过在任务处理逻辑被执行前为线程局部变量重新关联一个线程特有对象（通过调用ThreadLocal.set(T)实现）或者重置线程特有对象的状态来实现。例如，清单6-9中的XAbstractTask子类的多个实例可以由一个线程负责执行（比如使用第5章的TaskRunner来执行，代码参见清单5-14），因此我们在preRun方法中将线程特有对象HashMap的内容清空，以避免前一个任务（XAbstratTask子类实例）执行时更改了线程特有对象的状态对当前执行的任务造成影响。从清单6-9中可以看出，在线程可以被重复使用来执行多个任务的情况下使用线程特有对象即使不会造成数据错乱，也可能导致这种线程特有对象实际上“退化”成为任务特有对象——被执行的任务可能更改了线程特有对象的状态，而这些状态一旦对其他任务可见又可能导致数据错乱，因此每个任务实际上需要的是状态会受该任务影响并且独立于其他任务的一个对象。

  ~~~java
  public abstract class XAbstractTask implements Runnable {
      static ThreadLocal<HashMap<String, String>> configHolder = new ThreadLocal<HashMap<String, String>>() {
          @Override
          protected HashMap<String, String> initialValue() {
              return new HashMap<String, String>();
          }
      };
      
      // 该方法总是会在任务处理逻辑被执行前执行
      protected void preRun() {
          // 清空线程持有对象HashMap实例，以保证每个任务执行前HashMap的内容是“干净”的
          configHolder.get().clear();
      }
      
      protected void postRun() {
          // 什么也不做
      }
      
      // 暴露给子类用于实现任务处理逻辑
      protected abstract void doRun();
      
      @Override
      public final void run() {
          try {
              preRun();
              doRun();
          } finally {
              postRun();
          }
      }
  }
  ~~~

- ThreadLocal可能导致内存泄漏、伪内存泄漏。在Web应用中使用ThreadLocal极易导致内存泄漏、伪内存泄漏的问题。下面以Tomcat服务器环境为例分析ThreadLocal可能导致内存泄漏、伪内存泄漏的原因，并在此基础上给出规避措施。

  > **内存泄漏**（Memory Leak）指由于对象永远无法被垃圾回收导致其占用的Java虚拟机内存无法被释放。持续的内存泄漏会导致Java虚拟机可用内存逐渐减少，并最终可能导致Java虚拟机内存溢出（Out of Memory），直到Java虚拟机宕机。
  >
  > **伪内存泄漏**（Memory Pseudo-leak）类似于内存泄漏。所不同的是，伪内存泄漏中对象所占用的内存在其不再被使用后的相当长时间仍然无法被回收，甚至可能永远无法被回收。也就是说，伪内存泄漏中对象占用的内存空间可能会被回收，也可能永远无法被回收（此时，就变成了内存泄漏）。

我们先简单了解一下ThreadLocal的内部实现机制。在Java平台中，每个线程（Thread实例）内部会维护一个类似HashMap的对象，我们称之为ThreadLocalMap。每个ThreadLocalMap内部会包含若干Entry（条目，一个键Key-值Value对）。因此，我们可以说每个线程都拥有若干这样的条目，相应的线程就被称为这些条目的**属主线程**。Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象。因此，Entry的作用相当于为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系。由于Entry对ThreadLocal实例的引用（通过Key引用）是一个弱引用（Weak Reference），因此它不会阻止被引用的ThreadLocal实例被垃圾回收。当一个ThreadLocal实例没有对其可达的（Reachable）强引用时，这个实例可以被垃圾回收，即其所在的Entry的Key会被置为null。此时，相应的Entry就成为**无效条目**（State Entry）。另一方面，由于Entry对线程特有对象的引用是强引用，因此如果无效条目本身有对它的可达强引用，那么无效条目也会阻止其引用的线程特有对象被垃圾回收。有鉴于此，当ThreadLocalMap中有新的ThreadLocal到线程特有对象的映射（对应）关系被创建（相当于有新的Entry被添加到ThreadLocalMap）的时候，ThreadLocalMap会将无效条目清理掉，这打破了无效条目对线程特有对象的强引用，从而使相应的线程特有对象能够被垃圾回收。但是，这个处理也有一个缺点——一个线程访问过线程局部变量之后如果该线程有对其可达的强引用，并且该线程在相当长时间内（甚至一直）处于非运行状态，那么该线程的ThreadLocalMap可能就不会有任何变化，因此相应的ThreadLocalMap中的无效条目也不会被清理，这就可能导致这些线程的各个Entry所引用的线程特有对象都无法被垃圾回收，即导致了伪内存泄漏。

线程对象对ThreadLocal和线程特有对象的引用关系如图6-3所示（图中虚线表示弱引用，实线表示强引用）。

~~~mermaid
graph LR
	Thread --threadLocals--> ThreadLocalMap --entries--> Entry -.Key.-> ThreadLocal
	Entry --Value--> TSO
~~~

清单6-10展示了一个使用ThreadLocal并可能导致内存泄漏的Servlet。

~~~java
/**
 * 该类可能导致内存泄漏！
 */
@WebServlet("/memoryLeak")
public class ThreadLocalMemoryLeak extends HttpServlet {
    private static final long serialVersionUID = 4364376277297114653L;
    final static ThreadLocal<Counter> counterHolder = new ThreadLocal<Counter>(){
        @Override
        protected Counter initialValue() {
            Counter tsoCounter = new Counter();
            return tsoCounter;
        }
    };
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doProcess(req, resp);
        try (PrintWriter pwr = resp.getWriter()) {
            pwr.printf("Thread %s, counter:%d",
                      Thread.currentThread().getName(),
                      countHolder.get().getAndIncrement());
        }
    }
    
    void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        counterHolder.get().getAndIncrement();
        // 省略其他代码
    }
}

// 非线程安全
class Counter {
    private int i = 0;
    public int getAndIncrement() {
        return i++;
    }
}
~~~

在Tomcat环境下，Web应用自身定义的类（Custom Class）由类加载器（Class Loader）WebAppClassLoader负责加载，而Java标准库类（例如HashMap）由类加载器StandardClassLoader负责加载。每个类（类本身也是一种对象）都会持有对加载该类的类加载器的强引用，并且类加载器本身又会持有其加载过的所有类的强引用。另外，每个对象（实例）都会持有对其相应类的强引用。由于Servlet类ThreadLocalMemoryLeak及其使用的线程持有对象Counter类都是由WebAppClassLoader负责加载的，并且counterHolder（`ThreadLocal<Counter>`）是ThreadLocalMemoryLeak的一个静态字段，因此我们可以得出图6-4所示的引用关系（图中实线表示强引用）。

~~~mermaid
graph TB
	tsoCounter[tsoCounter:线程持有对象Counter] --class--> Counter[Counter:Web应用自定义类] --> WebAppClassLoader
	subgraph t
		WebAppClassLoader[WebAppClassLoader:类加载器] --loadedClasses--> ThreadLocalMemoryLeak[ThreadLocalMemoryLeak:Servlet子类] --静态变量--> countHolder[countHolder:线程局部变量]
	end
~~~

由图6-4中可以看出，由Web应用自身定义的线程特有对象（tsoCounter）特有对线程局部变量（counterHolder）的可达利用。并且线程（对象）又持有对其线程特有对象的可达引用（如图6-3所示），因此，结合图6-3、图6-4中的引用关系可知，此时线程（对象）不仅持有了对其线程特有对象的可达强引用（见图6-4）。所以，只要系统中还存在对这个线程对象的可达强引用，即线程本身没有被垃圾回收掉，那么这个线程访问过的所有线程局部变量以及相应的线程特有对象都不会被垃圾回收掉！由于Tomcat中的一个工作者线程（负责调用Servlet.service方法进行请求处理，service方法最终会调用doXXX方法）可以为多个Web应用服务，因此当ThreadLocalMemoryLeak所在的Web应用被停止的时候（不是Web服务器被停止）执行过ThreadLocalMemoryLeak.service方法的工作者线程并不会被停止，故而这些线程对象并不会被垃圾回收掉，进而使其所引用的所有线程局部变量及相应的线程特有对象并不会被垃圾回收掉，即导致了内存泄漏。进一步来说，此时的内存泄漏还会导致与当前Web应用相应的类加载器WebAppClassLoader所加载的所有类（以及这些类的静态变量所引用的所有对象）都无法被垃圾回收，而这最终可能导致Java虚拟机的非堆内存（Non-heap）空间中的永久代（Permanent Generation， Java 8 中它被元数据空间 Metaspace 所取代）内存溢出（Out of memory），即Java虚拟机会抛出java.lang.OutOfMemoryError(具体消息为“PermGen space”)。所幸的是，Apache Tomcat以及IBM WebSphere Application Server都提供了一套内存泄漏的检查机制以及一定程度的自动规避机制（不过，我们最好不要依赖于这种自动规避机制）。

如果线程局部变量关联的线程特有对象是一个Java标准库类（如清单6-7所使用的java.text.SimpleDateSimple）实例，那么由于Java 标准库类是由类加载器StandardClassLoader加载的，StandardClassLoader并不会持有对应用自身定义的类（ThreadLocalMemoryLeak）的引用，因此图6-4所示的引用关系中虚线框中的引用关系并不存在，即导致上述内存泄漏的前提不满足。所以，线程局部变量关联的线程特有对象类型如果是 Java 标准库类，那么它并不会导致内存泄漏。但是，由于图6-3中的引用关系——线程（对象）持有对线程特有对象（TSO）的可达强引用，因此只要相应的线程（对象）没有被垃圾回收掉，那么相应的线程特有对象也不会被垃圾回收掉。可见，这种情况下，线程局部变量可能导致伪内存泄漏。

由于ThreadLocal可能导致内存泄漏、伪内存泄漏的最小前提是线程（对象）持有对线程特有对象的可达强引用（见图6-3中的实线所表示的引用关系）。因此，我们只要打破这种引用，即通过在当前线程中调用ThreadLocal.remove()将线程特有对象从其所属的Entry中剥离（清理），便可以使线程特有对象以及线程局部变量都可以被垃圾回收。如果我们仅仅是打破线程特有对象对ThreadLocal的引用关系（如图6-4所示），那么只有线程局部变量可以被垃圾回收，而伪内存泄漏仍然存在，即线程特有对象可能仍然无法被来及回收。

对于同一个ThreadLocal实例，ThreadLocal.remove()能够奏效的前提是，其执行线程与ThreadLocal.get()/set(T) 的执行线程必须是同一个线程。由于ThreadLocal.get()/remove()/set(T) 这几个方法都是针对当前线程（即这些方法的执行线程）的，因此即使是针对同一个ThreadLocal实例，我们也无法通过在一个线程中调用ThreadLocal.remove()来将另外一个线程的线程特有对象从所属的Entry中剥离。换而言之，我们无法通过在一个线程中执行ThreadLocal.remove()来规避另外一个线程因使用ThreadLocal而导致的伪内存泄漏！

在Web应用中使用线程特有对象可能导致线程持有对象的“退化”：在上述例子中，为了避免ThreadLocal导致的伪内存泄漏（或内存泄漏），我们在每个请求处理结束后都将该请求的处理线程的线程特有对象（Counter实例）清理掉。因此，不同的请求即使是先后由同一个（任意的）服务器工作者线程来负责处理的，这个（任意的）线程每次执行ThreadLocalMemoryLeak.doGet方法（以对请求进行处理）的时候都会创建新的Counter实例。这就意味着：首先，不同的服务器工作者线程不会访问相同的Counter实例，即Counter实例不会被多个服务器工作者线程共享，这说明该例子对Counter的使用方式（线程局部变量）与直接将Counter实例定义为一个静态变量（`final static Counter COUNTER = new Counter();`）还是不同的。其次，这些服务器工作者线程所访问的线程特有对象（Counter实例）实际上已“退化”成“请求特有对象”——每一个请求都对应一个Counter实例。

### 6.4.2 线程特有对象的典型应用场景

典型应用场景如下。

- **场景一** 需要使用非线程安全对象，但又不希望因此而引入锁。如果多个线程需要使用非线程安全的对象，而我们又不希望该对象被多个线程共享（因为共享往往意味着需要引入锁以保证线程安全），此时可以使用线程特有对象，使得各个线程拥有其特有的非线程安全对象实例。
- **场景二** 使用线程安全对象，但希望避免其使用的锁的开销和相关问题。线程安全的对象虽然可以被多个线程共享，但是由于其可能使用了锁来保证线程安全，而某些情况下我们可能不希望看到锁的开销以及由锁可能引起的相关问题（如死锁）。此时，我们可以将线程安全对象当作非线程安全的对象来看待。因此，这种场景就转化成场景一。只不过此时使用线程特有对象的主要意图在于避免锁的开销，当然线程安全也是由保障的。
- **场景三** 隐式参数传递（Implicit Parameter Passing）。线程特有对象在一个具体的线程中，它是线程全局可见的。一个类的方法中设置的线程特有对象对于该方法调用的任何其他方法（包括其他类的方法）都是可见的。这就可以形成隐式传递参数的效果，即一个类的方法调用另一个类的方法时，前者向后者传递数据可以借助ThreadLocal而不必通过方法参数传递。不过，也有的观点认为隐式参数传递使得系统难于理解。隐式参数传递的实现通常是使用一个只包括静态方法的类或者单例类（包装类）来封装对线程特有对象的访问，其他相应访问线程特有对象的代码只需要调用包装类的静态方法或者实例方法即可以访问线程特有对象。
- **场景四** 特定于线程的单例（Singleton）模式。广为使用的单例模式所实现的效果是在一个Java虚拟机中的一个类加载器下某个类有且只有一个实例。如果我们希望对于某个类每个线程有且仅有该类的一个实例，那么就可以使用线程持有对象。

## 6.5 装饰器模式



# 第12章 Java多线程程序的性能调校

## 12.1 Java虚拟机对内部锁的优化

自 Java6/Java7 开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用。

### 12.1.1 锁消除

锁消除（Lock Elision）是JIT编译器对内部锁的具体实现所做的一种优化，如下所示。（IBM J9 Java虚拟机也支持该优化）

~~~java
// 待编译字节码的等效代码
synchronized(monitor){
    doSomething;
}
// 有且仅有一个线程会执行这段代码
↓
// 编译后的机器码的等效代码
doSomething();
~~~

在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候并不生成synchronized所表示的锁的申请与释放对应的机器码，而仅生成原临界区代码对应的机器码，这就造成了被动态编译的字节码就像是不包含monitorenter（申请锁）和monitorexit（释放锁）这两个字节码指令一样，即消除了锁的使用。这种编译器优化就被称为锁消除（Lock Elision），它使得特定情况下我们可以完全消除锁的开销。

Java标准库中的有些类（比如StringBuffer）虽然是线程安全的，但是在实际使用中我们往往不在多个线程间共享这些类的实例。而这些类在实现线程安全的时候往往借助于内部锁。因此，这些类是锁消除优化的常见目标。如清单12-1所示的例子中，JIT编译器在编译 toJSON 方法的时候会将其调用的 StringBuffer.append/toString 方法内联（Inline）到该方法之中，这相当于把 StringBuffer.append/toString 方法的方法体中的指令复制到toJSON的方法体中。这里的StringBuffer实例sbf是一个局部变量，并且该变量所引用的对象并没有被发布到其他线程，因此 sbf 引用的对象只能够被 sbf 所在的方法（toJSON方法）的当前执行线程（一个线程）访问。所以，JIT编译器此时可以消除toJSON方法中从 StringBuffer.append/toString 方法的方法体复制的指令所使用的内部锁。在这个例子中，StringBuffer.append/toString 方法本身所使用的锁并不会被消除，因为系统中可能还有其他地方在使用StringBuffer, 而这些代码可能会共享 StringBuffer 实例。

~~~java
// 清单12-1 可进行锁消除优化的示例代码
public class LockElisionExample {
    public static String toJSON(ProductInfo productInfo){
        StringBuffer sbf = new StringBuffer();
        sbf.append("{\"productID\":\"}").append(productInfo.productID);
        sbf.append("\",\"categoryID\":\"").append(productInfo.categoryID);
        sbf.append("\",\"rank\":\"").append(productInfo.rank);
        sbf.append("\",\"inventory\":\"").append(productInfo.inventory);
        sbf.append("\"}");
        
        return sbf.toString();
    }
}
~~~

锁消除优化所依赖的逃逸分析技术自Java SE 6u23起默认是开启的，但是锁消除优化是在Java 7开始引入的。（开启逃逸分析的虚拟机参数为“-XX:+DoEscapeAnalysis”, 关闭逃逸分析的虚拟机参数为“-XX:-DoEscapeAnalysis”。注意：“-XX:”开头的虚拟机参数表示相应的参数是“不稳定的”，即Oracle公司可能会在不事先通知的情况下更改甚至废弃相应的参数。）

从上述例子可以看出，锁消除优化还可能需要以JIT编译器的内联优化为前提。而一个方法是否会被JIT编译器内联取决于该方法的热度以及该方法对应的字节码的尺寸（Bytecode Size）。因此，锁消除优化能否被实施还取决于被调用的同步方法（或者带同步块的方法）是否能够被内联。

锁消除优化告诉我们在该使用锁的情况下必须使用锁，而不必过多在意锁的开销。开发人员应该在代码的逻辑层面考虑是否需要加锁，而至于代码运行层面上某个锁是否真的有必要使用则由JIT编译器来决定。锁消除优化并不表示开发人员在编写代码的时候可以随意使用内部锁（在不需要加锁的情况下加锁），因为锁消除是JIT编译器而不是javac所做的一种优化，而一段代码只有在其被执行的频率足够大的情况下才有可能会被JIT编译器优化。也就是说在JIT编译器优化介入之前，只要源代码中使用了内部锁，那么这个锁的开销就会存在。另外，JIT编译器所执行的内联优化、逃逸分析以及锁消除优化本身都是有其开销的。

在锁消除的作用下，利用ThreadLocal将一个线程安全的对象（比如Random）作为一个线程特有对象来使用，不仅仅可以避免锁的争用，还可以彻底消除这些对象内部所使用的锁的开销。

### 12.1.2 锁粗化

锁粗化（Lock Coarsening/Lock Merging）是JIT编译器对内部锁的具体实现所做的一种优化。