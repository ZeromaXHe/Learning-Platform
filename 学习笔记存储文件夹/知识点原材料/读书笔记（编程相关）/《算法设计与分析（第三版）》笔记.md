# 第1章 算法引论 习题

**1-1** 说明下面方法swap为什么无法交换实际参数的值。

```
答：java基本数据类型传值，方法不会改变实参的值。
书中原文为——java中所有方法的参数均为值参数。在调用方法时先将实际参数的值复制到形式参数中，然后再执行调用。因此，在执行调用后，实际参数的值不变。
（思考：所以要用javabean？如果要实现swap，必须引入getter&setter？）
```

**1-2** 说明下面的两个方法头是否有不同的签名，为什么？

```
答：签名是指方法名加参数列表。所以两者均为fff+（int, int, int），签名相同。
```

**1-3** 写一个通用方法用于判定给定数组是否已排好序。

```java
public static boolean checkOrder(int a[]){
    int temp;
    int order=0;
    for(int i=0;i<a.length;i++){
        if(i==0) temp=a[i];
        else if(order!=0){
            if(order==1 && a[i]>=temp) temp=a[i];
            else if(order==-1 && a[i]<=temp) temp=a[i];
            else return false;
        }
        else {
            if(a[i]>temp) order=1;
            else if(a[i]<temp) order=-1;
            temp=a[i];
        }
    }
    return true;
}
```

**1-4** 求下列函数的渐进表达式。

(1) 3n^2^+10n

(2) n^2^/10+2^n^

(3) 21+1/n

(4) logn^3^

(5) 10log3^n^

```
(1)O(n^2)
(2)O(2^n)
(3)O(1)
(4)O(log n)
(5)O(n)
```

**1-5** 说明O(1)和O(2)的区别

```
答：仅有表面上数字区别，其实没区别,O(1)=O(2)
```

**1-9** 对于下列各组函数f（n）和g（n），确定f（n）=O(g（n）)或f（n）=Ω（g(n)）或f（n）=θ（g（n）），并简述理由。

```
f（n）的阶不高于g（n）的阶：f(n)=O(g(n))
f(n)的阶不低于g（n）的阶：
f（n）=Ω（g(n)）
（1）θ
（2）O
（3）Ω
（4）Ω
（5）θ
（6）Ω
（7）Ω
（8）O
```

**1-10** 证明：n！=o(n^n^)。

```
n!/(n^n)=(1/n)(2/n)…(n/n)趋近于0
```

**1-11** 证明：如果一个算法在平均情况下的计算时间复杂性为θ（f(n)）,则该算法在最坏情况下所需的计算时间为Ω（f(n)）

```
反证法
假设最坏情况下需要的计算时间为g(n)其中g(n)为O（f(n)）中不为θ（f(n)）的部分。
那么根据平均情况下的计算时间复杂性就会成立θ（f(n)）=O（g(n)）,显然该式无法成立，所以，原命题正确。
```

```
查的答案：
Tavg（N）=∑P（I）T(N,I）
	<=∑P(I)maxT(N,I')
	=T(N,I*)∑P(I)
	=T(N,I*)
	=Tmax(N)
因此Tmax(N)=Ω（Tavg（N））=Ω（θ（f(n)））=Ω（f(n)）
```

# 第2章 递归与分治策略

## 2.1 递归的概念

### Ackerman函数

并非一切递归函数都能用非递归方式定义。为了对递归函数的复杂性有更多的了解，介绍一个双递归函数——Ackerman函数。

当一个函数以及它的一个变量是由函数自身定义时，称这个函数是**双递归函数**。

Ackerman函数A(n,m)有两个独立的整变量m>=0和n>=0，其定义如下：

```
A(1,0)=2
A(0,m)=1 m>=0
A(n,0)=n+2 n>=2
A(n,m)=A(A(n-1,m),m-1) n,m>=1
```

A(n,4)的增长速度非常快，以至于没有适当的数学式子来表示这一函数。

单变量的Ackerman函数A(n)定义为：`A(n)=A(n,n)`。其拟逆函数a(n)在算法复杂性分析中常遇到。它定义为：`a(n)=min{k|A(k)>=n}`。即a(n)是使n<=A(k)成立的最小的k值。a(n)的增长速度非常慢，但理论上a(n)没有上界，它以难以想象的速度趋向无穷大。

### 整数划分问题

将正整数n表示成一系列正整数的和：`n=n1+n2+……+nk,其中n1>=n2>=……>=nk>=1,k>=1`。

正整数n的这种表示称为**正整数n的划分**。正整数n的不同划分个数称为**正整数n的划分数**，记作p(n)。

例如，正整数6有如下11种不同的划分，所以 p(6)=11。

```
6；
5+1；
4+2，4+1+1；
3+3，3+2+1，3+1+1+1；
2+2+2，2+2+1+1，2+1+1+1+1；
1+1+1+1+1+1。
```

在正整数n的所有不同的划分中，将最大加数n1不大于m的划分个数记作q(n,m)。可以建立q(n,m)的如下递归关系。

(1) `q(n,1)=1,n>=1`

当最大加数n1不大于1时，任何正整数n只有一种划分形式，即n是n个1相加。

(2) `q(n,m)=q(n,n),m>=n`

最大加数n1实际上不能大于n。因此，q(1,m)=1

(3) `q(n,n)=1+q(n,n-1)`

正整数n的划分由n1=n的划分和n1<=n-1的划分组成。

(4) `q(n,m)=q(n,m-1)+q(n-m,m),n>m>1`

正整数n的最大加数n1不大于m的划分由n1=m的划分和n1<=m-1的划分组成。

## 2.2 分治法的基本思想

## 2.3 二分搜索技术

## 2.4 大整数的乘法

设X和Y都是n位的二进制整数，现在要计算它们的乘积XY。可以用小学所学的方法来设计计算乘积XY的算法，但这样做计算步骤太多，效率太低。如果将每2个1位数的乘法或加法看做一步运算，那么这种方法要进行O(n^2)步运算才能算出乘积XY。下面用分治法来设计更有效的大整数乘积算法。

将n位二进制整数X和Y都分为2段，每段的长为n/2位（为简单起见，假设n是2的幂），`X=A(n/2位)B（n/2位）；Y=C(n/2位)D(n/2位)`

由此，X=A\*2^(n/2)+B,Y=C\*2^(n/2)+D, X和Y的乘积为 `XY = (A*2^(n/2)+B)(C*2^(n/2)+D) = AC*2^n + (AD + CB)*2^(n/2) + BD`

如果按此式计算XY，则必须进行4次n/2位整数的乘法（AC,AD,BC,BD）,以及3次不超过2n位的整数加法（分别对应于式中的加号），此外还要进行2次移位（分别对应于式中的乘2^n和乘2^(n/2)）。所有这些加法和移位共用O(n)步运算。设T(n)是2个n位整数相乘所需的运算总数，则有

```
T(n)= O(1) n=1
	4T(n/2)+O(n) n>1
```

由此可得T(n)=O(n^2)。因此，直接用此式来计算X和Y的乘积并不比小学生的方法更有效。*要想改进算法的计算复杂性，必须减少乘法次数。*

下面把XY写成另一种形式 `XY = AC*2^n + ((A-B)(D-C) + AC + BD）*2^(n/2) + BD`

此式看起来似乎复杂些，但它仅需做3次n/2位整数的乘法（AC，BD和(A-B)(D-C)），6次加、减法和2次移位。由此可得

```
T(n) = O(1) n=1
	3T(n/2)+O(n) n>1
```

容易求得其解为T(n)=O(n^log3)=O(n^1.59)。这是一个较大的改进

## 2.5 Strassen矩阵乘法

设A和B是2个n\*n矩阵，它们的乘积AB同样是一个n\*n矩阵。A和B的乘积矩阵C中元素C\[i]\[j]定义为`C[i][j]=∑A[i][k]B[k][j]`。

若依次定义来计算A和B的乘积矩阵C，则每计算C的一个元素C\[i]\[j]，需要做n次乘法运算和n-1次加法计算。因此，算出矩阵C的n^2个元素所需的计算时间为O(n^3)。

20世纪60年代末期，Strassen采用了类似于在大整数乘法中用过的分治技术，将计算2个n阶矩阵乘积所需的计算时间改进到O(n^log7)=O(n^2.81),其基本思想还是分治法。

首先，仍假设n是2的幂。将矩阵A, B
和C中每一矩阵都分块成4个大小相等的矩阵，每个矩阵都是(n/2)\*(n/2)的方阵。由此可将方程C=AB重写为

```
[C11 C12  = [A11 A12 [B11 B12
 C21 C22]   A21 A22] B21 B22]
```

由此可得

```
C11 = A11 B11 + A12 B21
C12 = A11 B12 + A12 B22
C21 = A21 B11 + A22 B21
C22 = A21 B12 + A22 B22
```

如果n=2，则2个2阶方阵的乘积可以直接计算出来，共需8次乘法和4次加法。当子矩阵的阶大于2时，为求2个子矩阵的积，可以继续将子矩阵分块，直到子矩阵的阶降为2.由此产生分治降阶的递归算法。以此算法，计算2个n阶方程的乘积和4个n/2阶方阵的加法。2个(n/2)\*(n/2)矩阵的加法显然可以在O(n^2)时间内完成。因此，上述分治法的计算时间耗费T(n)应满足

```
T(n) = O(1) n=2
	8T(n/2)+O(n^2) n>2
```

这个递归方程的解仍然是T(n)=O(n^3).因此，该方法并不比用原始定义直接计算更有效。*究其原因，乃是由于该方法没有减少矩阵的乘法次数。*

Strassen提出了一种新算法来计算2个2阶方阵的乘积。他的算法只用了7次乘法运算，但增加了加、减法的运算次数。这7次乘法运算是

```
M1 = A11 (B12 - B22)
M2 = (A11 + A12) B22
M3 = (A21 + A22) B11
M4 = A22 (B21 - B11)
M5 = (A11 + A22)(B11 + B22)
M6 = (A12 - A22)(B21 + B22)
M7 = (A11 - A21)(B11 + B12)
```

做了这7次乘法运算后，再做若干次加、减法运算就可以得到

```
C11 = M5 + M4 - M2 + M6
C12 = M1 + M2
C21 = M3 + M4
C22 = M5 + M1 - M3 - M7
```

以上计算的正确性很容易验证。
Strassen矩阵乘法中，用了7次对于n/2阶矩阵乘的递归调用和18次n/2阶矩阵的加减运算。由此可知，该算法所需的计算时间T(n)满足如下的递归方程

```
T(n) = O(1) n=2
	7T(n/2)+O(n^2) n>2
```

解此递归方程得T(n)=O(n^log7)=O(n^2.81).由此可见，Strassen矩阵乘法的计算时间复杂性比普通矩阵乘法有较大改进。

## 2.6 棋盘覆盖

在一个2^k\*2^k个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一**特殊方格**，且称该棋盘为一**特殊棋盘**。显然特俗方格在棋盘上出现的位置有4^k种情形。

在棋盘覆盖问题中，要用每张可以覆盖3格的L型骨牌覆盖给定的特殊棋盘上除特俗方格以外的所有方格，且任何两个L型骨牌不得重叠覆盖。

用分治策略，可以设计出解棋盘覆盖问题的简洁算法。
当k>0时，将2^k\*2^k棋盘分割为四个2^(k-1)\*2^(k-1)子棋盘。
为了将这三个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处。这3个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用过这种分割，直至棋盘简化为1\*1棋盘。

设T(k)是算法chessBoard覆盖一个2^k\*2^k棋盘所需的时间。从算法的分割策略可知，T(k)满足如下递归方程

```
T(k) = O(1) k=0
	4T(k-1)+O(1) k>0
```

解此递归方程可得T(k)=O(4^k).由于覆盖2^k\*2^k棋盘所需的L型骨牌个数为(4^k-1)/3，故算法chessBoard是一个在渐进意义下最优的算法。

## 2.7 合并排序

合并排序算法递归的描述：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。

改进：消去递归的合并排序算法。可以将数组a中国相邻元素两两配对。用合并算法将它们排序，构成n/2组长度为2的排好序的子数组段，然后再将它们排序成长度为4的排好序的子数组段，如此继续下去，直至整个数组排好序。

**自然合并排序**是上述合并排序算法mergeSort的变形。在上述合并排序算法中，第一步合并相邻长度为1的子数组段，这是因为长度为1的子数组段是已排好序的。事实上，对于初始给定的数组a，通常存在多个长度大于1的已自然排好序的子数组段。例如，若数组a中元素为｛4，8，3，7，1，5，6，2｝，则自然排好序的子数组段有｛4，8｝，｛3，7｝，｛1，5，6｝和｛2｝。用1次对数组a的线性扫描就足以找出所有这些排好序的子数组段。然后将相邻的排好序的子数组段两两合并，构成更大的排好序的子数组段。对上面的例子，经一次合并得到两个合并后的子数组段｛3，4，7，8｝和｛1，2，5，6｝。继续合并相邻排好序的子数组段，直至整个数组排好序。上面这两个数组段再合并后就得到｛1，2，3，4，5，6，7，8｝

## 2.8 快速排序

快速排序基本思想是，对于输入的子数组a\[p:r],按以下3个步骤进行排序。

(1)分解：以a\[p]为基准元素将a\[p:r]划分成3段a\[p:q-1],a\[q]和a\[q+1:r],使得a\[p:q-1]中任何元素小于等于a\[q],a\[q+1:r]中任何元素大于等于a\[q]。下标q在划分过程中确定。

(2)递归分解：通过递归调用快速排序算法，分别对a\[p:q-1]和a\[q+1:r]进行排序。

(3)合并：由于a\[p:q-1]和a\[q+1:r]的排序是就地进行的，所以在a\[p:q-1]和a\[q+1:r]都已经排好序后不需要执行任何计算，a\[p:r]就已排好序。

快速排序算法在平均情况下时间复杂性也是O(nlogn)，这在基于比较的排序算法类中算是快速的了，快速排序也因此而得名。

快速排序算法的性能取决于划分的对称性。通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。

## 2.9 线性时间选择

本节讨论与排序问题类似的元素选择问题。**元素选择问题**的一般提法是：给定线性序集中n个元素和一个整数k，1<=k<=n，要求找出这n个元素中第k小的元素，即如果将这n个元素依其线性序排列时，排在第k个的元素即要找的元素。当k=1时，即要找最小元素；k=n时，即要找最大元素；当k=(n+1)/2时，称为找中位数。

在某些特殊情况下，很容易设计出解选择问题的线性时间算法。例如，找n个元素的最小元素和最大元素显然可以在O(n)时间完成。如果k<=n/logn，通过堆排序算法可以在O(n+klogn)=O(n)时间内找出第k小的元素。当k>=n-n/logn时也一样。

一般的选择问题，特别是中位数的选择问题似乎比找最小元素要难，但事实上，从渐进阶的意义上看，它们是一样的。一般的选择问题也可以在O(n)时间内得到解决。下面要讨论解一般的选择问题的分治算法randomizedSelect。该算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。与快速排序算法不同的是，它只对划分出的子数组之一进行递归处理。

```java
private static Comparable randomizedSelect(int p, int r, int k)
{
	if(p==r) return a[p];
   int i=randomizedPartition(p,r),j=i-p+1;
   if(k<=j) return randomizedSelect(p,i,k);
   else return randomizedSelect(i+1,r,k-j);
}
```

可以看出，在最坏情况下，算法randomizedSelect需要Ω(n^2)计算时间。例如在找最小元素时，总是在最大元素处划分。尽管如此，该算法的平均性能很好。

下面来讨论类似于算法randomizedSelect但可以在最坏情况下用O(n)时间就完成选择任务的算法select。如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的两个子数组的长度都至少为原数组长度的ε倍（0<ε<1是某个正常数），那么就可以在最坏情况下用O(n)时间完成选择任务。例如ε=9/10，算法递归调用所产生的子数组的长度至少缩短1/10。所以在最坏情况下，算法所需的计算时间T(n)满足递归式T(n)<=T(9n/10)+O(n).由此可得T(n)=O(n).

按以下步骤可以找到满足要求的划分基准：

（1）将n个输入元素划分成\[n/5](向上取整)个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共\[n/5](向上取整)个。

（2）递归调用算法select来找出这\[n/5](向上取整)个元素的中位数。如果\[n/5](向上取整)是偶数，就找它的两个中位数中较大的一个。以这个元素作为划分基准。

## 2.10 最接近点对问题

**最接近点对问题**的提法是：给定平面上n个点，找其中一对点，使得在n个点组成的所有点对中，该点对间的距离最小。

一维情形：显然可以先将n个点排序，然后一次线性扫描就可以找出最接近点对。耗时O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对一维的简单情形，还是尝试用分治法来求解，并希望推广到二维的情形。

```java
public static double cpair1(S)
{
	n=|S|;
   if (n<2) return inf;
   m=S中各点坐标的中位数;
   构造S1和S2;
   //S1={x∈S|s<=m},S2={x∈S|x>m}
   d1=cpair1(S1);
   d2=cpair2(S2);
   p=max(S1);
   q=min(S2);
   d=min(d1,d2,q-p);
   return d;
}
```

由以上分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程

```
T(n) = O(1) n<4
	2T(n/2)+O(n) n>=4
```

解此递归方程可得T(n)=O(nlogn)。

这个算法看上去比用排序加扫描的算法复杂，然而它可以推广到二维的情形。

```
public static double cpair2(S)
{
	n=|S|;
   if(n<2) return inf;
   1. m=S中各点x间坐标的中位数；
   构造S1和S2；
   //S1={p∈S|x(p)<=m},S2={p∈S|x(p)>m}
   2. d1=cpair2(S1);
   d2=cpair2(S2);
   3. dm=min(d1,d2);
   4. 设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合;
   P2是S2中距垂直分割线l的距离在dm之内的所有点组成的集合;
   将P1和P2中的点依其y坐标排序；
   并设X和Y是相应的已排好序的点列；
   5. 通过扫描X以及对于X中每个店检查Y中与其距离在dm之内的所有点（最多6个）可以完成合并；
   当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动；
   6. d=min(dm,dl);
   return d;
}
```

下面分析算法cpair2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间。第3步和第6步用了常数时间。第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合要求，因此要做技术处理。采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列P\*。在执行分治法的第4步时，只要对P\*做一次线性扫描，即可抽取出所需要的排好序的点列X和Y。然后，在第5步中再对X做一次线性扫描，即可求得dl。因此，第4步和第5步的两遍扫描合在一起只要O(n)时间。由此可知，经过预排序处理后的算法cpair2所需的计算时间T(n)满足递归方程

```
T(n) = O(1) n<4
	2T(n/2)+O(n) n>=4
```

由此易知，T(n)=O(nlogn)。预排序所需的计算时间显然为O(nlogn).因此，整个算法所需的计算时间为O(nlogn)。在渐进的意义下，此算法已是最优的了。

## 2.11 循环赛日程表

分治策略，可以将所有的选手分为两半，n个选手的比赛日程表就可以通过为n/2个选手射击的比赛日程表来决定。递归地用这种一分为而的策略对选手进行分割，直到只剩下两个选手时，比赛日程表的指定就变得很简单。这时只要让这2个选手进行比赛就可以了。

# 第2章 递归与分治策略 习题

**2-1** 证明Hanoi塔问题的递归算法与非递归算法实际上是一回事。

```

```

# 第3章 动态规划

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法解这些问题，则分解得到的子问题数目太多，以至于最后解决原问题需要耗费指数时间。然而，不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。

为了达到这个目的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思想。具体的动态规划算法是多种多样的，但它们具有相同的填表样式。

动态规划算法适用于解最优化问题。通常可以按一下步骤设计动态规划算法：

（1）找出最优解的性质，并刻画其结构特征；

（2）递归地定义最优值；

（3）以自底向上的方式计算出最优值；

（4）根据计算最优值时得到的信息，构造最优解。

步骤（1）~（3）是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤（4）可以省去。若需要求问题的最优解，则必须执行步骤（4）。此时，在步骤（3）中计算最优值时，通常需记录更多的信息，以便在步骤（4）中，根据所记录的信息，快速构造出最优解。

## 3.1 矩阵连乘问题

矩阵A和B可乘的条件是矩阵A的列数等于矩阵B的行数。若A是一个p\*q矩阵，B是一个q\*r矩阵，则其乘积C=AB是一个p\*r矩阵。在上述计算C的标准算法中，主要计算量是3重循环，总共需要pqr次数乘。

**矩阵连乘积的最优计算次序问题**：对于给定的相继n个矩阵｛A1，A2，…，An｝（其中矩阵Ai的维数为p(i-1)\*pi，i=1,2,…，n），如何确定计算矩阵连乘积A1A2…An的计算次序（完全加括号方式），使得依此次序计算矩阵连乘积需要的数乘次数最少。

穷举搜索法是最容易想到的方法。也就是列举出所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序。这样做计算量太大。事实上，对于n个矩阵的连乘积，设其不同的计算次序为P(n)。由于可以先在第k个和第k+1个矩阵之间将原矩阵序列分为2个矩阵子序列，k=1,2,…,n-1；然后分别对这2个矩阵子序列完全加括号；最后对所得的结果加括号，得到原矩阵序列的一种完全加括号方式。由此，可以得到关于P(n)的递推式如下：

```
P(n) = 1 n=1
	(k=1~n-1)∑P(k)P(n-k) n>1
```

解此递归方程可得，P(n)实际上是Catalan数，即P(n)=C(n-1),其中，`C(n)=1/(n+1)\*二项分布系数(2n n)=Ω(4^n/n^(3/2))`

也就是说，P(n)是随n的增长呈指数增长的。因此，穷举搜索法不是一个有效的算法。

下面考虑用动态规划法解矩阵连乘积的最优计算次序问题。

**1.分析最优解的结构**

这个问题的一个关键特征设：计算A\[1:n]的最优次序所包含的计算矩阵子链A\[1:k]和A\[k+1:n]的次序也是最优的。事实上，若有一个计算A\[1:k]的次序需要的计算量更少，则用此次序替换原来计算A\[1:k]的次序，得到的计算A\[1:n]的计算量将比按最优次序计算所需计算量更少，这是个矛盾。（反证法）同理可知子链A\[k+1:n]也满足

因此，矩阵连乘积计算次序问题的最优解包含着其子问题的最优解。这种性质称为**最优子结构性质**。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。

**2.建立递归关系**

设计动态规划算法的第二步是递归地定义最优值。对于矩阵连乘积的最优计算次序问题，设计算A\[i:j],1<=i<=j<=n,所需的最少数乘次数为m\[i]\[j]，则原问题的最优值为m\[1]\[n]。

当i=j时，可利用最优子结构性质计算m\[i]\[j].事实上，若计算A\[i:j]的最优次序在Ak和A（k+1）之间断开，i<=k<j,则m\[i]\[j]+m\[k+1]\[j]+p(i-1)\*pk\*pj。由于在计算时并不知道断开点k的位置，所以k还未定。不过k的位置只有j-i种可能，即k∈｛i,i+1，…，j-1｝。因此，k是这j-i个位置中使计算量达到最小的那个位置。

若将对应于m\[i]\[j]的断开位置k记为**s\[i]\[j]** ，在计算出最优值m\[i]\[j]后，可递归地由s\[i]\[j]构造出相应的最优解。

**3. 计算最优值**

```java
public static void matrixChain(int []p, int [][]m, int [][]s)
{
	int n=p.length-1;
	for(int i=1;i<=n;i++) m[i][i]=0;
	for(int r=2;r<=n;r++)
		for(int i=1;i<=n-r+1;i++){
			int j=i+r-1;
			m[i][j]=m[i+1][j]+p[i-1]*p[k]*p[j];
			s[i][j]=i;
			for(int k=i+1;k<j;k++){
				int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];
				if(t<m[i][j]){
					m[i][j]=t;
					s[i][j]=k;
				}
			}
		}
}
```

算法matrixChain的主要计算量取决于算法中对r,i和k的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n<sup>3</sup>)。因此该算法的计算时间上界为O(n<sup>3</sup>)。算法所占用的空间显然为O(n<sup>2</sup>)。由此可见，动态规划法比穷举搜索法有效得多。

**4. 构造最优解**

动态规划算法的第四部是构造问题的最优解。算法matrixChain只是计算出了最优值，并未给出最优解。也就是说，通过算法matrixChain的计算，只知道最少乘次数，还不知道具体应按什么次序做矩阵乘法才能达到最少的数乘次数。

事实上，算法matrixChain已记录了构造最优解所需要的全部信息。

下面的算法traceback按算法matrixChain计算出的断点矩阵s指示的加括号方式输出计算A\[i:j]的最优计算次序。

```java
public static void traceback(int [][]s, int i, int j)
{
	if(i==j)return;
	traceback(s,i,s[i][j]);
	traceback(s,s[i][j]+1,j);
	System.out.println("Multiply A"+i+","+s[i][j]+"and A"+(s[i][j]+1)+","+j);
}
```

## 3.2 动态规划算法的基本要素

从计算矩阵连乘积最优计算次序的动态规划算法可以看出，该算法的有效性依赖于问题本身所具有的两个重要性质：`最优子结构`性质和`子问题重叠`性质。从一般的意义上讲，问题所具有的这两个重要性质是该问题可用动态规划算法求解的基本要素。

下面着重研究动态规划算法的这两个基本要素以及动态规划法的变形——备忘录方法。

**1. 最优子结构**

设计动态规划算法的第一步通常是刻画最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。

在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。算法考查的子问题空间规模较小。

**2. 重叠子问题**

可用动态规划算法求解的问题应该具备的另一个基本要素是子问题的重叠性质。也就是说，在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正式李永乐这种子问题的重叠性质，对每一个子问题都只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。

**3. 备忘录方法**

备忘录方法是动态规划算法的变形。与动态规划算法一样，备忘录方法用表格保存已解决的子问题的答案，在下次需要解此子问题时，只要简单地查看该子问题的解答，而不必重新计算。

与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法是自底向上递归的。因此，备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。

备忘录方法为每个子问题建立一个记录项，初始化时，该记录项存入一个特殊值，表示该子问题尚未求解。在求解过程中，对每个待求子问题，首先查看其相应的记录项。若记录项中存储的是初始化时存入的特殊值，则表示该子问题是第一次遇到，此时计算出该子问题的解，并保存在其相应的记录项中，以备以后查看。若记录项中存储的已不是初始化时存入的特殊值，则表示该子问题已被计算过，其相应的记录项中存储的是该子问题的解答。此时，只要从记录项中取出该子问题的解答即可，而不必重新计算。

下面算法memorizedmatrixChain是解矩阵连乘积最优计算次序问题的备忘录方法：

```java
public static int memorizedmatrixChain(int n)
{
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			m[i][j]=0;
	return lookupChain(1,n);
}
private static int lookupChain(int i, int j)
{
	if(m[i][j]>0)return m[i][j];
	if(i==j)return 0;
	int u=lookupChain(i+1,j)+p[i-1]*p[i]*p[j];
	s[i][j]=i;
	for(int k=i+1;k<j;k++){
		int t=lookupChain(i,k)+lookupChain(k+1,j)+p[i-1]*p[k]*p[j];
		if(t<u){
			u=t;
			s[i][j]=k;}
	}
	m[i][j]=u;
	return u;
}
```

一般来讲，当一个问题的所有子问题都至少要解一次时，用动态规划算法比用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常可利用其规则的表格存取方式，减少动态规划算法的计算时间和空间需求。当子问题空间中的部分子问题可不必求解时，用备忘录方法则较有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的子问题。

## 3.3 最长公共子序列

一个给定序列的**子序列**是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=｛x1,x2,…，xm｝，则另一序列Z=｛z1,z2,…，zk｝，X的子序列是指存在一个严格递增的下表序列｛i1，i2，…，ik｝使得对于所有j=1，2，…，k有zj=x(ij)。例如，序列Z=｛B,C,D,B｝是序列X=｛A,B,C,B,D,A,B｝的子序列，相应的递增下标序列为｛2，3，5，7｝。

给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的**公共子序列**。

**最长公共子序列问题**：给定两个序列X和Y，找出X和Y的最长公共子序列。

**1. 最长公共子序列的结构**

穷举搜索法是最容易想到的算法。对X的所有子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列。而且在检查过程中记录最长的公共子序列，X的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的每个子序列相应于下标集｛1，2，…，m｝的一个子集。因此，共有2^m个不同子序列，从而穷举搜索法需要指数时间。

事实上，最长公共子序列问题具有最优子结构性质。

设序列X=｛x1，x2，…，xm｝和Y=｛y1，y2，…，yn｝的最长公共子序列为Z=｛z1，z2，…，zk｝，则

（1）若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列；

（2）若xm≠yn且zk≠xm，则Z是Xm-1和Y的最长公共子序列；

（3）若xm≠yn且zk≠yn，则Z是X和Yn-1的最长公共子序列。

其中，X<sub>m-1</sub>=｛x1，x2，…，x<sub>m-1</sub>｝；Y<sub>n-1</sub>=｛y1，y2，…，y<sub>n-1</sub>｝；Z<sub>k-1</sub>=｛z1，z2，…，z<sub>k-1</sub>｝。

由此可见，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。

**2. 子问题的递归结构**

由最长公共子序列问题的最优子结构性质可知，要找出X和Y的最长公共子序列，可按以下方式递归计算：

当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm（=yn）即可得X和Y的最长公共子序列。

当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的最长公共子序列及X和Yn-1的一个最长公共子序列。这两个公共子序列较长者即为X和Y的最长公共子序列。

由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如在计算X和Y的最长公共子序列时，可能要计算X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算Xm-1和Yn-1的最长公共子序列。

首先建立子问题最优值的递归关系。用c\[i]\[j]记录序列Xi和Yj的最大公共子序列的长度。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故此时c\[i]\[j]=0.在其他情况下，由最优子结构性质可建立递归关系如下：

```
c[i][j] = 0 i=0,j=0
	c[i-1][j-1]+1 i,j>0;xi=yj
	max{c[i][j-1],c[i-1][j]} i,j>0;xi≠yj
```

**3. 计算最优值**

直接利用递归式容易写出计算c\[i]\[j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。

计算最长公共子序列长度的动态规划算法lcsLength以X和Y作为输入。输出两个数组c和b。其中c\[i]\[j]存储Xi和Yj的最长公共子序列的长度，b\[i]\[j]记录c\[i]\[j]的值是由哪一个子问题的解得到的，这在构造最长公共子序列时要用到。问题的最优值，即X和Y的最长公共子序列的长度记录于c\[m]\[n]中。

```java
public static int lcsLength(char []x, char[]y, int [][]b)
{
	int m=x.length-1;
	int n=y.length-1;
	int [][]c=new int [m+1][n+1];
	for(int i=1;i<=m;i++)c[i][0]=0;
	for(int i=1;i<=n;i++)c[0][i]=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			if(x[i]==y[j]){
				c[i][j]=c[i-1][j-1]+1;
				b[i][j]=1;
			}
			else if(c[i-1][j]>=c[i][j-1]){
				c[i][j]=c[i-1][j];
				b[i][j]=2;
			}
			else{
				c[i][j]=c[i][j-1];
				b[i][j]=3;
			}
		}
	return c[m][n];
}
```

由于每个数组单元的计算耗费O（1）时间，算法lcsLength耗时O(mn)。

**4. 构造最长公共子序列**

由算法lcsLength计算得到的数组b可用于快速构造序列X和Y的最长公共子序列。首先从b\[m]\[n]开始，依其值在数组b中搜索。当b\[i]\[j]=1时，表示X<sub>i</sub>和Y<sub>j</sub>的最长公共子序列是由X<sub>i-1</sub>和Y<sub>j-1</sub>的最长公共子序列在尾部加上xi所得到的子序列；当b\[i]\[j]=2时，表示Xi和Yj的最长公共子序列与X<sub>i-1</sub>和Y<sub>j</sub>的最长公共子序列相同；当b\[i]\[j]=3时，表示Xi和Yj的最长公共子序列与Xi和Y<sub>j-1</sub>的最长公共子序列相同。

```java
public static void lcs(int i, int j, char []x, int [][]b)
{
	if(i==0||j==0)return;
	if(b[i][j]==1){
		lcs(i-1,j-1,x,b);
		System.out.print(x[i]);
	}
	else if(b[i][j]==2)lcs(i-1,j,x,b);
		else lcs(i,j-1,x,b);
}
```

算法lcs中，每一次递归调用使i或j减1，因此算法的计算时间为O（m+n）。

**5. 算法的改进**

只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。事实上，在计算c\[i]\[j]时，只用到数组c的第i行和第i-1行。因此，用两行的数组空间就可以计算出最长公共子序列的长度。进一步的分析还可以将空间需求减至O(min｛m,n｝)。

## 3.4 凸多边形最优三角剖分

**凸多边形最优三角剖分的问题**：给定凸多边形P={v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n-1</sub>},以及定义在由多边形的边和弦组成的三角形上的权函数w。要求确定该凸多边形的三角剖分，使得该三角剖分所对应的权，即该三角剖分中诸三角形上权之和为最小。

可以定义三角形上各种各样的权函数w。例如，w（v<sub>i</sub> v<sub>j</sub> v<sub>k</sub>）=| v<sub>i</sub> v<sub>j</sub> | + | v<sub>j</sub> v<sub>k</sub> | + | v<sub>k </sub>v<sub>i</sub> |

其中，|v<sub>i</sub>v<sub>j</sub>|是点v<sub>i</sub>到v<sub>j</sub>的欧氏距离。相应于此权函数的最优三角剖分即为最小弦长三角剖分。

**1. 三角剖分的结构及其相关问题**

凸多边形的三角剖分和表达式的完全加括号方式之间具有非常紧密的联系。正如所看到的，矩阵连乘积的最优计算次序问题等价于矩阵链的最优完全加括号方式。这些问题之间的相关性可从它们所对应的完全二叉树的同构性看出。

一个表达式的完全加括号方式相应于一棵完全二叉树，称为表达式的语法树。例如，完全加括号的矩阵连乘积（A<sub>1</sub>（A<sub>2</sub>A<sub>3</sub>）(A<sub>4</sub>(A<sub>5</sub>A<sub>6</sub>))）相应的语法树如图3-4（a）所示。

![1555141709433](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1555141709433.png)

语法树每一个叶节点表示表达式中的一个原子。在语法树中，若一结点有一个表示表达式E<sub>l</sub>的左子树，以及一个表示表达式E<sub>r</sub>的右子树，则以该结点为根的子树表示表达式（E<sub>l</sub>E<sub>r</sub>）。因此，有n个原子的完全加括号表达式对应于唯一的一棵有n个叶节点的语法树，反之亦然。

凸多边形{v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n-1</sub>}的三角剖分也可以用语法树表示。例如，图3-4（a）中凸多边形的三角剖分可用3-4（b）所示语法树表示。该语法树的根结点为边v<sub>0</sub>v<sub>6</sub>。三角剖分中的弦组成其余的内结点。多边形中除v<sub>0</sub>v<sub>6</sub>边外的各边都是语法树的一个叶节点。树根v<sub>0</sub>v<sub>6</sub>是三角形v<sub>0</sub>v<sub>3</sub>v<sub>6</sub>的一条边。该三角形将原多边形分为三个部分：三角形v<sub>0</sub>v<sub>3</sub>v<sub>6</sub>，凸多边形｛v<sub>0</sub>, v<sub>1</sub>, …, v<sub>3</sub>｝和凸多边形｛v<sub>3</sub>, v<sub>4</sub>, …, v<sub>6</sub>｝。三角形v<sub>0</sub>v<sub>3</sub>v<sub>6</sub>的另外两条边，即弦v<sub>0</sub>v<sub>3</sub>和v<sub>3</sub>v<sub>6</sub>为根的两个儿子。以它们为根的子树表示凸多边形｛v<sub>0</sub>, v<sub>1</sub>, …, v<sub>3</sub>｝和凸多边形｛v<sub>3</sub>, v<sub>4</sub>, …, v<sub>6</sub>｝的三角剖分。

在一般情况下，凸n边形的三角剖分对应于一棵有n-1个叶结点的语法树产生相应的凸n边形的三角剖分。也就是说，凸n边形的三角剖分与有n-1个叶节点的语法树之间存在一一对应的关系。同样，n个矩阵的完全加括号乘积也与n个叶节点的语法树之间存在一一对应关系，所以，n个矩阵的完全加括号乘积和凸（n+1）边形的三角剖分之间也存在一一对应关系。矩阵连乘积A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>中的每个矩阵A<sub>i</sub>都对应凸（n+1）边形中的一条边v<sub>i-1</sub>v<sub>i</sub>。三角剖分中的一条弦v<sub>i</sub>v<sub>j</sub>, i<j, 对应于矩阵连乘积A[i+1:j]。

事实上，矩阵连乘积的最优计算次序是凸多边形最优三角剖分问题的特殊情形。对于给定的矩阵链A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>，定义与之相应的凸（n+1）边形P={v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n-1</sub>}，使得矩阵A<sub>i</sub>与凸多边形中的边v<sub>i-1</sub>v<sub>i</sub>一一对应。若矩阵A<sub>i</sub>的维数p<sub>i-1</sub>*p<sub>i</sub>，i=1,2,…,n, 则定义三角形v<sub>i</sub>v<sub>j</sub>v<sub>k</sub>上的权函数值为：w(v<sub>i</sub>v<sub>j</sub>v<sub>k</sub>)=p<sub>i</sub>p<sub>j</sub>p<sub>k</sub>。依此权函数的定义，凸多边形P的最优三角剖分所对应的语法树给出矩阵链A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>的最优完全加括号方式。

**2. 最优子结构性质**

凸多边形的最优三角剖分问题有最优子结构性质。

事实上，若凸(n+1)边形P={v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n-1</sub>}的最优三角剖分T包含三角形v<sub>0</sub>v<sub>k</sub>v<sub>n</sub>，1<=k<=n-1，则T的权为三个部分的和：三角形v<sub>0</sub>v<sub>k</sub>v<sub>n</sub>的权，还有子多边形｛v<sub>0</sub>, v<sub>1</sub>, …, v<sub>k</sub>｝和｛v<sub>k</sub>, v<sub>k+1</sub>, …, v<sub>n</sub>｝的权之和。可以断言，由T所确定的这两个子多边形的三角剖分也是最优的。因为若有｛v<sub>0</sub>, v<sub>1</sub>, …, v<sub>k</sub>｝和｛v<sub>k</sub>, v<sub>k+1, …, v<sub>n</sub>｝的更小权的三角剖分将导致T不是最优三角剖分的矛盾。

**3. 最优三角剖分的递归结构**

首先，定义t\[i][j]，1<= i < j <=n为凸子多边形｛v<sub>i</sub>, v<sub>i+1</sub>, …, v<sub>j</sub>｝的最优三角剖分所对应的权函数值，即其最优值。为方便起见，设退化的多边形｛v<sub>i-1</sub>, v<sub>i</sub>｝具有权值0.据此定义，要计算的凸（n+1）边形P的最优权值为t\[1][n]。

t\[i][j]的值可以利用最优子结构性质递归地计算。由于退化的2顶点多边形的权值为0，所以t\[i][i]=0,i=1, 2, …, n。当j-1>=1时，凸子多边形｛v<sub>i-1</sub>, v<sub>i</sub>, …, v<sub>j</sub>}至少有3个顶点。由最优子结构性质，t\[i][j]应为t\[i][k]的值加上t\[k+1][j]的值，再加上三角形v<sub>i-1</sub>v<sub>k</sub>v<sub>j</sub>的权值，其中i<=k<=j-1。由于计算时还不知道k的确切位置，而k的所有可能位置只有j-i个，因此，可以在这个j-i个位置中选出使t\[i][j]值达到最小的位置，因此t\[i][j]可以递归地定义为

```
t[i][j]=0 i=j
	min{t[i][k]+t[k+1][j]+w(vi vj vk)} i<j
```

**4. 计算最优值**

与矩阵连乘积中计算m\[i][j]的递归式进行比较，容易看出，除了权函数的定义外，t\[i][j]与m\[i][j]的递归式完全一样。因此，只要对计算m\[i][j]的算法matrixChain进行很小的修改就完全适用于计算t\[i][j]。

下面描述的计算凸（n+1）边形P={v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n</sub>}的最优三角剖分的动态规划算法minWeightTriangulation以凸多边形P={v<sub>0</sub>,v<sub>1</sub>,…,v<sub>n</sub>｝的定义在三角形上的权函数w作为输入。

```java
public static void minWeightTriangulation(int n, int[][] t, int[][] s)
{
    for(int i=1;i<=n;i++) t[i][i]=0;
    for(int r=2;r<=n;r++)
        for(int i=1;i<=n-r+1;i++){
            int j=i+r-1;
            t[i][j]=t[i+1][j]+w(i-1,i,j);
            s[i][j]=i;
            for(int k=i+1;k<i+r-1;k++){
                int u=t[i][k]+t[k+1][j]+w(i-1,k,j);
                if(u<t[i][j]){
                    t[i][j]=u;
                    s[i][j]=k;
                }
            }
        }
}
```

与算法matrixChain一样，算法minWeightTriangulation占用O（n<sup>2</sup>）空间，耗时O（n<sup>3</sup>）。

## 3.5 多边形游戏

多边形游戏是一个单人玩的游戏，开始时有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符+或*。所有边依次用整数从1到n编号。

游戏第一步，将一条边删除。随后n-1步按以下方式操作：

（1）选择一条边E以及由E连接着的两个顶点V<sub>1</sub>和V<sub>2</sub>；

（2）用一个新的顶点取代边E以及由E连接着的两个顶点V<sub>1</sub>和V<sub>2</sub>。将由顶点V<sub>1</sub>和V<sub>2</sub>的整数值通过边E上的运算得到的结果赋予新顶点。

最后所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。

问题：对于给定的多边形，计算最高得分。

该问题与上一节中讨论过的凸多边形最优三角剖分问题类似，但两者的最优子结构性质不同。多边形游戏问题的最优子结构性质更具有一般性。

**1. 最优子结构性质**

设所给的多边形的顶点和边的顺时针序列为op[1], v[1], op[2], v[2], …, op[n], v[n] 其中，op[i]表示第i条边所对应的运算符，v[i]表示第i个顶点上的数值，i=1~n。

在所给的多边形中，从顶点i(1<=i<=n)开始，长度为j（链中有j个顶点）的顺时针链p(i,j)可表示为 v[i], op[i+1], …, v[i+j-1]

如果这条链的最后一次合并运算在op[i+s]处发生（1<=s<=j-1），则可在op[i+s]处将链分割为两个子链p(i,s)和p(i+s,j-s)。

设m<sub>1</sub>是对子链p(i,s)的任意一种合并方式得到的值，而a和b分别是在所有可能的合并中得到的最小值和最大值。m<sub>2</sub>是p（i+s，j-s）的任意一种合并方式得到的值，而c和d分别是在所有可能的合并中得到的最小值和最大值。依此定义有a<=m<sub>1</sub><=b,c<=m<sub>2</sub><=d

由于子链p(i,s)和p(i+s,j-s)的合并方式决定了p(i,j)在op[i+s]处断开后的合并方式，在op[i+s]处合并后其值为m=(m<sub>1</sub>)op\[i+s](m<sub>2</sub>)

(1)当op[i+s]='+'时，显然有a+c<=m<=b+d

换句话说，由链p(i,j)合并的最优性可推出子链p(i,s)和p(i+s,j-s)的最优性，且最大值对应于子链的最大值，最小值对应于子链的最小值。

(2)当op[i+s]='*'时，情况有所不同。由于v\[i]可取负整数，子链的最大值相乘未必能得到主链的最大值。但是注意到最大值一定在边界点达到，即min｛ac, ad, bc, bd｝<= m <= max{ac,ad,bc,bd}

换句话说，主链的最大值和最小值可由子链的最大值和最小值得到。例如，当m=ac时，最大主链由它的两条最小子链组成；同理当m=bd时，最大主链由它的两条最大子链组成。无论哪种情形发生，由主链的最优性均可推出子链的最优性。

综上可知多边形游戏问题满足最优子结构性质。

**2. 递归求解**

由前面的分析可知，为了求链合并的最大值，必须同时求子链合并的最大值和最小值。因此，在整个计算过程中，应同时计算最大值和最小值。

设m[i,j,0]是链p(i,j)合并的最小值，而m[i,j,1]是最大值。若最优合并在op[i+s]处将p(i,j)分为两个长度小于j的子链p(i,i+s)和p(i+s,j-s),且从顶点i开始的长度小于j的子链的最大值和最小值均已计算出。为叙述方便，记

a=m[i,i+s,0]

b=m[i,i+s,1]

c=m[i+s,j-s,0]

d=m[i+s,j-s,1]

(1)当op[i+s]='+'时，

m[i,j,0]=a+c

m[i,j,1]=b+d

(2)当op[i+s]='*'时，

m[i,j,0]=min{ac,ad,bc,bd}

m[i,j,1]=max{ac,ad,bc,bd}

综合（1）和（2），将p(i,j)在op[i+s]处断开的最大值记为maxf（i,j,s）,最小值记为minf(i,j,s),则

minf(i,j,s) = a+c op[i+s]='+'

​	min{ac,ad,bc,bd} op[i+s]='*'

maxf(i,j,s) = b+d op[i+s]='+'

​	max{ac,ad,bc,bd} op[i+s]=‘*’

由于最优断开位置s有1<=s<=j-1的j-1种情况，由此可知

m[i,j,0]=min(1<=s<j){minf(i,j,s)} 1<=i,j<=n

m[i,j,1]=max(1<=s<j){maxf(i,j,s)} 1<=i,j<=n

初始边界值显然为

m[i,1,0] = v[i] 1<=i<=n

m[i,1,1] = v[i] 1<=i<=n

由于多边形是封闭的，在上面的计算中，当i+s>n时，顶点i+s实际编号为(i+s)mod n。按上述递推式计算出的m[i,n,1]即为游戏首次删去的第i条边后得到的最大得分。

**3. 算法描述**

基于以上讨论可设计解多边形游戏问题的动态规划算法如下：

```java
private static void minMax(int i, int s, int j){
    int[] e = new int [5];
    int a = m[i][s][0],
    b=m[i][s][1],
    r=(i+s-1)%n+1,
    c=m[r][j-s][0],
    d=m[r][j-s][1];
    if(op[r]=='r'){
        minf=a+c;
        maxf=b+d;
    }
    else{
        e[1]=a*c;
        e[2]=a*d;
        e[3]=b*c;
        e[4]=b*d;
        minf=e[1];
        maxf=e[1];
        for(int k=2;k<5;k++){
            if(minf>e[k])minf=e[k];
            if(maxf<e[k])maxf=e[k];
        }
    }
}
public static int polyMax(){
    for(int j=2;j<=n;j++)
        for(i=1;i<=n;i++)
            for(int s=1;s<j;s++){
                minMax(i,s,j);
                if(m[i][j][0]>minf)m[i][j][0]=minf;
                if(m[i][j][1]<maxf)m[i][j][1]=maxf;
            }
    int temp=m[1][n][1];
    for(int i=2;i<=n;i++)
        if(temp<m[i][n][1])temp=m[i][n][1];
    return temp;
}
```

**4. 计算复杂性分析**

与凸多边形最优三角剖分问题类似，上述算法需要O(n<sup>3</sup>)的计算时间。

## 3.6 图像压缩

在计算机中常用像素点灰度值序列｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>｝表示图像。其中，整数p<sub>i</sub>(1<=i<=n)表示像素点i的灰度值。通常灰度值的范围是0~255。因此，需要用8位表示一个像素。

图像的变位压缩格式将所给的像素点序列｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>｝分割成m个连续段S<sub>1</sub>, S<sub>2</sub>, …, S<sub>m</sub>。第i个像素段S<sub>i</sub>中（1<=i<=m）,有l[i]个像素，且该段中每个像素都只用b[i]位表示。设t[i]=(k=1~i-1)∑l[k], l<=i<=m, 则第i个像素段S<sub>i</sub>为

S<sub>i</sub> = {p<sub>t[i]+1</sub>, …, p<sub>t[i]+l[i]</sub>} l<=i<=m

设h<sub>i</sub>=⌈log(max(p<sub>k</sub>)+1)⌉ (t[i]+1<=k<=t[i]+l[i]), 则h<sub>i</sub><=b[i]<=8。因此需要用3位表示b[i]，l<=i<=m。如果限制l<=l[i]<=255，则需要用8位表示l[i],1<=i<=m。因此，第i个像素段所需的存储空间为l[i]\*b[i]+11位.按此格式存储像素序列｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>｝，需要（i=1~m）∑l\[i]\*b[i]+11m位的存储空间。

**图像压缩问题**要求确定像素序列｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>｝的最优分段，使得依此分段所需的存储空间最少。其中，0<=p<sub>i</sub><=256,1<=i<=n.每个分段的长度不超过256位。

**1. 最优子结构性质**

设l[i],b[i],1<=i<=m是｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>｝的最优分段。显而易见，l[1],b[1]是｛p<sub>1</sub>, p<sub>2</sub>, …, p<sub>l[1]</sub>｝的最优分段，且l[i],b[i],2<=i<=m是｛p<sub>l[1]+1</sub>,…, p<sub>n</sub>｝的最优分段。即图像压缩问题满足最优子结构性质。

**2. 递归计算最优值**

设s[i],1<=i<=n是像素序列｛p<sub>1</sub>,…, p<sub>s</sub>｝的最优分段所需的存储位数。由最优子结构性质易知

s[i] = min{s[i-k]+k*bmax(i-k+1,i)}+11 (1<=k<=min(i,256))

其中bmax（i，j）=⌈log（max{p<sub>k</sub>}+1）⌉ (i<=k<=j)。

据此可设计解图像压缩问题的动态规划算法如下：

```java
static final int lmax = 256;
static final int header = 11;
static int m;

public static void compress(int p[], int s[], int l[], int b[]){
    int n=p.length-1;
    s[0]=0;
    for(int i=1;i<=n;i++){
        b[i]=length(p[i]);
        int bmax = b[i];
        s[i]=s[i-1]+bmax;
        l[i]=1;
        for(int j=2;j<=i&&j<=lmax;j++){
            if(bmax<b[i-j+1])bmax=b[i-j+1];
            if(s[i]>s[i-j]+j*bmax){
                s[i]=s[i-j]+j*bmax;
                l[i]=j;
            }
        }
        s[i]+=header;
    }
}

private static int length(int i){
    int k=1;
    i=i/2;
    while(i>0){
        k++;
        i=i/2;
    }
    return k;
}
```



**3. 构造最优解**

算法compress中用l[i]和b[i]记录了最优分段所需的信息。最优分段长度和像素位数分别存储于l[n]和b[n]中。其前一段的段长度和像素位数存储于l[n-l[n]]和b[n-l[n]]中。依次类推，由算法计算出的l和b可在O(n)时间内构造出相应的最优解。具体算法可实现如下：

```java
private static void traceback(int n, int s[], int l[]){
    if(n==0)return;
    traceback(n-l[n],s,l);
    s[m++]=n-l[n];
}

public static void output(int s[], int l[], int b[]){
    int n=s.length - 1;
    System.out.println("The optimal value is "+s[n]);
    m=0;
    traceback(n,s,l);
    s[m]=n;
    System.out.println("Decomposed into"+m+"segments");
    for(int j=1;j<=m;j++){
        l[j]=l[s[j]];
        b[j]=b[s[j]];
    }
    for(int j=1;j<=m;j++)
        System.out.println(l[j]+"."+b[j]);
}
```

**4. 计算复杂性**

算法compress显然只需O(n)空间。由于算法compress中对j的循环次数不超过256，故对每一个确定的i，可在O（1）时间内完成min｛s[i-j]+j*bmax(i-j+1,i)｝ (1<=j<=min(i,256))的计算。因此，整个算法所需的计算时间为O(n)。

## 3.7 电路布线

在一块电路板的上、下两端分别有n个接线柱。根据电路设计，要求用导线（i,π（i））将上端接线柱i与下端接线柱π（i）相连。其中，π（i），1<=i<=n，是｛1，2，…，n｝的一个排列。导线（i,π（i））称为该电路板上的第i条连线。对于任何1<=i<j<=n，第i条连线和第j条连线相交的充分且必要的条件是π（i）>π（j）。

在制作电路板时，要求将这n条连线分部到若干个绝缘层上，在同一层上的连线不相交。**电路布线问题**要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets=｛（i, π(i)）, 1<=i<=n｝的最大不相交子集。

**4. 计算复杂性**

算法mnset显然需要O(n<sup>2</sup>)计算时间和O（n^2^）空间。算法traceback需要O(n)时间。

## 3.8 流水作业调度

n个作业｛1，2，…，n｝要在两台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是现在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi，1<=i<=n。**流水作业调度问题**要求确定这个作业的最优加工顺序，使得从第一个作业在机器M1开始加工，到最后一个作业在机器M2上加工完成所需时间最少。

**2.递归计算最优值**

T(N，0)=（1<=i<=n）min{ai + T(N-{i}, bi)}

**3. 流水作业调度的Johnson法则**

如果作业i和j满足min｛bi, aj｝>=min{bj, ai},则称作业i和j满足Johnson不等式。如果作业i和j不满足Johnson不等式，则交换作业i和作业j的加工顺序后，作业i和j满足Johnson不等式。

必存在最优调度π，使得作业π（i）和π（i+1）满足Johnson不等式。这样的调度π称为满足Johnson法则的调度。

进一步可以证明，调度π满足Johnson法则当且仅当对任意i<j，有min{b<sub>π(i)</sub>, a<sub>π(j)</sub>}>=min{b<sub>π(j)</sub>, a<sub>π(i)</sub>}

由此可知，任意两个满足Johnson法则的调度具有相同的加工时间。从而所有满足Johnson法则的调度均为最优调度。至此，将流水作业调度问题转化为求满足Johnson法则的调度问题。

**5.计算复杂性分析**

算法flowShop的主要计算时间花在对作业集的排序。因此，在最坏情况下算法flowShop所需的计算时间为O（nlogn），所需空间显然为O(n).

## 3.9 0-1背包问题

**0-1背包问题**：给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问：应该如何选择装入背包的物品，使得装入背包中物品，使得装入背包中的物品的总价值最大？

在选择装入背包的物品时，对每种物品i只有两种选择，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。因此，该问题称为0-1背包问题。

此问题的形式化描述是，给定C>0，wi>0,vi>0,1<=i<=n，要求找出n元0-1向量（x1，x2，…，xn），xi∈｛0，1｝，1<=i<=n, 使得∑wixi<=C, 而且∑vixi达到最大。因此，0-1背包问题是一个特殊的整数规划问题。

**4. 计算复杂性分析**

从计算m（i,j）的递归式容易看出，上述算法knapsack需要O(nc)计算时间，而算法traceback需要O(n)计算时间。

改进后算法计算时间复杂性为O(2^n^)。在这种情况下，改进后算法的计算时间复杂性为O(min{nc，2^n^})。

## 3.10 最优二叉搜索树

最优二叉搜索树问题是对有序集S及其存取概率分布（a0,b1,a1,…，bn，an），在所有表示有序集S的二叉搜索树中找出一棵具有最小平均路长的二叉搜索树。

**4. 计算复杂性**

算法中用到3个二维数组m，s和w，故所需的空间为O(n^2^)。算法的主要计算量在于计算min｛m（i, k-1）+m(k+1, j)｝。对于固定的r，它需要计算时间O(j-i+1)=O(r+1)。因此算法所耗费的总时间为（r=0\~n-1）∑（i=0\~n-r）∑O(r+1)=O(n^3^)。

事实上，在上述算法中，可以证明（i<=k<=j）min{m(i,k-1) + m(k+1,j) } = ( s\[i][j-1]<=k<=s\[i+1][j] ) min{m(i,k-1)+m(k+1,j)}

由此可对算法做进一步改进，改进后算法obst所需的计算时间为O(n^2^),所需空间为O(n^2^).

第10章将在一般的意义下证明上述改进后算法obst的正确性。

# 第4章 贪心算法

## 4.1 活动安排问题

（***笔记注解：***Q: 感觉这个greedySelector得到的貌似不是最优啊，是我没看懂还是怎么回事？ A: 好吧，没看到它的目的是让容纳的项目最多，而且项目按结束时间排好了，的确是最优……）

## 4.2 贪心算法的基本要素

### 4.2.1 贪心选择性质

### 4.2.2 最优子结构性质

### 4.2.3 贪心算法与动态规划算法的差异

1.0-1背包问题与背包问题

2.贪心算法与动态规划算法的主要差别

0-1背包问题不能用贪心算法，但是背包问题可以。

## 4.3 最优装载

## 4.4 哈夫曼编码

### 4.4.1 前缀码

### 4.4.2 构造哈夫曼编码

### 4.4.3 哈夫曼算法的正确性

## 4.5 单源最短路径

### 4.5.1 算法基本思想

Dijkstra算法

### 4.5.2 算法的正确性和计算复杂性

## 4.6 最小生成树

### 4.6.1 最小生成树性质

Prim算法和Kruskal算法

### 4.6.2 Prim算法

O(n^2^)

### 4.6.3 Kruskal算法

O(eloge)

e=Ω（n^2^）时，Kruskal算法比Prim算法差；e=o(n^2^), Kruskal算法比Prim算法好得多。

## 4.7 多机调度问题

NP完全问题

## 4.8 贪心算法的理论基础

### 4.8.1 拟阵

### 4.8.2 带权拟阵的贪心算法

### 4.8.3 任务时间表问题

# 第5章 回溯法

## 5.1 回溯法的算法框架

### 5.1.1 问题的解空间

### 5.1.2 回溯法的基本思想

旅行售货员问题 NP完全问题

提高回溯法的搜索效率：一是用约束函数在扩展结点处剪去不满足约束的子树；其二是用限界函数剪去得不到最优解的子树。这两类函数统称为剪枝函数。

### 5.1.3 递归回溯

### 5.1.4 迭代回溯

### 5.1.5 子集树与排列树

遍历子集树的算法需Ω（2^n^）计算时间

遍历排列树的算法需要Ω（n!）计算时间

## 5.2 装载问题

子集和问题与划分问题都是NP难的。

装载问题也是NP难的。

## 5.3 批处理作业调度

O(n!)

## 5.4 符号三角形问题

O(n2^n^)

## 5.5 n后问题

## 5.6 0-1背包问题

O(n2^n^)

## 5.7 最大团问题

O(n2^n^)

## 5.8 图的m着色问题

O(nm^n^)

## 5.9 旅行售货员问题

O(n!)

## 5.10 圆排列问题

## 5.11 电路板排列问题

NP难

## 5.12 连续游资问题

## 5.13 回溯法的效率分析

# 第6章 分支限界法

## 6.1 分支限界法的基本思想

1）队列式（FIFO）分支限界法

2）优先队列式分支限界法

