# 第4章 对象序列化

本章讨论一个鲁棒的序列化系统的必要性和使用方法，探索自引用数据、压缩、代码的易维护性等问题的处理方法，同时满足一个实时系统的运行时性能要求。

## 4.1 序列化的需求

序列化是一种将对象从内存中的随机访问格式转换为比特流格式的行为。这些比特流可以在硬盘上存储，或者通过网络传输，之后再恢复为原始格式。

## 4.2 流

在计算机科学中，**流**（stream）指的是一种数据结构，封装了一组有序的数据元素，并允许用户对其进行数据读写。

流可以是**输出流**（output stream）、**输入流**（input stream）或者两者都是。输出流作为用户数据的输出槽，允许数据流用户顺序插入元素，但不能从中读取数据。相反地，输入流作为数据源，允许用户顺序提取元素，但是不提供插入数据的功能。当一个流既是输入流也是输出流时，同时提供插入和读取数据元素的方法。

通常情况下，一个流是其他数据结构或计算资源的接口。例如，**文件输出流**（file output stream）可以封装一个已经打开准备写的文件，提供顺序存储不同类型的数据到磁盘的简单方法。**网络流**（network stream）可以封装一个socket，提供send()和recv()函数的封装，专门用于与用户相关的特定数据类型。

### 4.2.1 内存流

**内存流**（memory stream）封装了内存的缓冲区，通常是动态分配在堆栈上的缓冲区。**输出内存流**（output memory stream）有顺序写入缓冲区的方法，同时提供对缓冲区本身进行读取访问的访问器。通过调用缓冲区访问器，用户可以立即将所有的数据写入流，并发送给另外一个系统，正如socket的send函数。

流解决了序列化的第一个问题：它提供了一个简单方法来创建缓冲区，使用源对象中各个字段的值来填充缓冲区，给远程主机发送这个缓冲区，顺序提取数据，将它们插入到目标对象的合适字段。此外，这个过程没有干扰到目标对象中不应该被改变的任何字段，例如虚函数表指针。

### 4.2.2 字节存储次序的兼容性

并不是所有的CPU存储多字节数字都是按照一样的字节顺序。字节在一个平台上的存储顺序被称为这个平台的**字节序**（endianness），可以是**小端字节序**（litten-endian）或**大端字节序**（big-endian）。小端字节序的平台存储多字节数字是将低序字节存储在起始地址（低位编址）。例如，值为0x12345678的整数存储在地址为0x01000000的内存中，存储方式如图4.1所示

| 值   | 0x78       | 0x56       | 0x34       | 0x12       |
| ---- | ---------- | ---------- | ---------- | ---------- |
| 地址 | 0x01000000 | 0x01000001 | 0x01000002 | 0x01000003 |

最低序的字节0x78首先存储在内存中。这是数字的最小部分，所以这种排列策略称为小端字节序。使用这种策略的平台包括英特尔的x86、x64和苹果的iOS设备。

大端字节序将高序字节存储在起始地址（高位编址）。同样的数字存储在同样的地址，存储方式如图4.2所示。

| 值   | 0x12       | 0x34       | 0x56       | 0x78       |
| ---- | ---------- | ---------- | ---------- | ---------- |
| 地址 | 0x01000000 | 0x01000001 | 0x01000002 | 0x01000003 |

使用这种策略的平台包括Xbox360、PlayStation 3和IBM的PowerPC架构。

> 小窍门：
>
> 当编写一个单一平台的单人游戏时，字节序通常是无关紧要的。但是当在不同字节序的平台之间传输数据时，它成为必须考虑的一个因素。当使用流来传输数据时，一个比较好的策略是流本身决定字节序。然后，当写一个多字节数据类型时，如果平台的字节序与所选择的流字节序不匹配时，在写入流时数据的字节序将被颠倒。同样地，当从流中读数据时，如果平台的字节序与流字节序不相同时，字节序应该被颠倒。

大部分平台提供有效的字节交换算法，有的甚至有内部函数和汇编指令。

### 4.2.3 比特流

上一节所描述的内存流的一个限制是它们只能读写整数字节的数据。当写网络代码时，通常希望用尽可能少的比特来表示数值，这就需要以比特的精度来读写。为此，实现**内存比特流**（memory bit stream）是非常有帮助的，它能够序列化任何比特大小的数据。

## 4.3 引用数据

### 4.3.1 内联或嵌入

一个自定义的序列化函数应该只写vector所包含的数据，而不是序列化vector本身。RAM中的数据可能实际上与RoboCat本身的数据相差很远。然而，当自定义函数序列化它时，它将数据嵌入到RoboCat中一起写入流。因此，这个过程被称为**内联**（inlining）或**嵌入**（embedding）。

如果数据需要与其他对象共享或者被其他对象引用，那么就需要一个更复杂的解决方案，称为链接（linking）。

### 4.3.2 链接

该解决方案是给每个多处引用的对象一个唯一的标识符，然后通过序列化标识符实现这些对象引用的序列化。当网络的另一端反序列化这些对象时，修复例程可以使用该标识符查找引用对象，并将其插入到相应的成员变量。正是由于这个原因，这个过程通常被称为**链接**（linking）。

> 注释：
>
> 当完全实现之后，链接系统和使用它的游戏代码必须容忍收到这样的网络ID，即没有与之映射的对象。因为数据包可以丢失，游戏可能受到一个对象，它的成员变量引用了一个尚未发送的对象。有许多不同的方法来解决这个问题——游戏可以忽略整个对象，或者反序列化这个对象并连接任何可用的引用，将丢失的引用置为空。更复杂的系统可以跟踪空链接的成员变量，这样收到给定网络ID的对象时可以链接它。具体如何选择取决于游戏设计的细节。

## 4.4 压缩

### 4.4.1 稀疏数组压缩

压缩数据的诀窍是去除任何不需要通过网络发送的信息。一个寻找此类信息的好地方是任何稀疏的和不被完全填充的数据结构。

### 4.4.2 熵编码

**熵编码**（entropy encoding）是信息论的一个主题，它利用数据的不确定性进行数据压缩。根据信息论，含有期望数据的数据包比含有非期望数据的数据包蕴含更少的信息或者**熵**。因此，代码在发送期望数据时应当比发送非期望数据需要更少的比特数。

在大多数情况下，花费CPU周期模拟实际游戏比计算数据包中熵的确切取值达到最佳压缩率更重要。

熵编码有许多形式，从简单的，如这里介绍的写死在函数中的，到复杂的，如常用的赫夫曼编码、算术编码、gamma编码、行程编码等。

### 4.4.3 定点

一种称为**定点**（fixed point）数的方法可以将这个任务变得相当简单。定点数是一个数，看起来像整数，但实际上会将其进行缩放和加减来表示一个浮点数。

### 4.4.4 几何压缩

定点压缩利用游戏特定的信息来实现使用尽可能少的比特进行数据序列化。有趣的是，这里再次用到了信息论：因为变量的可能取值有了约束，所以需要较少的比特就可以表示那个信息。序列化任何数据结构时，只要它的内容有约束，就可以使用这种技术。

许多几何数据类型就属于这种情况。本节讨论四元数和变换矩阵。**四元数**（quaternion）是一种数据结构，包括四个浮点数，用于表示三维空间中的旋转。

## 4.5 可维护性

仅仅关注带宽效率可能会导致某些地方出现丑陋的代码。所以需要一些权衡考虑，牺牲一点点效率来换取代码的可维护性。

### 4.5.1 抽象序列化方向

### 4.5.2 数据驱动的序列化