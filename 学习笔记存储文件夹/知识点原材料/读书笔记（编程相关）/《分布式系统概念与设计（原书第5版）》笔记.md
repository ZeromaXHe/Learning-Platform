# 第1章 分布式系统的特征

## 1.1 简介

我们定义的分布式系统有如下显著特征：

**并发**：在一个计算机网络中，执行并发程序是常见的行为。用户可以在各自的计算机上工作，在必要时共享诸如Web页面或文件之类的资源。系统处理共享资源的能力会随着网络资源（例如，计算机）的增加而提高。在本书的许多地方将描述有效部署这种额外能力的方法。对共享资源的并发执行程序的协调也是一个重要和重复提及的主题。

**缺乏全局时钟**：在程序需要协作时，它们通过交换消息来协调它们的动作。密切的协作通常取决于对程序动作发生的时间的共识。但是，事实证明，网络上的计算机与时钟同步所达到的准确性是有限的，即没有一个正确时间的全局概念。这是通信仅仅是通过网络发送消息这个事实带来的直接结果。定时问题和它们的解决方案将在第14章描述。

**故障独立性**：所有的计算机系统都可能出故障，一般由系统设计者负责为可能的故障设计结果。分布式系统可能以新的方式出现故障。网络故障导致网上互连的计算机的隔离，但这并不意味着它们停止运行，事实上，计算机上的程序不能够检测到网络是出现故障还是网络运行得比通常慢。类似的，计算机的故障或系统中程序的异常终止（崩溃），并不能马上使与它通信的其他组件了解。系统的每个组件会单独地出现故障，而其他组件还在运行。分布式系统的这个特征所带来的后果将是贯穿本书的一个反复提及的主题。

## 1.2 分布式系统的例子

### 1.2.1 Web搜索

Google，Web搜索技术上的市场领导者，在支持用于搜索（与其他Google应用和服务，如Google Earth）的复杂的分布式系统基础设施的设计上已做出了巨大的努力。它代表了计算历史上最大和最复杂的分布式系统设施之一。该基础设施最突出的亮点包括：

- 一个底层物理设施，它由超大数目的位于全世界多个数据中心的联网计算机组成；
- 一个分布式文件系统，支持超大文件，并根据搜索和其他Google应用的使用方式（特别是在文件中以快速而持久的速度读取）进行了深度优化；
- 一个相关的结构化分布式存储系统，它提供对超大数据集的快速访问；
- 一个锁服务，它提供诸如分布式加锁和协定等分布式系统功能；
- 一个编程模式，它支持对底层物理基础设施上的超大并行和分布式计算的管理。

### 1.2.2 大型多人在线游戏

针对大型多人在线游戏，提出了许多解决方案：

- 可能有点出人意料，最大的在线游戏EVE Online，采用了客户-服务器体系架构，在一个集中式服务器上维护了游戏世界状态的单个拷贝，供运行在玩家终端或其他设备上的客户程序访问。为了支持大量客户，服务器自身是一个复杂的实体，拥有由上百个计算机结点组成的集群结构（该客户-服务器方法在1.4节详细讨论，集群方法将在1.3.4节讨论）。
- 其他MMOG采用更多的分布式体系结构，宇宙被划分到大量（可能是超多）服务器上，这些服务器可能地理上分散部署。接着，用户基于当前的使用模式和到服务器的网络延迟（例如基于地理最近）被动态地分配到一个特定服务器。这种体系结构风格被EverQuest采用，它通过增加新的服务器，可自然地扩展。
- 大多数商业系统采用上述两个模型中的一个，但研究者现在也在寻找更极端的体系结构，即不基于客户-服务器原理而是基于对等技术采用完全分散的方法。采用对等技术，意味着每个参与者贡献（存储和处理）资源来容纳游戏。对对等解决方案的进一步研究将推迟到第2章和第10章。

### 1.2.3 金融交易

注意，此类系统的重点是对感兴趣数据项的通信和处理。感兴趣数据项在分布式系统中称为**事件**。这样的系统通常采用**分布式基于事件的系统**。

## 1.3 分布式系统的趋势

分布式系统正在经历巨大的变化，这可追溯到一系列有影响力的趋势：

- 出现了泛在联网技术；
- 出现了无处不在计算，它伴随着分布式系统中支持用户移动性的意愿；
- 对多媒体设备的需求增加；
- 把分布式系统作为一个设施。

### 1.3.1 泛在联网和现代互联网

最终结果是联网已成为一个泛在的资源，设备可以在任何时间、任何地方被连接（如果愿意）。

互联网和其支持的服务的实现，使得必须开发实用解决方案来解决分布式系统中的许多问题（包括在1.5节中定义的大多数问题）。

### 1.3.2 移动和无处不在计算

设备小型化和无线网络方面的技术进步已经逐步使得小型和便携式计算设备集成到分布式系统中。

这些设备大部分具有可携带性，再加上它们可以在不同地方方便地连接到网络的能力，使得**移动计算**成为可能。移动计算是指用户在移动或访问某个非常规环境时执行计算任务的性能。

**无处不在计算**是指在对用户的物理环境（包括家庭、办公室和其他自然环境）中存在的多个小型、便宜的计算设备的利用。

利用适当的系统基础设施，用户能在其访问地用他们携带的设备完成一些简单的任务。原则上，用户可以利用无线LAN或有线的以太网链接从笔记本电脑上把文件发送到同一台打印机。

这个场景说明了支持**自发互操作**的需求，依靠自发互操作，设备之间的关联被例行地创建和拆除，定位和使用所访问地的设备（如打印机）是一个这方面的例子。这种情况下的最大挑战是让互操作快速和方便（即自发），即使用户可能在一个他们以前从来没有访问过的环境。这意味着，要让访问者的设备在访问地的网络上通信，并将设备与合适的本地设备相关联——这个过程称为**服务发现**。

### 1.3.3 分布式多媒体系统

人们可以期望分布式多媒体系统支持离散类型媒体（如图片或正文消息）的存储、传输和展示。分布式多媒体系统应该能对连续类型媒体（如音频和视频）完成相同的功能，即它应该能存储和定位音频或视频文件，并通过网络传输它们（可能需要以实时的方式，因为流来自摄像机），从而能向用户展示多种媒体类型，以及在一组用户中共享多种类型的媒体。

**网络播放**（webcasting）是分布式多媒体技术的应用。

### 1.3.4 把分布式计算作为一个公共设施

随着分布式系统基础设施的不断成熟，不少公司在推广这样的观点：把分布式资源看成一个商品或公共设施，把分布式资源和其他公共设施（例如水或电）进行类比。采用这个模型，资源通过合适的服务提供者提供，能被最终用户有效地租赁而不是拥有。这种模型可以应用到物理资源和更多的逻辑服务上。

关于计算作为公共设施，术语**云计算**（cloud computing）被用来刻画其前景。云被定义成一组基于互联网的应用，并且足以满足大多数用户需求的存储和计算服务的集合，这使得用户能大部分或全部免除本地数据存储和应用软件的使用。

**网格计算**也能被看成一种云计算。大量的术语是同义的，偶尔定义得不清楚，但网格计算通常被看成是云计算这种更通用模式的先驱，它只是偏重于支持科学计算。

## 1.4 关注资源共享



## 1.5 挑战

### 1.5.1 异构性

互联网使得用户能在大量异构计算机和网络上访问应用程序。下面这些均存在异构性（即存在多样性和差别）：

- 网络；
- 计算机硬件；
- 操作系统；
- 编程语言；
- 由不同开发者完成的软件实现。

虽然，互联网由多种不同种类的网络组成，但因为所有连接到互联网的计算机都使用互联网协议来相互通信，所以这些不同网络的区别被屏蔽了。例如，连接在以太网中的计算机要在以太网上实现互联网协议，而在另一种网络上的计算机需要在该网络上实现互联网协议。第3章将解释互联网协议如何在多种不同的网络上实现。

整型等数据类型在不同种类的硬件上可以有不同的表示方法。例如，整数的字节顺序就有两种表示方法。如果要在不同硬件上运行的两个程序之间交换消息，那么就要处理它们在表示上的不同。

虽然互联网上所有的计算机的操作系统均需要包含互联网协议的实现，但可以不为这些协议提供相同的应用编程接口。例如，UNIX中消息交换的调用与Windows中的调用是不一样的。

不同的编程语言使用不同的方式表示字符和数据结构（如数组和记录）。如果想让用不同语言编写的程序能够相互通信，那么必须解决这些差异。

不同开发者只有使用公共标准，他们编写的程序才能相互通信。例如，网络通信和消息中的基本数据项和数据结构的表示均要使用公共标准。所以，要制订和采用公共标准，就像互联网协议一样。

**中间件** 术语**中间件**是指一个软件层，它提供了一个编程抽象，同时屏蔽了底层网络、硬件、操作系统和编程语言的异构性。

除了解决异构性问题外，中间件为服务器和分布式应用的程序员提供了一致的计算模型。这些模型包括远程对象调用、远程事件通知、远程SQL访问和分布式事务处理。

**异构性和移动代码** 术语**移动代码**指能从一台计算机发送到另一台计算机，并且目的计算机上运行的代码，Java applet是一个例子。

### 1.5.2 开放性

计算机系统的开放性是决定能否以不同的方式被扩展和重新实现的特征。分布式系统的开放性主要取决于新的资源共享服务能被增加和供多种客户程序使用的程度。

除非软件开发者能获得系统组件的关键软件接口的规约和文档，否则无法实现开放性。一句话，**发布**关键接口。

互联网协议的设计者引入了一系列称为“征求意见文档”（Request For Comments，RFC）的文档，每个文档有一个编号。RFC不是唯一的发布方式，例如，万维网联盟（World Wide Web Consortium，W3C）开发和发布了与Web工作相关的标准。

按这种方式支持资源共享的系统之所以称为**开放的分布式系统**，主要是强调它们是可扩展的。它们可通过在网络中增加计算机实现在硬件层面的扩展，通过引入新的服务、重新实现旧的服务实现在软件层次上的扩展，最终使得应用程序能共享资源。

### 1.5.3 安全性

分布式系统中维护和使用的众多信息资源对用户具有很高的内在价值，因此它们的安全相当重要。信息资源的安全性包括三个部分：机密性（防止泄漏给未授权的个人）、完整性（防止被改变或被破坏）、可用性（防止对访问资源的手段的干扰）。

下列两个安全方面所面临的挑战目前还没有圆满解决：

**拒绝服务攻击**

**移动代码的安全性**

### 1.5.4 可伸缩性

分布式系统可在不同的规模（从小型企业内部网到互联网）下有效且高效地运转。如果资源数量和用户数量激增，系统仍能保持其有效性，那么该系统就称为**可伸缩的**。

可伸缩分布式系统的设计面临下列挑战：

**控制物理资源的开销**：当对资源的需求增加时，应该可以花费合理的开销扩展系统以满足要求。

**控制性能损失**：如果数据集的大小与系统中的用户或资源数量成正比，设想一下这些数据的管理。采用层次结构的算法其伸缩性要好于使用线性结构的算法。但即使使用层次结构，数量的增加仍将导致一些性能上的损失，即访问有层次地结构化数据的时间是O(log n)，当n是数据集的大小时，对一个可伸缩的系统，最大的性能损失莫过于此。

**防止软件资源用尽**：用做互联网（IP）地址（互联网上的计算机地址）的数字是缺乏伸缩性的一个例子。

**避免性能瓶颈**：通常，算法应该是分散型，以避免性能瓶颈。

### 1.5.5 故障处理

分布式系统的故障是部分的，也就是说，有些组件出了故障而有些组件运行正常。因此故障的处理相当困难。本书将讨论下列处理故障的技术：

**检测故障**：有些故障能被检测到。例如，校验和可用于检测消息或文件中出错的数据。第2章将解释其他一些故障（例如，互联网上一台远程服务器的崩溃）是很难甚至不可能被检测到。面临的挑战是如何在有故障出现的情况下进行管理，这些故障不能被检测到但可以被猜到。

**掩盖故障**：有些被检测到的故障能被隐藏起来或降低它的严重程度。下面是隐藏故障的两个例子：

1）消息在不能到达时进行重传。

2）将文件数据写入两个磁盘，如果一个磁盘损坏，那么另一个磁盘的数据仍是正确的。

降低故障严重程度的例子是丢掉被损坏的消息，这样，该消息可以被重传。读者可能意识到，隐藏故障的技术不能保证在最坏情况下有效。例如，第二个磁盘上的数据可能也坏了，或信息无论怎样重传都不能在合理的时间内到达。

**容错**：服务的客户能被设计成容错的，这通常也涉及用户要容忍错误。

**故障恢复**：恢复设计软件的设计，以便在服务器崩溃后，永久数据的状态能够被恢复或“回滚”。

**冗余**：利用冗余组件，服务可以实现容错。

### 1.5.6 并发性

在分布式系统中，服务和应用均提供可被客户共享的资源。因此，可能有几个客户同时视图访问一个共享资源的情况。

在分布式系统中，代表共享资源的任何一个对象必须负责确保它在并发环境中操作正确，这不仅适用于服务器，也适用于应用中的对象。因此，持有未打算用于分布式系统的对象实现的程序员必须做一些事情，使得对象在并发环境中能安全使用。

### 1.5.7 透明性

透明性被定义成为对用户和应用程序员屏蔽分布式系统的组件的分离性，使系统被认为一个整体，而不是独立组件的集合。透明性的含义对系统软件的设计有重大的影响。

**访问透明性**：用相同的操作访问本地资源和远程资源。

**位置透明性**：不需要知道资源的物理或网络位置就能访问它们。

**并发透明性**：几个进程能够并发地使用共享资源进行操作且互不干扰。

**复制透明性**：使用资源的多个实例提升可靠性和性能，而用户和应用程序员无需知道副本的相关信息。

**故障透明性**：屏蔽错误，不论是硬件组件故障还是软件组件故障，用户和应用程序都能够完成它们的任务。

**移动透明性**：资源和客户能够在系统内移动而不会影响用户或程序的操作。

**性能透明性**：当负载变化时，系统能被重新配置以提高性能。

**伸缩透明性**：系统和应用能够进行扩展而不改变系统结构或应用算法。

最重要的两个透明性是访问透明性和位置透明性，它们的有无对分布式资源的利用有很大影响。有时它们统一称为**网络**透明性。

### 1.5.8 服务质量

一旦提供给用户他们要求的服务的功能，例如在一个分布式系统中的文件服务，我们就能继续探询所提供的服务质量。系统的主要的非功能特性，即影响客户和用户体验的服务质量是**可靠性**、**安全性**和**性能**。满足变化的系统配置和资源可用性的**适应性**已被公认为服务质量的一个重要方面。

可靠性和安全性问题在设计大多数计算机系统时是关键的。服务质量的性能方面源于及时性和计算吞吐量，但它已被重定义成满足及时性保证的能力。

## 1.6 实例研究：万维网

# 第2章 系统模型

**物理模型**考虑组成系统的计算机和设备的类型以及它们的互连，不涉及特定的技术细节。

**体系结构模型**是从系统的计算元素执行的计算和通信任务方面来描述系统；这里计算元素或是指单个计算机或是指通过网络互联的计算机集合。**客户-服务器**和**对等模型**是分布式系统中两种最常使用的体系结构模型。

**基础模型**采用抽象的观点描述大多数分布式系统面临的单个问题的解决方案。

在分布式系统中没有全局时间，所以不同计算机上时钟未必给出相同的时间。进程间的所有通信是通过消息完成的。计算机网络上的消息通信会受延迟的影响，会遇到多种故障，对安全方面的攻击很脆弱。这些问题通过下面三个模型论述：

- 交互模型处理分布式系统的性能问题并解决在分布式系统种设置时间约束的困难，例如消息传送的时间约束。
- 故障模型视图给出进程和通信通道故障的一个精确的规约。它定义了可靠的通信和正确的进程。
- 安全模型讨论对进程和通信通道的各种可能的威胁。它引入了安全通道的概念，安全通道能保证在上述威胁下通信的安全。

## 2.1 简介

**物理模型**是描述系统的一个最显式的方法，它从计算机（和其他设备，例如移动电话）及其互联的网络方面考虑系统的硬件组成。

**体系结构模型**从系统的计算元素执行的计算的通信任务方面来描述系统。

**基础模型**采用抽象的观点描述分布式系统的某个方面。本章介绍考察分布式系统三个重要方面的基础模型：**交互模型**，它考虑在系统元素之间通信的结构和顺序；**故障模型**，它考虑一个系统可能不能正确操作的方式；**安全模型**，它考虑如何保护系统使其不受到正确操作的干扰或不被窃取数据。

> **分布式系统的困难和威胁** 下面是分布式系统设计者要面对的一些问题。
>
> **使用模式的多样性**：系统的组件会承受各种工作负载。系统的有些部分可能断线或连接不稳定。一些应用对通信带宽和延迟有特殊的需求，例如，多媒体应用。
>
> **系统环境的多样性**：分布式系统必须能容纳异构的硬件、操作系统和网络。网络可能在性能上有很大不同，如无线网的速度只达到局域网的几分之一。必须支持不同规模的系统，从几十台计算机到上百万台计算机。
>
> **内部问题**：包括非同步的时钟、冲突的数据更新、多种涉及系统单个组件的软硬件故障模式。
>
> **外部威胁**：包括对数据完整性、保密性的攻击以及服务拒绝攻击。

## 2.2 物理模型

物理模型是从计算机和所用网络技术的特定细节中抽象出来的分布式系统底层硬件元素的表示。

**基线物理模型**：最小物理模型是一组可扩展的计算机结点，这些结点通过计算机网络相互连接进行所需的消息传递。

在这个基线模型之上，我们能有效地识别出三代分布式系统。

**早期的分布式系统**

**互联网规模的分布式系统**

**当代的分布式系统**

| 分布式系统 | 早期                   | 互联网规模                         | 当代                                       |
| ---------- | ---------------------- | ---------------------------------- | ------------------------------------------ |
| 规模       | 小                     | 大                                 | 超大                                       |
| 异构性     | 有限（相对同构的配置） | 从平台、语言和中间件方面来说都较大 | 维度增加，包括体系结构中完全不同的风格     |
| 开放性     | 不属于优先考虑的事     | 相当重要，引入一系列标准           | 重要的研究挑战，已有的标准不能包含复杂系统 |
| 服务质量   | 起步阶段               | 相当重要，引入一系列服务           | 重要的研究挑战，已有的服务不能包含复杂系统 |

## 2.3 体系结构模型

一个系统的体系结构是用独立指定的组件以及这些组件之间的关系来表示的结构。整体目标是确保结构能满足现在和将来可能的需求。主要关心的是系统可靠性、可管理性、适应性和性价比。建筑物的体系结构设计有类似的方面，不仅要决定它的外观，还决定其总体结构和体系结构风格（哥特式、新古典式、现代式），并为设计提供一个一致的参考框架。

本节将描述分布式系统采用的几种主要的体系结构模型，即分布式系统的体系结构风格。特别的，为读者全面理解客户-服务器模型、对等方法、分布式对象、分布式组件、分布式基于事件的系统以及这些风格之间的不同之处奠定基础。

### 2.3.1 体系结构元素

为了理解一个分布式系统的基础构建块，有必要考虑下面四个关键问题：

- 在分布式系统中进行通信的实体是什么？
- 它们如何通信，特别是使用什么**通信范型**？
- 它们在整个体系结构中扮演什么（可能改变的）角色，承担什么责任？
- 它们怎样被映射到物理分布式基础设施上（它们被**放置**在哪里）？

**通信实体** 上述前两个问题是理解分布式系统的关键；什么是通信和这些实体如何相互通信为分布式系统开发者定义了一个丰富的设计空间。它对从面向系统和面向问题的角度解决第一个问题是有帮助的。

**对象**：在分布式面向对象的方法中，一个计算由若干交互的对象组成，这些对象代表分解给定问题领域的自然单元。对象通过接口被访问，用一个相关的接口定义语言（IDL）提供定义在一个对象上的方法的规约。分布式对象已经成为分布式系统研究的一个主要领域，第5章和第8章将进一步讨论这个话题。

**组件**：因为对象的引入，许多重要的问题已被认为与分布式对象有关，组件技术的出现是对这些弱点的一个直接响应。组件类似于对象，因为它们为构造分布式系统提供面向问题的抽象，也是通过接口被访问。关键的区别在于组件不仅指定其（提供的）接口而且给出关于其他组件/接口的假设，其他组件/接口是组件完成它的功能必须有的。换句话说，组件使得所有依赖显式化，为系统的构造提供一个更完整的合约。

**Web服务**：Web服务代表开发分布式系统的第三种重要的范型。Web服务与对象和组件紧密相关，也是采取基于行为封装和通过接口访问的方法。但是，相比而言，通过利用Web标准表示和发现服务，Web服务本质上是被集成到万维网（即W3C）的。



**通信范型** 我们现在转向在分布式系统中实体如何通信，考虑三种通信范型：

- 进程间通信；
- 远程调用；
- 间接通信。

**进程间通信**指的是用于分布式系统进程之间通信的相对底层的支持，包括消息传递原语、直接访问由互联网协议提供的API（套接字编程）和对多播通信的支持。第4章将详细讨论这样的服务。

**远程调用**代表分布式系统中最常见的通信范型，覆盖一系列分布式系统中通信实体之间基于双向交换的技术，包括调用远程操作、过程或方法。进一步的定义参见下面内容（详细讨论见第5章）：

**请求-应答协议**是一个有效的模式，它加在一个底层消息传递服务之上，用于支持客户-服务器计算。特别的，这样的协议通常涉及一对消息的交换，消息从客户到服务器，接着从服务器返回客户，第一个消息包含在服务器端执行的操作的编码，然后是保存相关参数的字节数组，第二个消息包含操作的结果，它也被编码成字节数组。这种范型相对原始，实际上仅被用于嵌入式系统，对嵌入式系统来说性能是至关重要的。这个方法也被用在5.2节描述的HTTP协议中。正如下面讨论的，大多数分布式系统将选择使用远程过程调用或者远程方法调用，但注意底层的请求-应答交换支持两种方法。

**远程过程调用**（Remote Procedure Call，RPC）的概念，最初由Birrell和Nelson[1984]提出，代表了分布式计算中的一个主要突破。在RPC中，远程计算机上进程中的过程能被调用，好像它们是在本地地址空间中的过程一样。底层RPC系统隐藏了分布的重要方面，包括参数和结果的编码和解码、消息的传递和保持过程调用所要求的语义。这个方法直接而且得体地支持了客户-服务器计算，其中，服务器通过一个服务接口提供一套操作，当这些操作本地可用时客户直接调用这些操作。因此，RPC系统（在最低程度上）提供访问和位置透明性。

**远程方法调用**（Remote Method Invocation，RMI）非常类似于远程过程调用，但它应用于分布式对象的环境。用这种方法，一个发起调用的对象能调用一个远程对象中的方法。与RPC一样，底层的细节都对用户隐藏。不过，通过支持对象标识和在远程调用中传递对象标识符作为参数，RMI实现做得更多。它们也从与面向对象语言（见第5章相关讨论）的密集集成中获得更多的好处。

上述技术具有一个共同点：通信代表发送者和接收者之间的双向关系，其中，发送者显式地把消息/调用送往相关的接收者。接收者通常了解发送者的标识，在大多数情况下，双方必须在同时存在。相比而言，已经出现若干技术，这些技术支持间接通信，通过第三个实体，允许在发送者和接收者之间的深度解耦合。尤其是：

- 发送者不需要知道他们在发送给谁（**空间解耦合**）。
- 发送者和接收者不需要同时存在（**时间解耦合**）。

第6章将详细讨论间接通信。

间接通信的关键技术包括：

**组通信**：组通信涉及信息传递给若干个接收者，因此是支持一对多通信的多方通信范型。组通信依赖组抽象，一个组在系统中用一个组标识符表示。接收方通过加入组，就能选择性接收发送到组的消息。发送者通过组标识符发送消息给组，因此，不需要知道消息的接收者。组通常也要维护组成员，具有处理组成员故障的机制。

**发布-订阅系统**：发布-订阅系统共享同一个关键的特征，即提供一个中间服务，有效确保由生产者生成的信息被路由到需要这个信息的消费者。

**消息队列**：虽然发布-订阅系统提供一种一对多风格的通信，但消息队列提供了点对点服务，其中生产者进程能发送消息到一个指定的队列，消费者进程能从队列中接收消息，或被通知队列里有新消息到达。因此，队列是生产者和消费者进程的中介。

**元组空间**：元组空间提供了进一步的间接通信服务，并支持这样的模型——进程能把任意的结构化数据项（成为元组）放到一个持久元组空间，其他进程可以指定感兴趣的模式，从而可以在元组空间读或者删除元组。因为元组空间是持久的，读操作者和写操作者不需要同时存在。这种风格的编程，也被称为生成通信，由Gelernter[1985]作为一种并行编程范式引入。已经开发了不少分布式实现，采用了客户-服务器-风格的实现或采用了更分散的对等方法。

**分布式共享内存**：分布式共享内存（Distributed Shared Memory，DSM）系统提供一种抽象，用于支持在不共享物理内存的进程之间共享数据。提供给程序员的是一套熟悉的读或写（共享）数据结构的抽象，就好像这些数据在程序员自己本地的地址空间一样，从而提供了高层的分布透明性。分布式共享内存的概述在第6章介绍。

| 通信实体（什么在通信） |                | 通信范型（它们怎样通信） |           |           |
| ---------------------- | -------------- | ------------------------ | --------- | --------- |
| 面向系统的实体         | 面向问题的实体 | 进程间通信               | 远程调用  | 间接通信  |
| 结点                   | 对象           | 消息传递                 | 请求-应答 | 组通信    |
| 进程                   | 组件           | 套接字                   | RPC       | 发布-订阅 |
|                        | Web服务        | 多播                     | RMI       | 消息队列  |
|                        |                |                          |           | 元组空间  |
|                        |                |                          |           | DSM       |

**角色与责任** 在一个分布式系统中，进程，或者说，对象、组件、服务，包括Web服务相互交互完成一个有用的活动，例如支持一次聊天会话。在这样做的时候，进程扮演给定的角色，在建立所采用的整体体系结构时，这些角色是基本的。本节我们考察两种起源于单个进程角色的体系结构风格：客户-服务器风格和对等风格。

**客户-服务器**

**对等体系结构**



**放置** 最后要考虑的问题是诸如对象或服务这样的实体是怎样映射到底层的物理分布式基础设施上的，物理分布式基础设施由大量的机器组成，这些机器通过一个任意复杂的网络互联。从决定分布式系统特性的角度而言，放置是关键的，这些特性大多数与性能相关，也包括其他特性如可靠性和安全性。

从机器和机器内部进程的角度看，在哪里放置一个给定客户或服务器的问题是需要仔细设计的。放置需要考虑实体间的通信模式、给定机器的可靠性和它们当前的负载、不同机器之间的通信质量等。必须用有说服力的应用知识来确定放置，有些通用的指导方针可以用来获得一个优化的解决方案。因此，我们主要关注下列放置策略，它们能显著地改变一个给定设计的特征：

- 将服务映射到多个服务器；
- 缓存；
- 移动代码；
- 移动代理。

**将服务映射到多个服务器**：服务可以实现成一个单独主机上的几个服务器进程，在必要时进行交互以便客户进程提供服务。服务器可以将服务所基于的对象集分区，然后将这些分区分布到各个服务器上；或者服务器可以在几个主机上维护复制的对象集。

**缓存**：缓存用于存储最近使用的数据对象，这些被存储的数据对象比对象本身更接近一个客户或特定的一组客户。当服务器接收一个新对象时，就将它存入缓存，必要的时候会替换缓存中已存在的对象。当客户进程需要一个对象时，缓存服务首先检查缓存，如果缓存中有最新的拷贝可用就提供缓存中的对象；如果缓存没有可用的对象，才去取一个最新的拷贝。每个客户都可以配置缓存或者将缓存放置在由几个客户共享的代理服务器上。

**移动代码**

**移动代理**：移动代理是一个运行的程序（包括代码和数据），它从一台计算机移动到网络上另一台计算机，代表某人完成诸如信息搜集之类的任务，最后返回结果。一个移动代理可能多次调用所访问地点的本地资源——例如，访问一个数据库条目。

### 2.3.2 体系结构模式

体系结构模式构建在上述讨论过的相对原始结构元素之上，提供组合的、重复出现的结构，这些结构在给定的环境中能运行良好。它们未必是完整的解决方案，但当与其他模式组合时，它们会更好地引导设计者给出一个给定问题域的解决方案。

这是一个大的主题，已经有了许多用于分布式系统的体系结构模式。本节中，我们给出分布式系统中几个关键的体系结构模型，包括分层体系结构（layering architecture）、层次化体系结构（tiered architecture）和瘦客户相关的概念（包括虚拟网络计算的特定机制）。我们也把Web服务当做一个体系结构模式进行了考察，给出了其他可以应用在分布式系统中的模式。

**分层** 分层的概念是一个熟悉的概念，与抽象紧密相关。在分层方法中，一个复杂的系统被分成若干层，每层利用下层提供的服务。

~~~mermaid
graph TB
	a[应用\服务]-->b[中间件]
	b-->c[操作系统]
	subgraph 平台
		c-->d[计算机和网络硬件]
	end
~~~

图2-7引入了重要的术语——**平台和中间件**，具体定义如下：

- 一个服务于分布式系统和应用的平台由最底层的硬件和软件层组成。这些底层为其上层提供服务，它们在每个计算机中都是独立实现的，提供系统的编程接口，方便进程之间的通信和协调。主要的例子有Intel x86/Windows、Intel x86/Solaris、Intel x86/Mac OS X、Intel x86/Linux 和 ARM/Symbian。
- 1.5.1节把中间件定义成一个软件层，其目的是屏蔽异构性，给应用程序员提供方便的编程模型。中间件表示成一组计算机上的进程或对象，这些进程或对象相互交互，实现分布式应用的通信和资源共享支持。中间件提供有用的构造块，构造在分布式系统中一起工作的软件组件。特别的，它通过对抽象的支持，如远程方法调用、进程组之间的通信、事件的通知、共享数据对象在多个协作的计算机上的分布、放置和检索、共享数据对象的复制以及多媒体数据的实时传送，提升应用程序通信活动的层次。我们将在2.3.3节讲述这个重要的话题。

**层次化体系结果** 层次化体系结构与分层体系结构是互补的。分层将服务垂直成抽象层，而层次化是一项组织给定层功能的技术，它把这个功能放在合适的服务器上，或者作为第二选择放在物理节点上。

我们先查看两层和三层体系结构概念。为了说明这些概念，考虑如下对一个给定应用的功能分解：

- 表示逻辑，涉及处理用户交互和修改呈现给用户的应用视图；
- 应用逻辑，涉及与应用相关的（也称为业务逻辑，虽然这个概念不仅仅限于业务应用）详细的应用特定处理；
- 数据逻辑，涉及应用的持久存储，通常在一个数据库管理系统中。

现在考虑用客户-服务器技术实现这样一个应用。图2-8a和图2-8b分别给出了相关的两层和三层体系结构解决方案，以便于比较。

~~~mermaid
graph LR
	subgraph 服务器
	a1(应用和数据管理)
	a2(应用和数据管理)
	end
	g(用户视图) --- a1
	c(控制和数据操纵) --- a2
~~~

~~~mermaid
graph LR
	subgraph 应用服务器
	a1(应用逻辑)
	a2(应用逻辑)
	end
	subgraph 数据库服务器
	d(数据库管理器)
	end
	g1(用户视图和控制) --- a1
	g2(用户视图和控制) --- a2
	a1 --- d
	a2 --- d
~~~

在两层解决方案中，上面提及的三方面必须被分到两个进程（客户和服务器）中。通常通过分隔应用逻辑来完成这个划分，把一些应用逻辑放在客户端，剩下的放在服务器端（虽然其他解决方案也是可以的）。这个模式的好处是具有交互的低延迟，仅有调用操作的消息交换，不足是将应用逻辑分离到不同的进程，带来的后果是一部分逻辑不能被另一部分直接调用。

在三层解决方案中，有从逻辑元素到物理服务器的一对一映射，因此，例如，应用逻辑放在一个地方，能提高软件的可维护性。每一层也都有定义明确的角色。缺点是增加了管理三个服务器的复杂性，也增加了与每个操作相关的网络流量和延迟。

*AJAX的作用*：在1.6节中，我们介绍了AJAX（Asynchronous Javascript And XML）是Web所使用的标准客户-服务器交互方式的扩展。AJAX满足了Javascript前端程序（运行在Web浏览器中）和基于服务器的后端程序（拥有描述应用状态的数据）之间的细粒度通信的需要。

**瘦客户** 分布式计算的趋势是将复杂性从最终用户设备移向互联网服务。这点在向云计算（见第1章）发展的趋势中最明显，在上面讨论的层次化体系结构中也能看到。这个趋势导致了对**瘦客户**概念的兴趣，它使得能以很少的对客户设备的假设或需求，获得对复杂网络化服务的访问，这些服务可以通过云解决方案提供。更具体来说，术语瘦客户指的是一个软件层，在执行一个应用程序或访问远程计算机上的服务时，由执行一个应用程序或访问远程计算机上的服务时，由该软件层提供一个基于窗口的本地用户界面。瘦客户体系结构的主要缺点是：在交互频繁的图形活动（如CAD和图像处理）中，因为网络和操作系统的延迟，用户感受到的延迟会因为在瘦客户和应用进程之间传输图像和向量信息而增大到不可接受的程度。

这个概念导致**虚拟网络计算**（Virtual Network Computing，VNC）的出现。

**其他经常出现的模式** 如上所述，现在已有大量的体系结构模式，且它们已被文档化。这里给出一些关键的例子。

- **代理**（proxy）模式是分布式系统中经常出现的模式，其主要用于支持远程过程调用或远程方法调用的位置透明性。用这种方法，一个代理在本地地址空间中被创建，用于代表远程对象。这个代理提供与远程对象一样的接口，程序员调用这个代理对象，因此无需了解交互的分布式特性。
- Web服务中的业务代理（brokerage）的使用能被看成是一个在可能很复杂的分布式基础设施中支持互操作性的体系结构模式。特别地，这个模式是由服务提供商、服务请求者和服务代理（提供与请求的服务一致的服务）三部分组成。
- **反射**（reflection）模式在分布式系统中作为支持内省（系统的动态发现的特性）和从中调停（动态修改结构或行为的能力）的手段而被持续地使用。

### 2.3.3 相关的中间件解决方案

中间件的任务是为分布式系统的开发提供一个高层的编程抽象，并且通过分层，对底层基础设施中的异构性提供抽象，从而提升互操作性和可移植性。中间件解决方案时基于2.3.1节引入的体系结构模型，也支持更复杂的体系结构模式。本节我们简要回顾一下现在存在的中间件类别，为在本书的其他部分进一步研究这些解决方案做好准备。

**中间件的类别** 远程过程调用包，（如Sun RPC，第5章）和组通信（如ISIS，第6章和第18章）属于最早的中间件实例。从那以后，出现了大量不同风格的中间件，大部分都基于上面介绍的体系结构模型。

| 主类                   | 子类       | 系统例子                           |
| ---------------------- | ---------- | ---------------------------------- |
| 分布式对象（第5、8章） | 标准       | RM-ODP                             |
|                        | 平台       | CORBA                              |
|                        | 平台       | Java RMI                           |
| 分布式组件（第8章）    | 轻量级组件 | Fractal                            |
|                        | 轻量级组件 | OpenCOM                            |
|                        | 应用服务器 | SUN EJB                            |
|                        | 应用服务器 | CORBA组件模型                      |
|                        | 应用服务器 | JBoss                              |
| 发布-订阅系统（第6章） |            | CORBA事件服务<br />Scribe<br />JMS |
| 消息队列（第6章）      |            | Websphere MQ<br />JMS              |
| Web服务（第9章）       | Web服务    | Apache Axis                        |
|                        | 网格服务   | Globus Toolkit                     |
| 对等（第10章）         | 路由覆盖网 | Pastry                             |
|                        | 路由覆盖网 | Tapestry                           |
|                        | 应用特定的 | Squirrel                           |
|                        | 应用特定的 | OceanStore                         |
|                        | 应用特定的 | Ivy                                |
|                        | 应用特定的 | Gnutella                           |

**中间件的限制** 许多分布式应用完全依赖中间件提供的服务来支持应用的通信和数据共享需求。

通过依靠中间件支持的开发，能大大简化分布式系统的编程，但系统可依赖性的一些方面要求应用层面的支持。

Saltzer、Reed和Clarke的一篇经典论文[Saltzer et al. 1984]对分布式系统的设计给出了类似的、有价值的观点，他们称之为“端到端争论”。可将他们的陈述表述为：

> 一些与通信相关的功能，可以只依靠通信系统终点（end point）的应用的知识和帮助，即可完整、可靠地实现。因此，将这些功能作为通信系统的特征不总是明智的（虽然由通信系统提供一个不完全版本的功能有时对性能提高是有用的）。

可以看出他们的论点与通过引入适当的中间件层将所有通信活动从应用编程中抽象出来的观点是相反的。

争论的关键是分布式程序正确的行为在很多层面上依赖检查、错误校正机制和安全手段，其中有些要求访问应用的地址空间的数据。任何企图在通信系统中单独完成的检查将只能保证部分正确性。因此，可能在应用程序中重复同样的任务，降低了编程效率，更重要的是增加了不必要的复杂性并要执行冗余的计算。

这个争论给中间件设计者带来一个实际的两难困境，而且给定当代分布式系统中种类繁多的应用（和相关的环境条件）（见第1章），这些困难与日剧增。本质上，底层中间件行为与一个给定应用或应用集的需求和相关环境上下文（如底层网络的状态和风格）有关。这个看法推动了对上下文感知和中间件自适应解决方案的兴趣。

## 2.4 基础模型

上面的各种系统模型完全不同，但具有一些基本特性。特别是，所有的模型都由若干进程组成，这些进程通过在计算机网络上发送消息而相互通信，所有的模型都共享下列设计需求：实现进程及网络的性能和可靠性特征，确保系统中资源的安全性。本节给出基于基本特性的模型，利用这些模型，我们能更详细地描述系统可能展示的特征、故障和安全风险。

通常，为了理解和推理系统行为的某些方面，一个基础模型应该仅包含我们要考虑的实质性成分。这样一个模型的目的是：

- 显式地表示有关我们正在建模的系统的假设。
- 给定这些假设，就什么是可能的、什么是不可能的给出结论。结论以通用算法或要确保的特性的形式给出。特性成立的保证依赖于逻辑分析和（适当时候的）数学证明。

我们希望在我们的基本模型中提取的分布式系统情况能解决下列问题：

**交互**：计算在进程中发生，进程通过传递消息交互，并引发进程之间的通信（信息流）和协调（活动的同步和排序）。在分布式系统的分析和设计中，我们特别关注这些交互。交互模型必须反映独立进程相互配合的准确性受限于这些延迟，受限于在分布式系统中很难跨所有计算机维护同一时间概念。

**故障**：只要分布式系统运行的任一计算机上出现故障（包括软件故障）或连接它们的网络出现故障，分布式系统的正确操作就会受到威胁。我们的模型将对这些故障进行定义和分类。这为分析它们潜在效果以及设计能容忍每种类型故障的系统奠定了基础。

**安全**：分布式系统的模块特性和开放性将其暴露在外部代理和内部代理的攻击下。我们的安全模型对发生攻击的形式给出了定义并进行了分类，为分析对系统的威胁以及设计能抵御这些威胁的系统奠定了基础。

### 2.4.1 交互模型

2.3节对系统体系结构的讨论表明分布式系统由多个以复杂方式进行交互的进程组成。例如：

- 多个服务器进程能相互协作提供服务，前面提到的例子有域名服务（它将数据分区并复制到互联网中的服务器上）和Sun的网络信息服务（它在局域网的几个服务器上保存口令文件的复制版本）。
- 对等进程能相互协作获得一个共同的目标。例如，一个语音会议系统，它以类似的方式分布音频数据流，但它有严格的实时限制。

大多数程序员非常熟悉**算法**的概念——采取一系列步骤以执行期望的计算。简单的程序由算法控制，算法中每一步都有严格的顺序。由算法决定程序的行为和程序变量的状态。这样的程序作为一个进程执行。由多个上面所说的进程组成的分布式系统是很复杂的。它们的行为和状态能用**分布式算法**描述——分布式算法定义了组成系统的每个进程所采取的步骤，**包括它们之间消息的传递**。消息在进程之间传递以便在它们之间传递信息并协调它们的活动。

本节讨论分布式系统中影响进程交互的两个重要因素：

- 通信性能经常是一个限制特性。
- 不可能维护一个全局时间概念。

**通信通道的性能** 在我们的模型中，通信通道在分布式系统中可用许多方法实现，例如，通过计算机网络上的流或简单消息传递来实现。计算机网络上的通信有下列与延迟（latency）、带宽（bandwidth）和抖动（jitter）有关的性能特征

**计算机时钟和时序事件** 计算机时钟和绝对时间之间有漂移，更重要的是，它们的漂移率互不相同。术语**时钟漂移率**（clock drift rate）指的是计算机时钟偏离绝对参考时钟的比率。

**交互模型的两个变体** 在分布式系统中，很难对进程执行、消息传递或时钟漂移所花的时间设置时间限制。两种截然相反的观点提供了一对简单模型：第一个模型对时间有严格的假设，第二个模型对时间没有假设。

*同步分布式系统*：Hadzilacos和Toueg[1994]定义了一个同步分布式系统，它满足下列约束：

- 进程执行每一步的时间有一个上限和下限。
- 通过通道传递的每个消息在一个已知的时间范围内接收到。
- 每个进程有一个本地时钟，它与实际时间的偏移率在一个已知的范围内。

*异步分布式系统*：许多分布式系统，例如互联网，是非常有用的，但它们不具备同步系统的资格。因此我们需要另一个模型。异步分布式系统是对下列因素没有限制的系统：

- 进程执行速度——例如，进程的一步可能只花费亿万分之一秒，而进程的另一步要花费一个世纪的时间，也就是说，每一步能花费任意长的时间。
- 消息传递延迟——例如，从进程A到进程B传递一个消息的时间可能快得可以忽略，也可能要花费几年时间。换句话说，消息可在任意长时间后接收到。
- 时钟漂移率——时钟漂移率可以是任意的。

**事件排序** 在许多情况下，我们有兴趣知道一个进程中的一个事件（发送或接收一个消息）是发生在另一个进程中的另一个事件之前、之后或同时。尽管缺乏精确的时钟，但系统的执行仍能用事件和它们的顺序来描述。

### 2.4.2 故障模型



