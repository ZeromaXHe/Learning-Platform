Future
多线程讲一下，FutureTask
https://blog.csdn.net/jonnyhsu_0913/article/details/79597251

JDK1.7：

FutureTask实现了Future接口，它的计算实际上是通过Callable接口来实现的，相当于一种可以生成结果的Runnable。

FutureTask任务执行的核心在内部类Sync类中，在Sync类的内部，包含了以下几种状态码：

READY：FutureTask任务创建成功以后，初始状态码；
RUNNING：任务开始启动以后的状态码；
RAN：无论是任务执行成功还是任务执行过程中抛了异常，都将走入到该状态码；
CANCELLED：任务执行过程中被调用innerCancel取消后，进入该状态码；

除此之外，Sync还包含了其他信息：

执行结果：在Sync类中用result字段表示任务执行结果；
异常：用该字段表示任务执行过程中抛出的异常信息；

future的底层实现异步原理
volatile
volatile的底层如何实现，怎么就能保住可见性了？
https://blog.csdn.net/lc13571525583/article/details/90345760

可见性，所谓的可见性就是指可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

==为了保证内存的可见性，使用缓存一致性协议还有一个happends-before关系==

什么是缓存一致性协议呢？
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

volatile是两条实现原则：
1.Lock前缀指令会引起处理器缓存会写到内存
当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中
2.一个处理器的缓存回写到内存会导致其他处理器的缓存失效
处理器使用嗅探技术保证内部缓存 系统内存和其他处理器的缓存的数据在总线上保持一致。

综合上面两条实现原则，我们了解到：如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。

happends-before法则
1.程序次序法则：按照代码顺序执行
2.监视器锁法则：一个unlock操作要先于同一个锁的lock操作
3.volatile变量法则：对volatile域的写入操作happends-before于每一个后续对同一域的读操作
4.线程启动法则：在一个线程里，对Thread.start()的调用会先于Thread.run()；
5.线程终结法则：线程中的任何动作都happends-before于其他线程检测到这个线程已经终结，或者从Thread.join 调用中成功返回，或者Thread.isAlive返回false
中断法则：一个线程调用另一个线程的interrupt.happens-before于被中断的线程发现中断。（通过跑出interruptedException,或者调用isInterrupted和interrupted）
6.终结法则：一个对象的构造函数的结束happends-before于这个对象finalizer的开始。
7.传递性：如果A happens-before于B, 且B happends-before 于C, 则A happens-before 于C

当我们去写一个volatile变量的时候，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中，读一个volatile变量的时候，JMM会把该线程对应的本地内存置为无效，接下来线程从主内存中读取共享变量。两个线程，线程A写一个volatile变量，线程B随后读这个volatile变量。这个过程实际上就是线程A和线程B通过主内存进行通信（线程间通信）

volatile原理
内存屏障

volatile关键字，可见性。
同上

volatile作用，变量不断加一，是否能够并发加正确，非原子性
https://www.cnblogs.com/keeya/p/9255136.html

原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。

在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
　　假如某个时刻变量inc的值为10，
　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
　　那么两个线程分别进行了一次自增操作后，inc只增加了1。

volatile作用和底层如何实现
volatile，经常被问到的一个关键字，他的作用主要有两个，我们一一说明：

1 保证变量在各个线程的可见性，意思就是说这个变量的值一修改，其他线程可以立即得知。而一个普通变量需要先写回主内存，然后其他线程去读取这个值。

2：禁止指令重排序优化。然而它并不能保证原子性，以及运算的线程安全

volatile ，作用，底层， lock 前缀的指令， 多CPU的嗅探机制，多处理器下的缓存一致性协议
https://www.cnblogs.com/awkflf11/p/9218414.html

通过利用工具获得class文件的汇编代码，会发现，标有volatile的变量在进行写操作时，会在前面加上lock指令前缀。

而lock指令前缀会做如下两件事

将当前处理器缓存行的数据写回到内存。lock指令前缀在执行指令的期间，会产生一个lock信号，lock信号会保证在该信号期间会独占任何共享内存。lock信号一般不锁总线，而是锁缓存。因为锁总线的开销会很大。

将缓存行的数据写回到内存的操作会使得其他CPU缓存了该地址的数据无效。 

https://blog.csdn.net/mashaokang1314/article/details/96571818

加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，它有三个功能：

确保指令重排序时不会把其后面的指令重排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面，即在执行到内存屏障这句指令时，前面的操作已经全部完成；

将当前处理器缓存行的数据立即写回系统内存（由volatile先行发生原则保证）；

这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。写回操作时要经过总线传播数据，而每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个值进行修改的时候，会强制重新从系统内存里把数据读到处理器缓存(也是由volatile先行发生原则保证)；

缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于”嗅探（snooping）”协议，它的基本思想是：
所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个CPU缓存可以读写内存）。
CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。

volatile 的特点，保证原子性么
同上

ThreadLocal
static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的
https://blog.csdn.net/u012411414/article/details/50532875/

问题的来源是：

   在我写一个OpenSessionFilterInView的时候（当然Spring已经有了这个功能），需要在view中这里也就是在Filter中从spring工厂的hibernate sessionFactory中获取一个session,并且需要把session传到DAO当中，那么问题来了，如果ThreadLocal是静态的，那么多线程并发的时候 主存中只有一个ThreadLocal，每个线程都set一次，那不同线程get的时候不是乱套了？

其实并不是这样，虽然在某个类中，这里是Filter类，ThreadLocal是静态的，只有一个，但是它所持有的变量，这里是session 在不同线程中是不一样的，不存在session乱套的问题。这也是ThreadLocal的特别之处，退一步说，若ThreadLocal是一个普通的类，它若是static,那么它持有的变量，在多线程时候，肯定会产生冲突。

ThreadLocal: 它的作用只是在当前线程中，共享一个值，可以是session connection等等，这个值在每个线程都是不一样的，也不存在什么线程安全的问题，也不需要线程安全。

题目：怎么用ThreadLocal解决问题、原理实现，内存泄漏
private HashMap<Integer,Integer> map = new HashMap<>();
线程一：map.put(1,2);  线程二: map.put(1,3);
两个线程去执行一段代码
if(map.get(1) == 2) 输出...
if(map.get(1) == 3) 输出..
问线程一和线程二执行完上述完会出现什么问题？
我回答说可能出现覆盖，跟执行顺序有关系，怎么解决，我说map用锁修饰？可以，有没有其他的，再想一想，想一想？？
然后想了好久，没想出来，他说ThreadLocal你没听过么？我豁然开朗，于是开始拼命解释原理实现、可能导致的内存泄露问题，挽救路线完成。
https://www.cnblogs.com/ablejava/p/5914090.html（《ThreadLocal解决线程安全问题》）

使用ThreadLocal解决线程安全:

public class ThreadLocalDateUtil {
    private static final String date_format = "yyyy-MM-dd HH:mm:ss";
    private static ThreadLocal<DateFormat> threadLocal = new ThreadLocal<DateFormat>();
  
    public static DateFormat getDateFormat()  
    { 
        DateFormat df = threadLocal.get(); 
        if(df==null){ 
            df = new SimpleDateFormat(date_format); 
            threadLocal.set(df); 
        } 
        return df; 
    } 
    public static String formatDate(Date date) throws ParseException {
        return getDateFormat().format(date);
    }
    public static Date parse(String strDate) throws ParseException {
        return getDateFormat().parse(strDate);
    }  
}
https://www.jianshu.com/p/dde92ec37bd1（《一篇文章，从源码深入详解ThreadLocal内存泄漏问题》）

造成内存泄露的原因
threadLocal是为了解决对象不能被多线程共享访问的问题，通过threadLocal.set方法将对象实例保存在每个线程自己所拥有的threadLocalMap中，这样每个线程使用自己的对象实例，彼此不会影响达到隔离的作用，从而就解决了对象在被共享访问带来线程安全问题。

如果将同步机制和threadLocal做一个横向比较的话，同步机制就是通过控制线程访问共享对象的顺序，而threadLocal就是为每一个线程分配一个该对象，各用各的互不影响。

同步机制以“时间换空间”，由于每个线程在同一时刻共享对象只能被一个线程访问造成整体上响应时间增加，但是对象只占有一份内存，牺牲了时间效率换来了空间效率即“时间换空间”。而threadLocal，为每个线程都分配了一份对象，自然而然内存使用率增加，每个线程各用各的，整体上时间效率要增加很多，牺牲了空间效率换来时间效率即“空间换时间”。

上图中，实线代表强引用，虚线代表的是弱引用，如果threadLocal外部强引用被置为null(threadLocalInstance=null)的话，threadLocal实例就没有一条引用链路可达，很显然在gc(垃圾回收)的时候势必会被回收，因此entry就存在key为null的情况，无法通过一个Key为null去访问到该entry的value。同时，就存在了这样一条引用链：threadRef->currentThread->threadLocalMap->entry->valueRef->valueMemory,导致在垃圾回收的时候进行可达性分析的时候,value可达从而不会被回收掉，但是该value永远不能被访问到，这样就存在了内存泄漏。当然，如果线程执行结束后，threadLocal，threadRef会断掉，因此threadLocal,threadLocalMap，entry都会被回收掉。可是，在实际使用中我们都是会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们关注。

已经做出了哪些改进
实际上，为了解决threadLocal潜在的内存泄漏的问题，Josh Bloch and Doug Lea大师已经做了一些改进。在threadLocal的set和get方法中都有相应的处理。下文为了叙述，针对key为null的entry，源码注释为stale entry，直译为不新鲜的entry，这里我就称之为“脏entry”。比如在ThreadLocalMap的set方法中：

在该方法中针对脏entry做了这样的处理：

如果当前table[i]！=null的话说明hash冲突就需要向后环形查找，若在查找过程中遇到脏entry就通过replaceStaleEntry进行处理；

如果当前table[i]==null的话说明新的entry可以直接插入，但是插入后会调用cleanSomeSlots方法检测并清除脏entry

为什么使用弱引用？
从文章开头通过threadLocal,threadLocalMap,entry的引用关系看起来threadLocal存在内存泄漏的问题似乎是因为threadLocal是被弱引用修饰的。那为什么要使用弱引用呢？

如果使用强引用

假设threadLocal使用的是强引用，在业务代码中执行threadLocalInstance==null操作，以清理掉threadLocal实例的目的，但是因为threadLocalMap的Entry强引用threadLocal，因此在gc的时候进行可达性分析，threadLocal依然可达，对threadLocal并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误

如果使用弱引用

假设Entry弱引用threadLocal，尽管会出现内存泄漏的问题，但是在threadLocal的生命周期里（set,getEntry,remove）里，都会针对key为null的脏entry进行处理。

从以上的分析可以看出，使用弱引用的话在threadLocal生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。

ThreadLocal最佳实践
通过这篇文章对threadLocal的内存泄漏做了很详细的分析，我们可以完全理解threadLocal内存泄漏的前因后果，那么实践中我们应该怎么做？

每次使用完ThreadLocal，都调用它的remove()方法，清除数据。

在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。

楼主嘴贱，扯了一下ThreadLocal，疯狂问这个，底层实现我还可以讲一下，问一下使用背景，怎么使用？有点懵，忘了
https://www.jianshu.com/p/30ee77732843（《并发容器之ThreadLocal》）

ThreadLocal的实现原理
set方法
set方法设置在当前线程中threadLocal变量的值

public void set(T value) {
    //1. 获取当前线程实例对象
    Thread t = Thread.currentThread();
    //2. 通过当前线程实例获取到ThreadLocalMap对象
    ThreadLocalMap map = getMap(t);
    if (map != null)
        //3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入
        map.set(this, value);
    else
        //4.map为null,则新建ThreadLocalMap并存入value
        createMap(t, value);
}
方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道value是存放在了ThreadLocalMap里了，当前先把它理解为一个普普通通的map即可，也就是说，数据value是真正的存放在了ThreadLocalMap这个容器中了，并且是以当前threadLocal实例为key。先简单的看下ThreadLocalMap是什么，有个简单的认识就好，下面会具体说的。

首先ThreadLocalMap是怎样来的？源码很清楚，是通过getMap(t)进行获取：

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
该方法直接返回的就是当前线程对象t的一个成员变量threadLocals：

/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
也就是说ThreadLocalMap的引用是作为Thread的一个成员变量，被Thread进行维护的。回过头再来看看set方法，当map为Null的时候会通过createMap(t，value)方法：

void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
该方法就是new一个ThreadLocalMap实例对象，然后同样以当前threadLocal实例作为key,值为value存放到threadLocalMap中，然后将当前线程对象的threadLocals赋值为threadLocalMap。

现在来对set方法进行总结一下：
通过当前线程对象thread获取该thread所维护的threadLocalMap,若threadLocalMap不为null,则以threadLocal实例为key,值为value的键值对存入threadLocalMap,若threadLocalMap为null的话，就新建threadLocalMap然后在以threadLocal为键，值为value的键值对存入即可。

get方法
get方法是获取当前线程中threadLocal变量的值

public T get() {
    //1. 获取当前线程的实例对象
    Thread t = Thread.currentThread();
    //2. 获取当前线程的threadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        //3. 获取map中当前threadLocal实例为key的值的entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            //4. 当前entitiy不为null的话，就返回相应的值value
            T result = (T)e.value;
            return result;
        }
    }
    //5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value
    return setInitialValue();
}
弄懂了set方法的逻辑，看get方法只需要带着逆向思维去看就好，如果是那样存的，反过来去拿就好。代码逻辑请看注释，另外，看下setInitialValue主要做了些什么事情？

private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
这段方法的逻辑和set方法几乎一致，另外值得关注的是initialValue方法:

protected T initialValue() {
    return null;
}
这个方法是protected修饰的也就是说继承ThreadLocal的子类可重写该方法，实现赋值为其他的初始值。关于get方法来总结一下：

通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回null。

remove方法
public void remove() {
    //1. 获取当前线程的threadLocalMap
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        //2. 从map中删除以当前threadLocal实例为key的键值对
        m.remove(this);
}
get,set方法实现了存数据和读数据，我们当然还得学会如何删数据。删除数据当然是从map中删除数据，先获取与当前线程相关联的threadLocalMap然后从map中删除该threadLocal实例为key的键值对即可。

ThreadLocalMap详解
从上面的分析我们已经知道，数据其实都放在了threadLocalMap中，threadLocal的get，set和remove方法实际上具体是通过threadLocalMap的getEntry,set和remove方法实现的。如果想真正全方位的弄懂threadLocal，势必得在对threadLocalMap做一番理解。

Entry数据结构
ThreadLocalMap是threadLocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadLocalMap内部维护了一个Entry类型的table数组。

/**
 * The table, resized as necessary.
 * table.length MUST always be a power of two.
 */
private Entry[] table;
通过注释可以看出，table数组的长度为2的幂次方。接下来看下Entry是什么：

static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
Entry是一个以ThreadLocal为key,Object为value的键值对，另外需要注意的是这里的threadLocal是弱引用，因为Entry继承了WeakReference，在Entry的构造方法中，调用了super(k)方法就会将threadLocal实例包装成一个WeakReferenece。

set方法
ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。

从源码中我们可以清楚的看到threadLocal实例的hashCode是通过nextHashCode()方法实现的，该方法实际上总是用一个AtomicInteger加上0x61c88647来实现的。0x61c88647这个数是有特殊意义的，它能够保证hash表的每个散列桶能够均匀的分布，这是Fibonacci Hashing，关于更多介绍可以看这篇文章的threadLocal散列值部分。也正是能够均匀分布，所以threadLocal选择使用开放地址法来解决hash冲突的问题。

getEntry方法
这个方法同样很好理解，通过nextIndex往后环形查找，如果找到和查询的key相同的entry的话就直接返回，如果在查找过程中遇到脏entry的话使用expungeStaleEntry方法进行处理。到目前为止，为了解决潜在的内存泄漏的问题，在set，resize,getEntry这些地方都会对这些脏entry进行处理，可见为了尽可能解决这个问题几乎无时无刻都在做出努力。

remove方法
该方法逻辑很简单，通过往后环形查找到与指定key相同的entry后，先通过clear方法将key置为null后，使其转换为一个脏entry，然后调用expungeStaleEntry方法将其value置为null，以便垃圾回收时能够清理，同时将table[i]置为null。

ThreadLocal的使用场景
ThreadLocal 不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap,也就是说每个不同的线程都拥有专属于自己的数据容器（threadLocalMap），彼此不影响。因此threadLocal只适用于 共享对象会造成线程安全 的业务场景。比如hibernate中通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的session,若将session共享出去被多线程访问，必然会带来线程安全问题。

多线程方面，ThreadLocal，线程池
同上

ThreadLocal相关
同上

synchronized
像synchronized这种，得知道膨胀过程，锁膨胀实现过程，比如对象头如何变化，monitor是怎么回事等
https://blog.csdn.net/xueba8/article/details/88753443（《深入分析synchronized原理和锁膨胀过程(二)》）

synchronized原理
同步代码块：
我们在代码块加上synchronized关键字，编译之后，我们利用反编译命令javap -v xxx.class查看对应的字节码

可以发现synchronized同步代码块是通过加monitorenter和monitorexit指令实现的。

每个对象都有个监视器锁(monitor) ，当monitor被占用的时候就代表对象处于锁定状态，而monitorenter指令的作用就是获取monitor的所有权，monitorexit的作用是释放monitor的所有权，这两者的工作流程如下：

monitorenter：

如果monitor的进入数为0，则线程进入到monitor，然后将进入数设置为1，该线程称为monitor的所有者。

如果是线程已经拥有此monitor(即monitor进入数不为0)，然后该线程又重新进入monitor，则将monitor的进入数+1，这个即为锁的重入。

如果其他线程已经占用了monitor，则该线程进入到阻塞状态，知道monitor的进入数为0，该线程再去重新尝试获取monitor的所有权。

monitorexit：执行该指令的线程必须是monitor的所有者，指令执行时，monitor进入数-1，如果-1后进入数为0，那么线程退出monitor，不再是这个monitor的所有者。这个时候其它阻塞的线程可以尝试获取monitor的所有权。

同步方法
在方法上加上synchronized关键字，编译之后，我们利用反编译命令javap -v xxx.class查看对应的字节码

从字节码上看，加有synchronized关键字的方法，常量池中比普通的方法多了个ACC_SYNCHRONIZED标识，JVM就是根据这个标识来实现方法的同步。

当调用方法的时候，调用指令会检查方法是否有ACC_SYNCHRONIZED标识，有的话线程需要先获取monitor，获取成功才能继续执行方法，方法执行完毕之后，线程再释放monitor，同一个monitor同一时刻只能被一个线程拥有。

两种同步方式的区别
synchronized同步代码块的时候通过加入字节码monitorenter和monitorexit指令来实现monitor的获取和释放，也就是需要JVM通过字节码显式的去获取和释放monitor实现同步，而synchronized同步方法的时候，没有使用这两个指令，而是检查方法的ACC_SYNCHRONIZED标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。

这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的mutex互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。
线程获取、释放monitor的过程如下：

线程尝试获取monitor的所有权，如果获取失败说明monitor被其他线程占用，则将线程加入到的同步队列中，等待其他线程释放monitor，当其他线程释放monitor后，有可能刚好有线程来获取monitor的所有权，那么系统会将monitor的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以synchronized是非公平锁。如果线程获取monitor成功则进入到monitor中，并且将其进入数+1。

到这里我们也清楚了synchronized的语义底层是通过一个monitor的对象完成，其实wait、notiyf和notifyAll等方法也是依赖于monitor对象来完成的，这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出java.lang.IllegalMonitorStateException的异常

Java对象的组成
我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？

为了解开这个疑问，我们需要进入Java虚拟机(JVM) 的世界。在HotSpot虚拟机中，Java对象在内存中储存的布局可以分为3块区域：对象头、实例数据、对齐填充。synchronized使用的锁对象储存在对象头中

对象头
对象头的数据长度在32位和64位(未开启压缩指针)的虚拟机中分别为32bit和64bit。对象头由以下三个部分组成：

Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁标志位、线程持有的锁、偏向线程ID、偏向时间戳、对象分代年龄等。注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间。

类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

数组长度：这个属性只有数组对象才有，储存着数组对象的长度。

在32位虚拟机下，Mark Word的结构和数据可能为以下5种中的一种。

在64位虚拟机下，Mark Word的结构和数据可能为以下2种中的一种。

这里重点注意是否偏向锁和锁标志位，这两个标识和synchronized的锁膨胀息息相关。

实例数据
储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。

对齐填充
HotSpot虚拟机的对齐方式为8字节对齐，即一个对象必须为8字节的整数倍，如果不是，则通过这个对齐填充来占位填充。

synchronized锁膨胀过程
上文介绍的 “synchronized实现原理” 实际是synchronized实现重量级锁的原理，那么上文频繁提到monitor对象和对象又存在什么关系呢，或者说monitor对象储存在对象的哪个地方呢？在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向monitor对象

那锁的状态为其它状态的时候是不是就没用上monitor对象？答案:是的。

这也是JVM对synchronized的优化，我们知道重量级锁的实现是基于底层操作系统的mutex互斥原语的，这个开销是很大的。所以JVM对synchronized做了优化，JVM先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用monitor对象。当然JVM对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。

那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。

锁优化
自旋锁和自适应自旋锁
自旋：当有个线程A去请求某个锁的时候，这个锁正在被其它线程占用，但是线程A并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程A可以尝试一直请求锁，没必要被挂起放弃CPU时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程A自旋指定的时间还没有获得锁，仍然会被挂起。

自适应性自旋：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如线程如果自旋成功了，那么下次自旋的次数会增多，因为JVM认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果对于某个锁，自旋很少成功，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，JVM对程序锁的状况预测就会变得越来越准确，JVM也就变得越来越聪明。

锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

锁粗化
在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。

轻量级锁
所谓轻量级锁是相对于使用底层操作系统mutex互斥原语实现同步的重量级锁而言的，因为轻量级锁同步的实现是基于对象头的Mark Word。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。

获取锁过程：

在线程进入同步方法、同步块的时候，如果同步对象锁状态为无锁状态(锁标志位为"01"状态，是否为偏向锁为"0")，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Recored)的空间，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。

将对象头的Mark Word拷贝到线程的锁记录(Lock Recored)中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新成功了，则执行步骤4，否则执行步骤5。

更新成功，这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为"00"，即表示此对象处于轻量级锁的状态。。

更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。进行自旋执行步骤3，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为"10"，Mark Word中储存就是指向monitor对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。

释放锁的过程：

使用CAS操作将对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来(依据Mark Word中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤2，否则执行步骤3。

如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。

如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。

偏向锁
偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不用做了。偏向锁默认是开启的，也可以关闭。

偏向锁"偏"，就是"偏心"的"偏"，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

获取锁的过程：

检查Mark Word是否为可偏向锁的状态，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。

如果是可偏向锁，则检查Mark Word储存的线程ID是否为当前线程ID，如果是则执行同步块，否则执行步骤3。

如果检查到Mark Word的ID不是本线程的ID，则通过CAS操作去修改线程ID修改成本线程的ID，如果修改成功则执行同步代码块，否则执行步骤4。

当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。

锁释放的过程：

有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。

等待全局安全点(在这个是时间点上没有字节码正在执行)。

暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于无锁状态，则恢复到无锁状态(01)，以允许其他线程竞争，如果锁对象处于锁定状态，则挂起持有偏向锁的线程，并将对象头Mark Word的锁记录指针改成当前线程的锁记录，锁升级为轻量级锁状态(00)。

锁的转换过程
锁主要存在4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层mutex互斥原语来实现，其他的锁都是使用对象头来实现的。需要注意锁可以升级，但是不可以降级。

Synchronized是重入的吗？和lock区别，以及synchronized对于普通方法和静态方法加锁。
synchronized可重入性
https://blog.csdn.net/u010002184/article/details/72938691（《synchronized的可重入性》）

从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功。

在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下：

正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现

需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。

synchronized和lock区别
https://www.cnblogs.com/iyyy/p/7993788.html（《synchronized与Lock的区别》）

两者区别：

首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

synchronized对普通方法和静态方法加锁
https://www.cnblogs.com/houzheng/p/8763478.html（《关于java线程锁synchronized修饰普通方法与静态方法的区别》）

如果synchronized修饰在普通方法上,线程之间互无关系,可任意执行自己对象的锁
如果在static方法上修饰，synchronized表示锁定了class类.多个线程都是相同的一把锁,即取得的锁都是对象锁,哪个线程先执行代码,哪个线程就持有该方法所属的对象锁,其他对象就无法执行

synchronized和Reentranlock区别以及底层实现原理
synchronized和ReentrantLock的区别
https://blog.csdn.net/zheng548/article/details/54426947（《synchronized和锁(ReentrantLock) 区别》）

区别一：API层面
synchronized使用
synchronized既可以修饰方法，也可以修饰代码块。

ReentrantLock使用

public class test（）{
    private Lock lock = new ReentrantLock();

    public void testMethod()
    {
        try
        {
            lock.lock();
            ```
            //省略

        }
        finally
        {
            lock.unlock();
        }
    }
}
区别二：等待可中断
引用周志明的《深入理解Java虚拟机》Page 392

等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可等待特性对处理执行时间非常长的同步快很有帮助。

具体来说，假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。

使用synchronized。如果Thread1不释放，Thread2将一直等待，不能被中断。synchronized也可以说是Java提供的原子性内置锁机制。内部锁扮演了互斥锁（mutual exclusion lock ，mutex）的角色，一个线程引用锁的时候，别的线程阻塞等待。

使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

区别三：公平锁
引用周志明的《深入理解Java虚拟机》Page 392

公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。
synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。

区别四：锁绑定多个条件
ReentrantLock可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。
synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。

区别五：性能
JDK 1.5中，synchronized还有很大的优化余地。JDK 1.6 中加入了很多针对锁的优化措施，synchronized与ReentrantLock性能方面基本持平。虚拟机在未来的改进中更偏向于原生的synchronized。

补充：关于synchronized关键字
Java中每个对象都有一个锁（lock）或者叫做监视器（monitor）。

ReentrantLock和synchronized持有的对象监视器不同。

如果某个synchronized方法是static的，那么当线程方法改方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在对象所对应的Class对象，因为Java中不管一个类有多少对象，这些对象会对应唯一一个Class对象。因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，是顺序执行的，亦即一个线程先执行，完毕之后，另一个才开始执行。

synchronized 方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行synchronized方法；synchronized块则是一种细粒度的并发控制。只会将块中代码同步，位于方法内，synchronized块之外的代码是可以被多个线程同时访问的。

synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，操作对象均为锁的计数器。

相同点：都是可重入的。可重入值的是同一个线程多次试图获取它所占的锁，请求会成功。当释放的时候，直到冲入次数清零，锁才释放。

ReentrantLock的底层实现原理
https://blog.csdn.net/qq_36520235/article/details/81669831（《（五）可重入锁ReentrantLock的底层原理实现？》）


synchronized底层的实现原理（自旋锁、偏向锁、轻量级锁、重量级锁），什么是重量级锁，定义是什么
https://blog.csdn.net/qq_35583772/article/details/94544010（《轻量级锁、重量级锁都是啥玩意》）

在JDK1.6以后，为了减少消耗，锁进行了很多的升级。并且有了四种状态，从低到高

无锁状态

偏向锁状态

轻量级锁状态

重量级锁状态

下面就介绍一下这四种不同等级的锁

不同等级间的锁可以进行升级，但是不能进行降级

对象内存布局
在讲锁之前我们应该了解对象的内存布局，因为后面锁的判定时需要用到，

该内容可以看我的这篇文章，对象的内存布局，重点看对象头中的运行时数据(Mark Word)

看了这个你应该知道，Mark Word(以后简称MW) 会随着 标志位的变化而变化


无锁状态


偏向锁
先看MW变化(在对象头变化的那一张图片中)

可以看到，他的锁标志位和无锁的标志位是一样的 都是 01，但是是否是偏向锁的标志位就变了 变成了 1.并且整个MW部分变成了5部分

目的
经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引人了偏向锁

偏向锁，就如同他的名字一样，“偏向”，“偏心”，英文"biased"也是偏爱的意思。

他为啥是叫这个呢，因为这个锁偏向于第一个获取到他的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步

步骤

上面一共被分为三大部分，

无锁状态

偏向锁状态

撤销偏向锁

上面的图中，线程一演示了偏向锁的初始化流程，线程2演示了偏向锁撤销的过程

初始化过程
当锁对象第一次被线程获取的时候，虚拟机会将对象头中的锁标志位置为 “01”(偏向模式)

同时，使用CAS(如果不了解CAS，可以看这篇文章，悲观锁和乐观锁)操作，把获取到这个锁的线程的ID记录在对象的MW中，

如果 CAS成功，持有偏向锁的线程每次进入这个锁相关的同步块时，虚拟机可以不进行任何同步操作

撤销过程
首先暂停拥有偏向锁的线程

然后检查持有偏向锁的线程是否活着

不活跃，将对象头设置成无锁状态 (标志位"01"，但不可偏向)

活，

CAS成功，重新偏向，更改线程ID

失败，恢复成无锁状态，或者变成轻量级锁定状态。

轻量级锁
标志位为"00"，可以看最开始的图

为啥叫轻量级锁，因为这是相比于传统的重量级锁而言，原来传统的重量级锁，使用的是系统互斥量实现的

他的出现并不是代替重量级锁，而是在没有多线程竞争的前提下，减少系统互斥量操作产生的性能消耗

步骤

加锁
线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录（下图的LockRecord）的空间，并将对象头中的MW复制到锁记录中，官方称为 Displaced Mark Word

然后，虚拟机将使用CAS操作，将对象的MW更新为指向锁记录的指针

如果这个操作成功，那么该线程就有了该对象的锁，并且对象的MW的锁标志位置为 “00”，表示该对象处于轻量级锁定状态

如果更新失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁

解锁
使用CAS操作将 Displaced Mark Word 替换回到对象头

如果成功，则说明没有发生竞争

失败，则表示当前锁存在竞争，锁就会膨胀成重量级锁

释放锁，并且唤醒等待的线程

缺点
轻量级能提升程序同步性能的依据是"对于绝大部分的锁，在整个同步周期内都是不存在竞争的"，这是一个经验数据。

如果没有竞争，轻量级锁使用CAS操作，避免使用互斥量

如果存在竞争，除了互斥量的开销，还有 CAS的操作，不仅没有提升，反而性能会下降

各个锁之间的转换
![img](E:\个人文件\博客\Java面试题目库题解.assets\aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzMvMTZiYjUzZmIyOWViMDE0ZQ.jpg)

对比
锁	优点	缺点	使用场景
偏向锁	加锁和解锁都不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的锁撤销的消耗	只有一个线程访问同步块
轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，使用自旋会消耗CPU	追求响应时间，同步块执行速度非常快
重量级锁	线程竞争不使用自旋，不会消耗CPU	线程阻塞，响应时间慢	追求吞吐量同步块执行时间较长
synchronized关键字作用与静态方法和普通方法的区别，通过不同的对象的监视器来进行并发控制，monitorenter， monitorexit
其他同上

https://blog.csdn.net/qq_29842929/article/details/80999836（《Java并发-对象监视器》）

对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。
无论采用哪种方式，其本质是对一个对象的监视器进行获取，而对这个获取过程是排他的，也就是说统一时刻是能有一个线程获得到由synchronized所保护对象的监视器。

![img](E:\个人文件\博客\Java面试题目库题解.assets\20180711141345952.png)

任意线程对Object的访问，首先要先获得Object的监视器。如果获取失败了，线程进入同步队列，线程状态变为BLOCKED。当访问Object的线程（获得了所的线程）释放了锁，则该释放操作唤醒在同步队列中的线程，使其重新尝试对监视器的获取。

lock sychronized区别
同上

sychronized锁住方法和锁住代码块的区别，什么时候会出现死锁
前者同上

https://blog.csdn.net/ysyswywl2/article/details/50801536（《synchronized产生的死锁》）

死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。

构建死锁的代码
例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。

该情况如下

package com.smart.concurrency.chapter1;
/**
 * @Description  死锁的例子
 * @author gaowenming
 */
public class DeadLock {
    /** A锁 */
    private static String A = "A";
    /** B锁 */
    private static String B = "B";
    public static void main(String[] args) {
        new DeadLock().deadLock();
    }
    public void deadLock() {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (A) {
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (B) {
                        System.out.println("thread1...");
                    }
                }
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (B) {
                    synchronized (A) {
                        System.out.println("thread2...");
                    }
                }
            }
        });
        t1.start();
        t2.start();
    }
}
上面的2个线程的执行过程如下：

线程1开始执行，拿到了锁A，休眠2秒，线程2执行，先拿到了锁B，在请求拿锁A，而由于此时线程1已经占用了锁A，所以就等待线程1释放锁A，休眠结束后，线程1继续往下执行，请求拿到锁B，而锁B被线程2占用，从而形成了死锁

解决死锁
java中，解决死锁一般有如下方法：

尽量使用tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 

尽量使用java.util.concurrent(jdk 1.5以上)包的并发类代替手写控制并发，比较常用的是ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等等，实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高 

尽量降低锁的使用粒度，尽量不要几个功能用同一把锁 

尽量减少同步的代码块

https://blog.csdn.net/a158123/article/details/78616562（《使用synchronized实现死锁》）

死锁定义
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁产生条件
互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

死锁排查与分析
Windows环境下打开cmd，输入jps显示Java的进程PID（Linux环境也是一样，在命令行界面输入jps），显示如下结果（我们只要关心SynchronizedDeadLock类的进程即可）：

3828 Jps
7780
5800 SynchronizedDeadLock
在jps显示的结果中，左边是进程PID，右边是类名，这次的实例类名为SynchronizedDeadLock，所以找到PID为5800（要根据你自己执行时的PID为准）。然后输入jstack 5800（即jstack PID）显示dump信息（我只截取了关于死锁的部分）：

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.rjh.lock.SynchronizedDeadLock$2.run(SynchronizedDeadLock.java:40)

        - waiting to lock <0x00000000d5fae710> (a java.lang.Object)
        - locked <0x00000000d5fae720> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:745)
"Thread-0":    
        at com.rjh.lock.SynchronizedDeadLock$1.run(SynchronizedDeadLock.java:24)

        - waiting to lock <0x00000000d5fae720> (a java.lang.Object)
        - locked <0x00000000d5fae710> (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.
dump分析：在最后一行知道了有一个死锁，而且从截取部分的信息知道，死锁是有Thread-1和Thread-0导致的，Thread-1等待<0x00000000d5fae710>这个对象的锁，并且已经锁定了<0x00000000d5fae720>，而Thread-0等待<0x00000000d5fae720>，并且锁定了<0x00000000d5fae720>这个对象的锁（注意<>内的是对应的对象的内存地址）。由于文字说明可能没怎么直观，还是展示一下简单的分析图（图中的箭头如果是穿过锁，这表示持有锁。否则表示等待持有锁）：

synchronized的锁的机制，自旋锁，可重入锁，偏向锁，轻量级锁、重量级锁，锁的膨胀过程
同上

synchronized 和 lock 的区别
同上

synchronized相关：锁住的是什么，实现原理，1.6优化，和lock的区别
https://blog.csdn.net/qq_28089993/article/details/80650379（《JDK1.6的synchronized底层优化（偏向锁、轻量级锁）》）

Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。

Synchronized原理
Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。

优化
1.适应自旋锁

   自旋锁：为了减少线程状态改变带来的消耗 不停地执行当前线程 

2.锁消除：

  不可能存在共享数据竞争的锁进行消除

3.锁粗化：

  将连续的加锁 精简到只加一次锁

4.轻量级锁：

 无竞争条件下 通过CAS消除同步互斥

5.偏向锁：

无竞争条件下 消除整个同步互斥，连CAS都不操作。

问synchronized锁的原理，synchronized修饰静态方法的时候锁是什么？  详细题目在下面：
（这个问题我真的一脸懵，锁是什么？这个问题这么泛）我前面已经介绍了synchronized锁的原理（monitor监视器），他说不是前面介绍的锁的原理，我还问他说你说的是锁的作用范围吗？会锁住这个类，他说不是，说他问的是底层原理，问的是源码，我说您说的是synchronize锁在对象头里面的Lock Record标志位吗？是说锁的一些优化吗，例如偏向锁，轻量级锁，重量级锁吗？感觉有点不像，他说不是，我说能不能提示一下，感觉这个问题太宽泛了，然后重点就来了，他说了这个懂行的人就懂，我。。。我说那您能提示一些概念我下去自己查一下（你倒是提示一点让我下去学习一波也是好的呀），他就是不说，然后就说好，下一个问题。

https://blog.csdn.net/qq_42564846/article/details/83991909（《Jdk1.6及以上版本对synchronized的优化》）

实现同步的基础
Java中的每个对象都可以作为锁. 具体变现为以下3中形式.

对于普通同步方法, 锁是当前实例对象.

==对于静态同步方法, 锁是当前类的Class对象.==

对于同步方法块, 锁是synchronized括号里配置的对象.

一个线程试图访问同步代码块时, 必须获取锁. 在退出或者抛出异常时, 必须释放锁.

实现方式
JVM基于进入和退出Monitor对象来实现方法同步和代码块同步, 但是两者的实现细节不一样.

代码块同步: 通过使用monitorenter和monitorexit指令实现的.

同步方法: ACC_SYNCHRONIZED修饰

monitorenter指令是在编译后插入到同步代码块的开始位置, 而monitorexit指令是在编译后插入到同步代码块的结束处或异常处.

代码题
三个线程如何实现交替打印ABC
https://blog.csdn.net/hefenglian/article/details/82596072（《三个线程交替顺序打印ABC》）

1、使用synchronized, wait和notifyAll
package com.beike.offer;
public class Synchronized_ABC {
    public static class ThreadPrinter implements Runnable {
        private String name;
        private Object prev;
        private Object self;

        private ThreadPrinter(String name, Object prev, Object self) {
            this.name = name;
            this.prev = prev;
            this.self = self;
        }

        @Override
        public void run() {
            int count = 10;
            while (count > 0) {// 多线程并发，不能用if，必须使用whil循环
                synchronized (prev) { // 先获取 prev 锁
                    synchronized (self) {// 再获取 self 锁
                        System.out.print(name);// 打印
                        count--;

                        self.notifyAll();// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。
                    }
                    // 此时执行完self的同步块，这时self锁才释放。
                    try {
                        if (count == 0) {// 如果count==0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。
                            prev.notifyAll();
                        } else {
                            prev.wait(); // 立即释放 prev锁，当前线程休眠，等待唤醒
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Object a = new Object();
        Object b = new Object();
        Object c = new Object();
        ThreadPrinter pa = new ThreadPrinter("A", c, a);
        ThreadPrinter pb = new ThreadPrinter("B", a, b);
        ThreadPrinter pc = new ThreadPrinter("C", b, c);

        new Thread(pa).start();
        Thread.sleep(10);// 保证初始ABC的启动顺序
        new Thread(pb).start();
        Thread.sleep(10);
        new Thread(pc).start();
        Thread.sleep(10);
    }
}
2、使用Lock和state标志
public class Lock_State_ABC {
    private static Lock lock=new ReentrantLock();
    private static int state=0;//通过state的值来确定是哪个线程打印

   static class ThreadA extends Thread{
        @Override
        public void run(){
            for (int i = 0; i <10 ; ) {
                try{
                    lock.lock();
                    while(state%3==0){// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒
                        System.out.print("A");
                        state++;
                        i++;
                    }
                }finally{
                    lock.unlock();
                }
            }
        }
    }

    static class ThreadB extends Thread{
        @Override
        public void run(){
            for (int i = 0; i <10 ; ) {
                try{
                    lock.lock();
                    while(state%3==1){
                        System.out.print("B");
                        state++;
                        i++;
                    }
                }finally{
                    lock.unlock();
                }
            }
        }
    }


    static class ThreadC extends Thread{
        @Override
        public void run(){
            for (int i = 0; i <10 ; ) {
                try{
                    lock.lock();
                    while(state%3==2){
                        System.out.print("C");
                        state++;
                        i++;
                    }
                }finally{
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
3、使用Lock->ReentrantLock 和Condition（await 、signal、signalAll）
public class Lock_Condition_ABC {
    private static Lock lock = new ReentrantLock();
    private static Condition A = lock.newCondition();
    private static Condition B = lock.newCondition();
    private static Condition C = lock.newCondition();

    private static int count = 0;

    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();

                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 0){//注意这里是不等于0，也就是说没轮到该线程执行，之前一直等待状态
                        A.await(); //该线程A将会释放lock锁，构造成节点加入等待队列并进入等待状态
                    }
                    System.out.print("A");
                    count++;
                    B.signal(); // A执行完唤醒B线程
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 1)
                        B.await();// B释放lock锁，当前面A线程执行后会通过B.signal()唤醒该线程
                    System.out.print("B");
                    count++;
                    C.signal();// B执行完唤醒C线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 2)
                        C.await();// C释放lock锁
                    System.out.print("C");
                    count++;
                    A.signal();// C执行完唤醒A线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
4、使用Semaphore
public class Semaphore_ABC {
    // 以A开始的信号量,初始信号量数量为1
    private static Semaphore A = new Semaphore(1);
    // B、C信号量,A完成后开始,初始信号数量为0
    private static Semaphore B = new Semaphore(0);
    private static Semaphore C = new Semaphore(0);

    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    A.acquire();// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量
                    System.out.print("A");
                    B.release();// B释放信号，B信号量加1（初始为0），此时可以获取B信号量
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    B.acquire();
                    System.out.print("B");
                    C.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    C.acquire();
                    System.out.println("C");
                    A.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }

}
5、使用AtomicInteger
public class Atomtic_ABC {

    private AtomicInteger ai = new AtomicInteger(0);
    private static final int MAX_SYC_VALUE = 3 * 10;

    private class RunnableA implements Runnable {
        public void run() {
            while (ai.get() < MAX_SYC_VALUE-1) {
                if (ai.get() % 3 == 0) {
                    System.out.print("A");
                    ai.getAndIncrement();
                }
            }

        }
    }

    private class RunnableB implements Runnable {
        public void run() {
            while (ai.get() < MAX_SYC_VALUE) {
                if (ai.get() % 3 == 1) {
                    System.out.print("B");
                    ai.getAndIncrement();
                }
            }

        }
    }

    private class RunnableC implements Runnable {
        public void run() {
            while (ai.get() < MAX_SYC_VALUE) {
                if (ai.get() % 3 == 2) {
                    System.out.println("C");
                    ai.getAndIncrement();
                }
            }

        }
    }


    public static void main(String[] args) {
        Atomtic_ABC atomic_ABC = new Atomtic_ABC();
        ExecutorService service = Executors.newFixedThreadPool(3);

        service.execute(atomic_ABC.new RunnableA());
        service.execute(atomic_ABC.new RunnableB());
        service.execute(atomic_ABC.new RunnableC());

        service.shutdown();
    }
}
如何线程安全的实现一个计数器
https://www.jianshu.com/p/785494999905（《实现一个线程安全的计数器》）

package pandy.thread;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @Author: Pandy
 * @Date: 2019/3/18 19:16
 * @Version 1.0
 */
public class MySafeThread implements Runnable {
    //设置计数器初始值为0
    private static AtomicInteger count = new AtomicInteger(0);

    @Override
    public void run(){
        while (true){
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            MySafeThread.calc();
        }
    }
    //计数 注意加锁sychronized
    private synchronized static void calc(){
        //count 为计数后的值
        if (count.get()<1000){
            //自增1 返回更新后的值
            int c = count.incrementAndGet();
            //现场名称与自增后的值
            System.out.println(Thread.currentThread().getName()+":"+c);
        }
    }
    //开启五个线程进行计数
    public static void main(String[] args) {
        for (int i=0;i<5;i++){
            MySafeThread mySafeThread = new MySafeThread();
            Thread t = new Thread(mySafeThread);
            t.start();
        }
    }
}
生产者消费者模式，要求手写过代码，还是要知道的

写单例模式，加锁，比较两种区别

实现一个blockqueue

实现36进制加法，中间不准转成10进制。

输入一组数字，长度为N，按照数字由小到大，输出前K个数字。

算法：链表反转

算法：正方形矩阵内实现最小路径。

在一个字符串中找到重复次数最多的子串，这个子串长度大于2。

一个数去掉k位使其最大/最小(贪心)

手写树的中序遍历的递归和非递归方法

手写一个算法对一个数组的数组排序其中里面一层的数组里的元素是排好序的	一开始写了个归并，后面面试官说时间复杂度太高，不如直接n个指针指向每一个里层数组直接排序

一道算法题，一个数组找连续子数组和为0的数组，并返回其中最大的长度 	这道题一开始用了贪心，但说最坏情况下复杂度太高，后来经过面试官提醒实现了一个O(n)时间复杂度

并发题目，数字 0-9，线程 A 先打印，打印到 5 之后，线程 B 接着打印。我说了用等待通知机制的思路（synchronized、ReentrantLock ），面试官说不能在外部加代码，只能在 run 里面写代码，我说用 AtomicInteger，说了下思路，要我写出代码，我口述了下代码，他还是不满意，说还是引入了外部变量，然后我说没有其他思路了，就没再问  

手撕算法，LeetCode原题 23. Merge k Sorted Lists，有一点点不一样就是要求后面没满k个的也转置。

手撕算法，链表快排，用快排的思想实现对链表的数据结构的数据做快排。

代码题1：输出一个单向链表的入环节点，如果没有则输出 null（先通过快慢指针得到 fast 和 slow 相遇的节点，再令 fast 从相遇点出发，slow 从链表首节点出发，一次一步，相遇的节点为入环首节点。面试官要求用数学公式推导为什么要这么做）  

代码题2：合并两棵二叉树，对于两棵树都存在的节点，节点值相加，否则空的位置用另一棵树的节点来代替

线程池
线程池有哪些创建方式和安全性问题

有哪些线程池的类型

线程池中LinkedBlockingQueue满了的话，线程会怎么样

线程池的底层原理和实现方法

线程池原理，拒绝策略，核心线程数

线程池，这个还是很重要的，在生产中用的挺多，四个线程池类型，其参数，参数的理解很重要，corepoolSize怎么设置，maxpoolsize怎么设置，keep-alive各种的，和美团面试官探讨过阻塞队列在生产中的设置，他说他一般设置为0，防止用户阻塞  

线程池的关键参数有哪些？当没有任务的时候，核心数线程还需要保持么？核心线程数是怎么理解的？

线程池然后说到了无界队列，引出了内存溢出

使用线程池的优点是什么

线程池中异常抛出的路径知道吗

线程池原理、类型以及关键参数

项目中用到了线程池，用的什么线程池，怎么配置的参数？

线程池，怎么实现的，要注意什么？

问了java线程池的具体参数，问了最长空闲等待时间的具体情况，释放线程的过程，什么时候什么情况释放，释放时队列的情况是怎么样的。然后给了一个具体的场景分配服务器和设置线程池参数。单次任务的cpu时间是100ms，要达到一秒钟1000次任务量，服务器是4核8g，问要多少服务器，每个服务器具体的线程池参数配置是多少。  

Java 并发编程，说一下理解，线程池的优缺点

几种线程池 参数含义 如何选择

问线程池参数设置和每个参数的意义，问线程池怎么从工作队列中取任务

Java基础，实现多线程的方法，线程池有哪些，怎么扩容。

线程
线程之间的交互方式有哪些？有没有线程交互的封装类 （join）

线程的实现方式——runnable thread future

线程回调，这块 被问过让我设计一个RPC，怎么实现，其实用到了回调这块的东西

线程的几种状态

sleep 和yield方法有什么区别

线程和进程区别，进程为什么开销大？有哪些开销

描述一下有序性

java里实现线程有哪些方式

说说线程的状态

多线程和多进程的使用场景

线程的状态 ， 新建，就绪，running， wait， blocked， terminated

sleep 和 wait 的区别， 类的不同，是否会释放持有的锁，monitor

创建线程的方式，使用过的有那些，为什么没使用过 Callable 和 Future

多线程说一下， 你项目中用到了吗， 你怎么写的线程？几个线程有什么区别？ 线程池用了吗？

Thread的join方法了解吗？
（我说相当于if(isAlive())wait(0)）
那为啥不直接用wait(0)?（不知道）

线程竞争

一个线程的生命周期

阻塞和sleep的区别？？

多线程安全（锁机制、）

线程间通信和进程间通信，管道法用的时候什么管道

多线程，sleep，wait，yield

并发和并行的区别

Java 并发编程，进程和线程的区别，协程，同步机制

Java 多线程同步的方法

wait 和 notify 以及 notifyAll

线程安全的本质是什么？如何解决可见性的问题？可以想出哪几种方法？

进程和线程区别 多进程和多线程区别

创建线程的几种方法

 什么是线程安全 如何实现线程安全

线程同步方式

线程通信方式

问线程安全怎么实现

问创建线程的几种方式，  我答了thread和runnable，还有callable和Future，还有线程池创建，他就说callable和runnable不是一样的吗，你干嘛说两个，我说的一个是有返回值的，一个是没有返回值的，他说我问的是创建线程的方式，你这两个是两种吗?......，还有，你这线程池能创建线程吗？（......）  

高并发
重排序，happens-before，内存屏障

快速失败(fail-fast)和安全失败(fail-safe)的区别是什么

如何排查多线程问题

Java并发工具包
JUC说说你知道的东西

cyclicbarrier 和countdownlatch的区别，个人理解 赛马和点火箭

说一下JUC包

看你对多并发熟悉是吧，来，多个线程同时去访问同一个代码块，我想知道最后一个线程什么时候执行完，怎么做。答CountDownLatch。

AtomicInteger怎么实现的？

i++ automicInteger，线程安全类，三个指令，重排序
https://blog.csdn.net/qq_36071795/article/details/83890531（《如何线程安全地实现一个计数器》）

i++是线程安全的吗？
i++和++i的线程安全分为两种情况：

1、如果i是局部变量（在方法里定义的），那么是线程安全的。因为局部变量是线程私有的，别的线程访问不到，其实也可以说没有线程安不安全之说，因为别的线程对他造不成影响。

2、如果i是全局变量（类的成员变量），那么是线程不安全的。因为如果是全局变量的话，同一进程中的不同线程都有可能访问到。

ConcurrentHashMap

CountDownLatch

问我对多线程和JUC熟悉吗，我说了AQS、ReentrantLock、线程池、CountDownLatch、CyclicBarrier，然后问了我AQS是什么，介绍了AQS的一部分内容，和具体实现。
AQS（AbstractQueuedSynchronizer）
https://blog.csdn.net/qq_36520235/article/details/81263037（《（三）AbstractQueuedSynchronizer（AQS）的底层原理的实现？》）

首先AQS是一个抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架（其实说白了，就是说当有多个线程时，为了更好的控制并发，可以把AQS看成是一个正在管理挂号买东西排队的管理员，由AQS来进行对这个排队的人员（也就是把线程看成节点）进行判断排队的人有没有权利去买东西）

他其实不是说可以单独来实现一个什么功能，但是有好多重要的功能都是得依靠他的底层支持，才能实现其他的ReentrantLock/Semaphore/CountDownLatch…各种锁机制功能

先不考虑代码，直接先理一下AQS的整个流程大概是个什么样的，心里有点逼数，想看源码，百度一堆这样的源码。

整体流程图

![整体流程图](E:\个人文件\博客\Java面试题目库题解.assets\20180728235957195.png)

核心部分图

![核心部分图](E:\个人文件\博客\Java面试题目库题解.assets\20180728170823602.png)

实现原理的大概具体步骤如下：
前提须知：
1、首先你要知道的是AQS的锁的类型是分为两种的：第一种是独占式锁的获取和释放（），第二中的是共享式的锁的释放和获取

2、第一步首先是用acquire(int arg)方法先拿到这个线程的共享资源的状态，这个状态变量是用volatile来修饰的，只有当获取到的state大于等于0时才表示获取锁成功（重入一次锁状态就加1，释放一次锁状态就减一），若果失败就把当前线程包装成一个node节点入队列（FIFO）

3、第二步就是第一步获取状态小于0的时候说明失败，然后调用的 addWaiter(Node mode)方法把该线程包装成一个节点，为了提搞性能，首先执行一次快速入队操作，即直接尝试将新节点加入队尾

4、然后再上一步的基础上，如果尝试把该节点加入队列尾部失败，这里又会去调用 enq(final Node node)方法，（1）先去判断这个队列是不是已经初始化了，如果初始化了就用CAS保证只有一个头结点可以初始化成功，如果没有初始化县初始化再CAS来保证只有一个线程节点创建成功，（2）最后在enq方法中进行无限次的自旋，直到，如果成功会直接使用CAS操作只能返回一个节点(compareAndSetTail(pred, node))

5、操作完了上面的操作之后，就相当于是线程节点已经成功的加入的等待队列中，然后进行的就是挂起当前线程，等待被唤醒。然后调用boolean acquireQueued(final Node node, int arg) ，先把锁的标记为默认为false，然后去判断该节点的前置结点是不是头结点，如果是把当前结点线程用setHead(node);设置为头结点（这里有个小坑，就是只有head头结点才是cpu正在执行的线程节点，后面的节点都是等待线程节点，而且在这个头结点执行的线程过程中头结点是可以中断的），如果设置头结点成功，就把锁标记为设置为true并返回，

6、然后再接着上一个步骤继续判断，如果没有获取锁成功，则进入挂起逻辑，也就是如果没有成功的话就进入下一个方法，node是当前线程的节点，pred是它的前置节点
boolean shouldParkAfterFailedAcquire(Node pred, Node node），在这个方法判断成功之后，会继续接着5的步骤把锁的标记设置为true，然后如果判断锁的标记是与否，否的话继续 cancelAcquire(node);

7、处理获取锁失败之后的挂起逻辑boolean shouldParkAfterFailedAcquire(Node pred, Node node)的方法，（1）前置节点的waitStatus是Node.SIGNAL则返回true，然后会执行parkAndCheckInterrupt()方法进行挂起,（2）如果前置节点的waitStatus大于0的话，把当前结点赋给前置结点的下一个结点，如果不大于0 的话，使用CAS的compareAndSetWaitStatus(pred, ws, Node.SIGNAL); 最后挂起的状态改为false，它是用来判断当前节点是否可以被挂起，也就是唤醒条件是否已经具备，即如果挂起了，那一定是可以由其他线程来唤醒的。该方法如果返回false，即挂起条件没有完备，那就会重新执行acquireQueued方法的循环体，进行重新判断，如果返回true，那就表示万事俱备

8、这里继续执行步骤5的 void cancelAcquire(Node node) 方法，拿到当前失败线程节点的等待状态是不是小于0，大于的话直接Node.CANCELLED;赋值给正在遍历的线程节点的waitStatus 中，然后继续判断当前节点是不是尾节点，是的话使用CAS操作compareAndSetNext(pred, predNext, null);把节点设置为空，若不是尾节点的话，当大于0的时候跳出循环，继续如果当前节点的后继节点没有被取消就把前置节点跟后置节点进行连接，相当于删除了当前节点compareAndSetNext(pred, predNext, next);

9、最后是释放锁，先去过去当前节点的waitStatus，然后如果waitStatus小于0尝试去释放锁使用compareAndSetWaitStatus(node, ws, 0)CAS操作，然后去判断如果当前线程节点的下一个节点，如果发现节点的waitStatus 小于0，就说明找到了待唤醒的节点，然后不为空的时候，就去唤醒该节点。

https://www.cnblogs.com/iou123lg/p/9464385.html（《Java并发编程-看懂AQS的前世今生》）

AQS产生背景
通过JCP的JSR166规范，Jdk1.5开始引入了j.u.c包，这个包提供了一系列支持并发的组件。这些组件是一系列的同步器，这些同步器主要维护着以下几个功能：内部同步状态的管理(例如表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。可以看下这里的4.2的图便能理解j.u.c包的组件构成。

　　几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性、开销及不灵活使j.u.c最多只能是一个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。因此，JSR166基于AQS类建立了一个小框架，这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也可以用它来定义自己的同步器。这个就是j.u.c的作者Doug Lea大神的初衷，通过提供AQS这个基础组件来构建j.u.c的各种工具类，至此就可以理解AQS的产生背景了。

AQS的设计和结构
2.1 设计思想
　　同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作是这样的：

　　while (当前同步器的状态不允许获取操作) {

        　　如果当前线程不在队列中，则将其插入队列

        　　阻塞当前线程

　　}

　　如果线程位于队列中，则将其移出队列

　　

　　release操作是这样的：

　　更新同步器的状态

　　if (新的状态允许某个被阻塞的线程获取成功)

         　　解除队列中一个或多个线程的阻塞状态

　　从这两个操作中的思想中我们可以提取出三大关键操作：同步器的状态变更、线程阻塞和释放、插入和移出队列。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：

　　·同步器状态的原子性管理；

　　·线程阻塞与解除阻塞；

　　·队列的管理；

　　由这三个基本组件，我们来看j.u.c是怎么设计的。

2.1.1 同步状态
　　AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。

 　　基于AQS的具体实现类（如锁、信号量等）必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。

2.1.2 阻塞
　　直到JSR166，阻塞线程和解除线程阻塞都是基于Java的内置管程，没有其它非基于Java内置管程的API可以用来达到阻塞线程和解除线程阻塞。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用，目前该方法基本已被抛弃。具体不能用的原因可以官方给出的答复。

　　j.u.c.locks包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合 ，可通过中断来unpark一个线程。

2.1.3 队列
　　整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。

　　CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head（头节点）和tail（尾节点）来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。如下图：

img

　　入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：

img

　　出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点的引用即可。出队操作示意图大致如下：

img

　　这一小节只是简单的描述了队列的大概，目的是为了表达清楚队列的设计框架，实际上CLH队列已经和初始的CLH队列已经发生了一些变化，具体的可以看查看资料中Doug Lea的那篇论文中的3.3 Queues。

2.1.4 条件队列
　　上一节的队列其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。

　　ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signalAll操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程（通过Object.wait等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。

　　ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：

img

　　await操作就是当前线程节点从同步队列进入条件队列进行等待，大致示意图如下：

img

　　实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。

2.2 方法结构
　　如果我们理解了上一节的设计思路，我们大致就能知道AQS的主要数据结构了。

组件	数据结构
同步状态	volatile int state
阻塞	LockSupport类
队列	Node节点
条件队列	ConditionObject
AQS的应用
AQS被大量的应用在了同步工具上。

　　ReentrantLock：ReentrantLock类使用AQS同步状态来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。ReentrantLock也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。

　　ReentrantReadWriteLock：ReentrantReadWriteLock类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。WriteLock的构建方式同ReentrantLock。ReadLock则通过使用acquireShared方法来支持同时允许多个读线程。

　　Semaphore：Semaphore类（信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；tryRelease方法会增加计数，在计数为正值时还要解除线程的阻塞。

　　CountDownLatch：CountDownLatch类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（对应到CountDownLatch中就是await方法）才能通过。

　　FutureTask：FutureTask类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（FutureTask的set方法）或取消（FutureTask的cancel方法）一个FutureTask时会调用AQS的release操作，等待计算结果的线程的阻塞解除是通过AQS的acquire操作实现的。

　　SynchronousQueues：SynchronousQueues类使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。

       除了这些j.u.c提供的工具，还可以基于AQS自定义符合自己需求的同步器。

ConcurrentHashMap 用到了 synchronized 么，说说 synchronized 的底层是怎么实现的
Java锁
 Java锁机制，都说一下~

乐观锁和悲观锁的使用场景

悲观锁的常见实现方式：lock synchronized retreentlock

乐观锁：CAS MVCC

读写锁的实现方式，16位int的前八位和后八位分别作为读锁和写锁的标志位

自旋锁

死锁的条件，怎么解除死锁，怎么观测死锁。

CAS原理，写了个底层源码

用过哪些锁呀？synchronized和reentrantLock区别

讲一讲reentrantLock底层啥样子，实现api

JDK 可重入锁， 读写锁 ， 底层 AQS，抽象队列同步器的机制

悲观锁和乐观锁， 概念上，JDK 中的类， CAS的缺点， 空转，ABA问题。使用pause指令， AtomicStampedReference

CAS， AQS 实现

乐观锁， 悲观锁， 举例， 可以顺便说一下， CAS，volatile， synchronized

Synchronized 和 ReentrantLock 区别

CAS 实现以及优缺点，用 CAS 实现阻塞队列（我也没听明白，自己说了下思路，面试官就说也行吧）

乐观锁，悲观锁

说一下锁

读写锁了解吗

CAS三大问题及解决方式

介绍一下Java中的锁？可重入锁如何实现的可重入？

乐观锁悲观锁，在Java中的体现，举例

CAS乐观锁原理

类锁和对象锁的不同

Java基础
抽象类和接口有什么不同
https://blog.csdn.net/gongxiao1993/article/details/82055007（《抽象类和接口有什么区别》）

参数	抽象类	接口
默认的方法实现	它可以有默认的方法实现	接口完全是抽象的。它根本不存在方法的实现
实现	子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。	子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
构造器	抽象类可以有构造器	接口不能有构造器
与正常Java类的区别	除了你不能实例化抽象类之外，它和普通Java类没有任何区别	接口是完全不同的类型
访问修饰符	抽象方法可以有public、protected和default这些修饰符	接口方法默认修饰符是public。你不可以使用其它修饰符。
main方法	抽象方法可以有main方法并且我们可以运行它	接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法）
多继承	抽象方法可以继承一个类和实现多个接口	接口只可以继承一个或多个其它接口
速度	它比接口速度要快	接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法	如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。	如果你往接口中添加方法，那么你必须改变实现该接口的类。
设计理念	表示的是“is-a”关系	表示的是“like-a”关系
如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。

如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。

如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法
同上

注解的原理
https://www.cnblogs.com/yangming1996/p/9295168.html（《Java注解的基本原理》）

以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。

于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。

关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。

追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。本文意不再辨析两者谁优谁劣，而在于以最简单的语言介绍注解相关的基本内容。

注解的本质
「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。

The common interface extended by all annotation types

所有的注解类型都继承自这个普通的接口（Annotation）

这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}
这是注解 @Override 的定义，其实它本质上就是：

public interface Override extends Annotation{
    
}
没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。

一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。

而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。

典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。

这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。

元注解
『元注解』是用于修饰注解的注解，通常用在注解的定义上

我们 @Override 注解的定义，你可以看到其中的 @Target，@Retention 两个注解就是我们所谓的『元注解』，『元注解』一般用于指定某个注解生命周期以及作用目标等信息。

JAVA 中有以下几个『元注解』：

@Target：注解的作用目标

@Retention：注解的生命周期

@Documented：注解是否应当被包含在 JavaDoc 文档中

@Inherited：是否允许子类继承该注解

其中，@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。

@Target的定义如下：

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    ElementType[] value();
}
我们可以通过以下的方式来为这个 value 传值：

@Target(value = {ElementType.FIELD})
被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。其中，ElementType 是一个枚举类型，有以下一些值：

ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上

ElementType.FIELD：允许作用在属性字段上

ElementType.METHOD：允许作用在方法上

ElementType.PARAMETER：允许作用在方法参数上

ElementType.CONSTRUCTOR：允许作用在构造器上

ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上

ElementType.ANNOTATION_TYPE：允许作用在注解上

ElementType.PACKAGE：允许作用在包上

@Retention 用于指明当前注解的生命周期，它的基本定义如下：

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    RetentionPolicy value();
}
同样的，它也有一个 value 属性：

@Retention(value = RetentionPolicy.RUNTIME
这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：

RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件

RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件

RetentionPolicy.RUNTIME：永久保存，可以反射获取

@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。

剩下两种类型的注解我们日常用的不多，也比较简单，这里不再详细的进行介绍了，你只需要知道他们各自的作用即可。@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。

JAVA 的内置三大注解
除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：

@Override

@Deprecated

@SuppressWarnings

@Override 注解想必是大家很熟悉的了，它的定义如下：

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。

所以你看，它就是一种典型的『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。

@Deprecated 依然是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。

当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。

@SuppressWarnings 主要用来压制 java 的警告，它的基本定义如下：

它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：

public static void main(String[] args) {
    Date date = new Date(2018, 7, 11);
}
这么一段代码，程序启动时编译器会报一个警告。

Warning:(8, 21) java: java.util.Date 中的 Date(int,int,int) 已过时

而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。

@SuppressWarning(value = "deprecated")
public static void main(String[] args) {
    Date date = new Date(2018, 7, 11);
}
这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。

当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。

自定义注解的相关内容就不再赘述了，比较简单，通过类似以下的语法即可自定义一个注解。

public @interface InnotationName{
    
}
当然，自定义注解的时候也可以选择性的使用元注解进行修饰，这样你可以更加具体的指定你的注解的生命周期、作用范围等信息。

注解与反射
上述内容我们介绍了注解使用上的细节，也简单提到，「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。

首先，我们自定义一个注解类型：

@Target(ElementType.METHOD, ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Hello {
    String value();
}
这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。

之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：

RuntimeVisibleAnnotations：运行时可见的注解

RuntimeInVisibleAnnotations：运行时不可见的注解

RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解

RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解

AnnotationDefault：注解类元素的默认值

给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。

所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。

getAnnotation：返回指定的注解

isAnnotationPresent：判定当前元素是否被指定注解修饰

getAnnotations：返回所有的注解

getDeclaredAnnotation：返回本元素的指定注解

getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的

方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。

首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。

-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true

然后 main 函数。

public class Test {
    @Hello("hello")
    public static void main(String[] args) throws NoSuchMethodException {
        Class cls = Test.class;
        Method method = cls.getMethod("main", String[].class);
        Hello hello = method.getAnnotation(Hello.class);
    }
}
我们说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。

我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：

public final class $Proxy1 extends Proxy implements Hello {
    public $Proxy1(InvocationHandler invocationhandler){
        super(invocationhandler);
    }
    public final String value(){
        try{
            return (String)super.h.invoke(this,m3,null);
        }
        catch(Error_ex){}
        catch(Throwable throwable){
            throw new UnderclaredThrowableException(throwable);
        }
    }
}
代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。

而这个关键的 InvocationHandler 实例是谁？

AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler， 这个类的设计也非常有意思。

这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。

而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。

var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。

如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。

那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。

其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。

最后我们再总结一下整个反射注解的工作原理：

首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = "hello"）。

接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。

然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。

最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。

那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，通过方法名返回注解属性值。

注解和接口的区别
https://www.cnblogs.com/linshenghui/p/11213867.html(《注解实际上是一个接口》)

自定义一个注解，编译后成一个class文件，

再反编译，是一个继承了Annotation的接口。

Class类、Method、Field类都有一个getAnnotation()方法，用于得到注解信息类对象

因此，反射与注解具有强关系。

Java三大特性
https://www.cnblogs.com/hysum/p/7100874.html（《JAVA基础——面向对象三大特性：封装、继承、多态》）

封装
		1、概念：

　　　　将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。

　　2、好处：

只能通过规定的方法访问数据。

隐藏类的实例细节，方便修改和实现。　

　　3、封装的实现步骤

修改属性的可见性（设为private）

创建getter/setter方法（用于属性的读写）

在getter/setter方法中加入属性控制语句（对属性值的合法性进行判断）

需要注意：对封装的属性不一定要通过get/set方法，其他方法也可以对封装的属性进行操作。当然最好使用get/set方法，比较标准。

A、访问修饰符
B、this关键字
C、Java 中的内部类
内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。

　那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！

答：内部类的主要作用如下：

内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。

内部类的方法可以直接访问外部类的所有数据，包括私有的数据。

内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。

　　内部类可分为以下几种： 

成员内部类

静态内部类

方法内部类

匿名内部类　　

继承
1、继承的概念

　继承是类与类的一种关系，是一种“is a”的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。

注：java中的继承是单继承，即一个类只有一个父类。

2、继承的好处

　子类拥有父类的所有属性和方法（除了private修饰的属性不能拥有）从而实现了实现代码的复用；　

3、语法规则，只要在子类加上extends关键字继承相应的父类就可以了：

A、方法的重写
　子类如果对继承的父类的方法不满意（不适合），可以自己编写继承的方法，这种方式就称为方法的重写。当调用方法时会优先调用子类的方法。

　重写要注意：

　    a、返回值类型

　　b、方法名

　　c、参数类型及个数

　都要与父类继承的方法相同，才叫方法的重写。

　重载和重写的区别：

　　方法重载：在同一个类中处理不同数据的多个相同方法名的多态手段。

　　方法重写：相对继承而言，子类中对父类已经存在的方法进行区别化的修改。

B、继承的初始化顺序
　　1、初始化父类再初始化子类

　　2、先执行初始化对象中属性，再执行构造方法中的初始化。

　基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是：

　父类对象属性初始化---->父类对象构造方法---->子类对象属性初始化--->子类对象构造方法　　　

C、final关键字
D、super关键字
super的应用：

　首先我们知道子类的构造的过程当中必须调用父类的构造方法。其实这个过程已经隐式地使用了我们的super关键字。

　这是因为如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法。

　那么如果自己用super关键字在子类里调用父类的构造方法，则必须在子类的构造方法中的第一行。

　要注意的是：如果子类构造方法中既没有显示调用父类的构造方法，而父类没有无参的构造方法，则编译出错。

（补充说明，虽然没有显示声明父类的无参的构造方法，系统会自动默认生成一个无参构造方法，但是，如果你声明了一个有参的构造方法，而没有声明无参的构造方法，这时系统不会动默认生成一个无参构造方法，此时称为父类有没有无参的构造方法。）

E、Object类
Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。

多态
面向对象的最后一个特性就是多态，那么什么是多态呢？多态就是对象的多种形态。

　java里的多态主要表现在两个方面：

1.引用多态　　　

　　父类的引用可以指向本类的对象；

　　父类的引用可以指向子类的对象；

2.方法多态

　　根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。

　　创建本类对象时，调用的方法为本类方法；

　　创建子类对象时，调用的方法为子类重写的方法或者继承的方法；

　　使用多态的时候要注意：如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！

　　注意： 继承是多态的基础。

A、引用类型转换　
　了解了多态的含义后，我们在日常使用多态的特性时经常需要进行引用类型转换。

　引用类型转换：

向上类型转换(隐式/自动类型转换)，是小类型转换到大类型。

　 就以上述的父类Animal和一个子类Dog来说明，当父类的引用可以指向子类的对象时，就是向上类型转换。

向下类型转换(强制类型转换)，是大类型转换到小类型(有风险,可能出现数据溢出)。

　　将上述代码再加上一行，我们再次将父类转换为子类引用，那么会出现错误，编译器不允许我们直接这么做，虽然我们知道这个父类引用指向的就是子类对象，但是编译器认为这种转换是存在风险的。

instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。

B、抽象类
C、接口
基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理
基本类型和包装类型的区别
https://blog.csdn.net/qq_36746327/article/details/79678655（《基本类型和包装类的区别》）

 区别：

1.基本类型存储在栈里，包装类型存储在堆里。因为栈的效率更高，所以保留了基本类型。

2.包装类是对象，拥有方法和字段，对象的调用是引用对象的地址。

3.基本类型是值传递，包装类是引用传递。

4.向ArrayList，LinkedList中放数据的时候，只能放Object类型的，基本类型放不进去。

包装类的默认值为Null。

自动装箱和自动拆箱
简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

这个过程是自动执行的，那么我们需要看看它的执行过程：

public class Main {
     public static void main(String[] args) {
     //自动装箱
     Integer total = 99;

     //自定拆箱
     int totalprim = total;
     }
}
反编译class文件之后得到如下内容：

Integer total = 99; 
执行上面那句代码的时候，系统为我们执行了： 
Integer total = Integer.valueOf(99);

int totalprim = total; 
执行上面那句代码的时候，系统为我们执行了： 
int totalprim = total.intValue();

我们现在就以Integer为例，来分析一下它的源码： 
1、首先来看看Integer.valueOf函数

public static Integer valueOf(int i) {
     return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];
}
它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行SMALL_VALUES[i + 128]。

首先我们来看看Integer的构造函数：

private final int value;
 
public Integer(int value) {
   this.value = value;
}

public Integer(String string) throws NumberFormatException {
    this(parseInt(string));
}
它里面定义了一个value变量，创建一个Integer对象，就会给这个变量初始化。第二个传入的是一个String变量，它会先把它转换成一个int值，然后进行初始化。

下面看看SMALL_VALUES[i + 128]是什么东西：

private static final Integer[] SMALL_VALUES = new Integer[256];
它是一个静态的Integer数组对象，也就是说最终valueOf返回的都是一个Integer对象。

所以我们这里可以总结一点：装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。

2、接着看看intValue函数

@Override
public int intValue() {
    return value;
}
下面我们进行一个归类： 
Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 
Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。

下面对Integer派别进行一个总结，如下图： 

这个很好理解，因为对于Integer，在(-128,128]之间只有固定的256个值，所以为了避免多次创建对象，我们事先就创建好一个大小为256的Integer数组SMALL_VALUES，所以如果值在这个范围内，就可以直接返回我们事先创建好的对象就可以了。

但是对于Double类型来说，我们就不能这样做，因为它在这个范围内个数是无限的。 
总结一句就是：在某个范围内的整型数值的个数是有限的，而浮点数却不是。

下面来进一步讨论其他情况。

Integer num1 = 400;  
int num2 = 400;  
System.out.println(num1 == num2); //true
说明num1 == num2进行了拆箱操作

Integer num1 = 100;  
int num2 = 100;  
System.out.println(num1.equals(num2));  //true
我们先来看看equals源码：

@Override
public boolean equals(Object o) {
    return (o instanceof Integer) && (((Integer) o).value == value);
}
我们指定equal比较的是内容本身，并且我们也可以看到equal的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。

Integer num1 = 100;  
int num2 = 100;  
Long num3 = 200l;  
System.out.println(num1 + num2);  //200
System.out.println(num3 == (num1 + num2));  //true
System.out.println(num3.equals(num1 + num2));  //false
1、当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。 
2、对于num3.equals(num1 + num2)为false的原因很简单，我们还是根据代码实现来说明：

1 @Override
2 public boolean equals(Object o) {
3     return (o instanceof Long) && (((Long) o).value == value);
4 }
它必须满足两个条件才为true： 
1、类型相同 
2、内容相同 
上面返回false的原因就是类型不同。

总结： 

1、需要知道什么时候会引发装箱和拆箱 

2、装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。

3、equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱

4、当两种不同类型用==比较时，包装器类的需要拆箱， 当同种类型用==比较时，会自动拆箱或者装箱

&和&&区别
https://www.cnblogs.com/minshia/p/6023950.html(《Java中&和&&的区别》)

Java中&&和&都是表示与的逻辑运算符，都表示逻辑运输符and，当两边的表达式都为true的时候，整个运算结果才为true，否则为false。

&&的短路功能，当第一个表达式的值为false的时候，则不再计算第二个表达式；&则两个表达式都执行。

&可以用作位运算符，当&两边的表达式不是Boolean类型的时候，&表示按位操作。

String ，StringBuffer，StringBuilder哪个是安全的，我就说反过。。
字符串编码的区别，被问到过，我觉得比较容易被忽视的一个点

什么是泛型，怎么用泛型

Comparable和Comparator接口是干什么的，其区别

多态的原理是什么，感觉这个很容易被问到

如何通过反射和设置对象私有字段的值

反射的实现及原理  希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法

BigDecimal java中的一个类，我觉得，多一些思考是比较重要的

在java中，0.000000001 和0其实是判定相等的，那么我怎么才能得到真实值呢

重载和重写的区别

String是基本数据类型吗？能被继承吗？final关键字

java中反射获取到的属性和方法是存储在什么地方

反射如何获取方法上的注解

说一下final

java的链式调用是怎么实现的

说一说NIO

java基本类型和占用字节数，回答八种，也特意提到boolean类型，1或者4个字节，为什么？

你说你熟悉Java基础，那讲一讲int与Integer的区别。我特意解释了拆箱装箱、Integer的一些源码、泛型的应用。

说一下string stringbuffer  stringbuilder

接口和虚函数。

final关键字，final修饰的方法不能被重写，能被重载吗
（在这里额外提了Java内存模型对于final的底层实现）

equals 和 == 
（可以谈谈自动装箱方面的不同）

了解IO吗？BIO、AIO

java类变量的加载过程，父类静态变量和子类静态变量哪个先加载，int和long哪个先加载

java元注解

讲一下 static

讲一下基本类型，String 是不是基本类型

讲一下 String 基本类型的转换

讲一下 final

讲一下接口和抽象类

讲一下 Java 里面的 clone

GBK 里面中文字符占用字节数

动态编译和静态编译的区别

equals和==的区别

java文件读写

反射机制

封装 继承 多态

equals和hashcode

stringbuffer和stringbuilder

wait和sleep

接口和抽象类

上手就问你了解反射么，讲讲吧？我真不知道从哪里讲起。
然后问反射的private的访问，关于是否能访问私有成员变量
那private还有什么用
反射的优缺点
反射的使用场景
反射怎么使用

反射的作用，反射相关的类（我说了一些反射相关的方法，说不太清楚相关的类是什么意思，后来才知道他说的是construction这种类，我就说还有字段，方法这种，他还说我没回答清楚他的问题，我说您是要我把这些单词说出来吗？他又说你和别人说类的时候不可能说构造器，肯定说的是construction这个单词，好吧。。）  

问创建对象的几种方式

Java内存模型
Java内存模型说一下

JVM的内存模型 （我开始以为他问的是工作内存和主内存），他说不是，不用讲这些，他说记住我问的问题，我说您问的是栈，堆之类吗？他说是的，然后就给他解释（我一直记得内存结构是这些，内存模型是工作内存和主内存，还特意区分了）  

Java集合
HashMap和ConcurrentHashMap哪个效率更高？为什么？

ConcurrentHashMap和HashMap

常用类型

      Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等      

      concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等      

      HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些      

      ArrayList  优势，扩容，什么时候用      

      LinkedList  优势，什么时候用，和arraylist的区别 等等      

      HashSet，TreeMap

List，Map，Set接口在取元素时，各有什么特点

hashmap线程安全实现

hashmap扩容方面做了哪些优化？我只答出了红黑树。

concurrenthashmap中1.7和1.8的区别

arraylist和linkedlist区别

说下hashmap/hashtable/concurrenthashmap，说底层了；

那你说一说hashmap的实现(这里非常详细的展开说了实现原理）

那hashmap安全吗？(不安全，我们可以用blabla...)

那说说concurrenthashmap的原理

如果一个hashmap有一亿条数据怎么实现高效查找; 答：可以考虑优化hash函数减少碰撞(事后大佬指点分布不均匀的话更好的应该是进行分层)

阅读过哪些集合源码？重点提了hashmap的哈希算法

你对集合那么熟悉，看过哪些源码？HashMap，HashTable，ConcurrentHashMap等等

讲到ArrayList，讲一下初始长度，扩容机制。

 说一下ArrayList和LinkedList区别，然后讲了大量数据下在LinkedList前1/10处插入效率高，在ArrayList中部以及后部插入效率高，解释原因。

楼主故意引线程安全的CopyOnWriteArrayList，然后把源码吹了一下。

HashMap和Hashtable区别，我特意提了哈希算法不一样，各自的算法原理，提问：为什么不一样？

Hashtable为什么不用HashMap的？

HashMap1.8优化在哪些方面？

CopyOnWriteArrayList底层实现

看过哪些源码，（hashmap，concurrenthashmap，hashtable），那你说说各自的特点。（把concurrenthashmap和hashtable说混了，面完了才想起）

集合类说一下， 说一下ArrayList 和 LinkedList， ArrayList为什么用数组，怎么扩容， 为什么扩容的时候新建数组，而不是数组去扩容。

HashMap 的底层， 跟hashtable有什么区别？

HashMap和ConcurrentHashMap

 Arraylist线程安全吗？有其他数据结构是线程安全的吗？

Map ,hashmap底层实现？链表过长怎么办？红黑树特点 复杂度

平衡二叉树？hashmap底层实现，红黑树特点？

Java中线程安全的类

问我HashMap是不是线程安全的，为什么不安全，会出现哪些问题，我讲了扩容出现环死循环，然后问我死循环cpu的状态是怎么样的，我答是100%，然后问我死循环其他线程能不能使用cpu，然后又问比如一个四核cpu占有率又是多少，cpu100%对整个服务器有什么影响。  

HashMap，ConcurrentHashMap，说了ConcurrentHashMap的1.7和1.8的不同和具体实现

集合类，HashMap 的底层结构，为什么使用红黑树

链表和数组的区别，提到 ArrayList，讲一下插入删除和扩容

HashMap 查找效率最低和最高

ConcurrentHashMap 读写加锁的情况

HashMap 的扩容，JDK 1.7和 JDK 1.8 扩容的区别

有几种方法可以让 HashMap 变得线程安全

HashMap的数据结构怎么样的，我就说了一下 数组和链表这种，不知道是不是他的意思
key可否null，为什么
是否线程安全，否则会发生什么情况

HashMap、Hashtable、ConcurrentHashMap的比较（扯了Hashtable不绝对安全）

Java8
JDK8的stream的操作

版本8-12，每个大版本更迭引入的新功能或新特性是什么

在JDK8中移除永久代，并把方法区移至元空间，这么设计的原因是什么

jdk1.8和jdk1.9的新特性。听到这个楼主一脸懵逼，1.9根本不会，只能把1.8的一些新特性结合具体例子跟他讲了一下，比较满意。

java1.8中有哪些新的特性？(随便答了一些）

异常
异常捕获处理

讲一讲异常， throwable, exception， error

try catch finally 都出现return的情况

异常有哪几种方式， 怎么自己写一个异常。

Error和Exception区别

算法
堆排序、栈实现队列、反转链表

1亿个手机号码，判断重复

排序算法

八大排序算法真的是面试宠儿

最常考 快速排序 和归并排序

哪些排序算法是稳定的 哪些是不稳定的

堆排 也应该掌握

回溯算法

走迷宫

游戏通关

递推算法

走台阶

断钢筋

背包问题

装最多的东西

贪心算法

覆盖问题

时间问题

动态规划算法，你写过吗？我说写过leetcode上的问题

两个链表判断是否相交，怎么找第一个相交点

开放题，服务器1上有40T的数据，服务器2上有一个任务需要这些数据，在网络带宽限制的情况下，怎么把数据快速传到服务器2上

设计一个数据结构实现LRU

来，继续撸算法吧。给一个string类型数字字符串，比如“1026”，范围0000-9999，打印繁体读法string-----"壹仟零贰什陆”

数组最长递减子序列，写了个动态规划，比较简单。

非递减序列找到第一个大于x的位置，时间复杂度要求lgN（二分）

一个完全由数字组成的字符串，求字符序列子串可以被k整除的个数，要求O（N），有点难度，没A全

给定一个数组（全为0~9的数字），可能有重复，挑出数字自由组合，给定数k，找最小的大于k的数（回溯），没撸完，这个是败笔，撸了半个小时，跟面试官讨论了好久，面试官也提示我用回溯，可是我太菜不会呀。

两个文件，分别存放50亿个URL，每个URL60个字节，内存4G，找两个文件并集。

一个文件，存放45亿已排好序的32位int整数，找出一个出现次数大于一次的整数，找出一个就行。

找到字符串中第一个出现次数只有一次的字母，比如abcdab，输出c，两种方法

写了个二分查找。面试官问我，你确定数组就是排序的么（我心里无语），数组非空判断不用（我服）？

随便写个排序 我写的快排

分析一下快速排序的时间复杂度和算法复杂度？

算法题：计算一个有环链表的节点数

归并排序？

归并排序的时间复杂度？

topK问题

一个long类型的数，让他整个位倒转，能不能只迭代8次完成

一个数组一个数只有一个其他数两个，找到单独的那个数（LeetCode原题）

一个数组有一个数超过一半，找到这个数（LeetCode原题）

问了一个大数据判重的题，只有一台机器，数据是int范围，给了3个思路，一个是hash切分大文件为小文件，对小文件用hashset去做判重，还有用BitSet，单机大概500mb内存可以解决，最后一个是用布隆过滤器解决，内存利用更小。 然后问我布隆过滤器的误差怎么解决，我说可以加大hash数量或者hash的范围，还有可以用多个独立的不同的布隆过滤器来解决。  

算法，排序算法，给场景考虑采用哪种

递归需要考虑一些什么，提到动态规划

算法题：156个元素数组，二分查找最少要多少次比较，最多多少次

敏感词过滤算法的过程

堆排序的实现过程，怎样调整堆；快排有没有稳定性，为什么

编程题6个（给了40分钟，只写了4个题）

将一个数字转任意进制（2-50进制） 

写一段代码判断当前环境的字节序 

实现单链表的有序插入，并思考如何在有序链表的基础上提高查找效率 

给定一个数组，求 max(A[i] & A[j])，时间复杂度不高于O(N2N^{2}N2)  

给定一个无序的大数组，如何找出中位数？如果有100亿个数，内存只有 4G 呢？ 

KMP 算法

给了一个例子让阐述解决思路：有十个线程，更新变量的值，每次加1，同时打出，每个线程只能打印一次，当十个线程打完以后，同时打一句话任务结束。

算法两道：

  1.找到两个存放了1亿多字符串的文件的相同的字符串 

  2.假设一个场景，支付系统和订单系统，支付失败后订单系统怎么知道失败（感觉是分布式事务的一致性，我开始问他是两个系统吗？是分布式吗？他也不回答我，后面复述一遍问题我又问了一遍分布式事务的一致性，他才说是的）

数据结构
B+树的叶子节点

树

根据遍历结果恢复树，递归

二叉搜索树第k大

树的和为k的路径

层次遍历

根据层次遍历和后序遍历恢复树

镜像树

树的深度

是不是平衡二叉树

链表

反转链表

链表环的入口

交叉链表的交点

复杂链表的复制

二叉搜索树变成双向链表

红黑树和跳表

红黑树的优缺点

栈用过吗？用栈实现二叉树非递归中序遍历

双向链表 优点

有哪些二叉树？搜索二叉树、平衡二叉树、红黑树，举个例子，什么时候用过

平衡二叉树和普通二叉树有什么区别，为什么要用平衡二叉树

各种hash区别，底层怎么实现的

问平衡二叉树，给了一些数据，让我讲出每一个插入后，树的状态。

堆栈的特点和应用场景

介绍下树，前缀树的应用场景，可以怎样优化

Spring
ioc原理详细讲讲，源码看过么

aop原理和应用

Spring

      spring的两大特性- ioc  aop，实现原理      

      如果存在A依赖B，B依赖A，那么是怎么加到IOC中去的      

      beanFactory的理解，怎么加载bean      

      FactoryBean的理解      

      基于注解的形式，是怎么实现的， 你知道其原理吗，说一下      

      依赖冲突，有碰到过吗，你是怎么解决的~      

      bean的生命周期      

      依赖注入的几种方式      

      spring中的自动装配方式      

      总之，建议大家如果时间充裕，还是好好看看源码~~

spring中是如何进行依赖注入的，依赖注入的原理

讲一讲spring的事务特性
https://blog.csdn.net/trigl/article/details/50968079 (《Spring事务管理（详解+实例）》)

ACID
事务有四个特性：ACID

原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。

一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。

隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。

持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。

核心接口
Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务，下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略。 

Spring事务管理涉及的接口的联系如下：

2.1 事务管理器
Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 

Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：

Public interface PlatformTransactionManager()...{  
    // 由TransactionDefinition得到TransactionStatus对象
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; 
    // 提交
    Void commit(TransactionStatus status) throws TransactionException;  
    // 回滚
    Void rollback(TransactionStatus status) throws TransactionException;  
    } 
从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。

2.1.1 JDBC事务
如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：

    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。

2.1.2 Hibernate事务
如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：

    <bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>
sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。

2.1.3 Java持久化API事务（JPA）
Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：

    <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>
JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。

2.1.4 Java原生API事务
如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：

    <bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">
        <property name="transactionManagerName" value="java:/TransactionManager" />
    </bean>
JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。

2.2 基本事务属性的定义
上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。 

那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面，如图所示：

![img](E:\个人文件\博客\Java面试题目库题解.assets\20160325003448793)

而TransactionDefinition接口内容如下：

public interface TransactionDefinition {
    int getPropagationBehavior(); // 返回事务的传播行为
    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据
    int getTimeout();  // 返回事务必须在多少秒内完成
    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的
} 
我们可以发现TransactionDefinition正好用来定义事务属性，下面详细介绍一下各个事务属性。

2.2.1 传播行为
事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：

传播行为	含义
PROPAGATION_REQUIRED	表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务
PROPAGATION_SUPPORTS	表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行
PROPAGATION_MANDATORY	表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常
PROPAGATION_REQUIRED_NEW	表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
PROPAGATION_NOT_SUPPORTED	表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
PROPAGATION_NEVER	表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常
PROPAGATION_NESTED	表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务
注：以下具体讲解传播行为的内容参考自Spring事务机制详解 

（1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。

//事务属性 PROPAGATION_REQUIRED
methodA{
    ……
    methodB();
    ……
}
//事务属性 PROPAGATION_REQUIRED
methodB{
   ……
}
使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。

单独调用methodB方法：

main{ 
    metodB(); 
}  
相当于

Main{ 
    Connection con=null; 
    try{ 
        con = getConnection(); 
        con.setAutoCommit(false); 

        //方法调用
        methodB(); 

        //提交事务
        con.commit(); 
    } Catch(RuntimeException ex) { 
        //回滚事务
        con.rollback();   
    } finally { 
        //释放资源
        closeCon(); 
    } 
} 
Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。
单独调用MethodA时，在MethodA内又会调用MethodB.

执行效果相当于：

main{ 
    Connection con = null; 
    try{ 
        con = getConnection(); 
        methodA(); 
        con.commit(); 
    } catch(RuntimeException ex) { 
        con.rollback(); 
    } finally {    
        closeCon(); 
    }  
} 
调用MethodA时，环境中没有事务，所以开启一个新的事务.当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。

（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。

//事务属性 PROPAGATION_REQUIRED
methodA(){
  methodB();
}

//事务属性 PROPAGATION_SUPPORTS
methodB(){
  ……
}
单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。

（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。

//事务属性 PROPAGATION_REQUIRED
methodA(){
    methodB();
}

//事务属性 PROPAGATION_MANDATORY
    methodB(){
    ……
}
当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入到methodA的事务中，事务地执行。

（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。

//事务属性 PROPAGATION_REQUIRED
methodA(){
    doSomeThingA();
    methodB();
    doSomeThingB();
}

//事务属性 PROPAGATION_REQUIRES_NEW
methodB(){
    ……
}
调用A方法：

main(){
    methodA();
}
相当于

main(){
    TransactionManager tm = null;
    try{
        //获得一个JTA事务管理器
        tm = getTransactionManager();
        tm.begin();//开启一个新的事务
        Transaction ts1 = tm.getTransaction();
        doSomeThing();
        tm.suspend();//挂起当前事务
        try{
            tm.begin();//重新开启第二个事务
            Transaction ts2 = tm.getTransaction();
            methodB();
            ts2.commit();//提交第二个事务
        } Catch(RunTimeException ex) {
            ts2.rollback();//回滚第二个事务
        } finally {
            //释放资源
        }
        //methodB执行完后，恢复第一个事务
        tm.resume(ts1);
        doSomeThingB();
        ts1.commit();//提交第一个事务
    } catch(RunTimeException ex) {
        ts1.rollback();//回滚第一个事务
    } finally {
        //释放资源
    }
}
在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。

（5）PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。（代码示例同上，可同理推出）

（6）PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。

（7）PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。

//事务属性 PROPAGATION_REQUIRED
methodA(){
    doSomeThingA();
    methodB();
    doSomeThingB();
}

//事务属性 PROPAGATION_NESTED
methodB(){
    ……
}
如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：

main(){
    Connection con = null;
    Savepoint savepoint = null;
    try{
        con = getConnection();
        con.setAutoCommit(false);
        doSomeThingA();
        savepoint = con2.setSavepoint();
        try{
            methodB();
        } catch(RuntimeException ex) {
            con.rollback(savepoint);
        } finally {
            //释放资源
        }
        doSomeThingB();
        con.commit();
    } catch(RuntimeException ex) {
        con.rollback();
    } finally {
        //释放资源
    }
}
当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。

嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。

PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。

使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。

PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。

另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。

由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.

PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。

2.2.2 隔离级别
事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。

（1）并发事务引起的问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。

脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。

不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。

幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。

不可重复读与幻读的区别

不可重复读的重点是修改:
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
例如：在事务1中，Mary 读取了自己的工资为1000,操作并没有完成

	con1 = getConnection();  
    select salary from employee empId ="Mary";  
在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.

    con2 = getConnection();  
    update employee set salary = 2000;  
    con2.commit();  
在事务1中，Mary 再次读取自己的工资时，工资变为了2000

    //con1  
    select salary from employee empId ="Mary"; 
在一个事务中前后两次读取的结果并不一致，导致了不可重复读。

幻读的重点在于新增或者删除：
同样的条件, 第1次和第2次读出来的记录数不一样
例如：目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。

    con1 = getConnection();  
    Select * from employee where salary =1000; 
共读取10条记录

这时另一个事务向employee表插入了一条员工记录，工资也为1000

con2 = getConnection();  
Insert into employee(empId,salary) values("Lili",1000);  
con2.commit();  
事务1再次读取所有工资为1000的员工

    //con1  
    select * from employee where salary =1000; 
共读取到了11条记录，这就产生了幻像读。

从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。
对于前者, 只需要锁住满足条件的记录。
对于后者, 要锁住满足条件及其相近的记录。

（2）隔离级别

隔离级别	含义
ISOLATION_DEFAULT	使用后端数据库默认的隔离级别
ISOLATION_READ_INCOMMITED	最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
ISOLATION_READ_COMMITTED	允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
ISOLATION_REPEATABLE_READ	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
ISOLATION_SERIALIZABLE	最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的
2.2.3 只读
事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。

2.2.4 事务超时
为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。

2.2.5 回滚规则
事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）
但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。

2.3 事务状态
上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：

public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事物
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
} 
可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。

3 编程式事务
3.1 编程式和声明式事务的区别
Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。
简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。

spring bean的实例化过程。 ——不熟悉的地方不要写上去。

IOC 的实例化过程，原理

AOP， JDK代理， Proxy， InvocationHandler

AOP 动态代理

Spring 问题，IOC、AOP、代理模式，JDK 和 CGLIB 区别，代理模式底层实现，对 IOC 的理解

一个类里面有两个方法A和B，方法A有@Transaction，B没有，但B调用了A，外界调用B会不会触发事务？
https://blog.csdn.net/u010235716/article/details/90171802 （《@Transactional 同一个类中无事务方法a()内部调用有事务方法b()的问题》）

1. 事务的4种特性
序号	参数	含义
1	原子性（Atomicity）	事务是数据库的逻辑工作单位，它对数据库的修改要么全部执行，要么全部不执行。
2	一致性（Consistency）	事务前后，数据库的状态都满足所有的完整性约束。
3	隔离性（Isolation）	并发执行的事务是隔离的，一个不影响一个。通过设置数据库的隔离级别，可以达到不同的隔离效果
4	持久性（Durability）	在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
2.Transactional（）控制事务传播的配置项目（默认Propagation.REQUIRED）
@Transactional(propagation=Propagation.REQUIRED)           //控制事务传播。默认是Propagation.REQUIRED
@Transactional(isolation=Isolation.DEFAULT)                //控制事务隔离级别。默认跟数据库的隔离级别相同
@Transactional(readOnly=false)                             //控制事务可读写、只可读。默认可读写
@Transactional(timeout=30)                                 //控制事务的超时时间，单位秒。默认跟数据库的事务控制系统相同
@Transactional(rollbackFor=RuntimeException.class)         //控制事务遇到哪些异常会回滚。默认是RuntimeException
@Transactional(rollbackForClassName=RuntimeException)      //同上
@Transactional(noRollbackFor=NullPointerException.class)   //控制事务遇到哪些异常不会回滚。默认遇到RuntimeException回滚
@Transactional(noRollbackForClassName=NullPointerException)//同上
3.事务的7种传播特性
序号	传播行为	含义
1	REQUIRED	如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
2	SUPPORTS	如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行
3	MANDATORY	如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
4	NESTED	如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行
5	NEVER	总是非事务地执行，如果存在一个活动事务，则抛出异常
6	REQUIRES_NEW	总是开启一个新的事务。如果一个事务已经存在，则将这个已经存在的事务挂起
7	NOT_SUPPORTED	总是非事务地执行，并挂起任何存在的事务
4.事务的传播案例：
事务在A类的a()方法中调用B类的b()方法的传播案例

B.b()的事务配置	a()没有事务的结果	a()有事务的结果
REQUIRED	b()创建自己的事务;	b()接受a()的事务
SUPPORTS	b()不创建自己的事务;	b()接受a()的事务
MANDATORY	b()报异常	b()接受a()的事务
NESTED	b()创建自己的事务;	b()接受a()的事务，成为a()嵌套的子事务
NEVER	b()不创建自己的事务;	b()报异常
REQUIRES_NEW	b()创建自己的事务;	b()不接受a()的事务，b()先执行,内层事务失败不会影响外层事务
NOT_SUPPORTED	b()不创建自己的事务;	b()不接受a()的事务，b()先执行
5.特殊案例分析：
Java案例：无事务a()方法中调用同一个类的有事务b()方法问题案例

声明式事务基于Spring AOP实现,将具体业务逻辑与事务处理解耦，在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。

即：

==同一类中a()方法没有@Transactional 注解，在其内部调用有@Transactional 注解的方法，有@Transactional 注解的方法b()的事务被忽略，不会发生回滚。==

spring中用到的设计模式
https://www.cnblogs.com/AndyAo/p/8666385.html (《Spring中的用到的设计模式大全》)

spring中常用的设计模式达到九种，我们举例说明：

第一种：简单工厂

又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 
简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 
spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。

~~~xml
<beans>
    <bean id="singletonBean" class="com.itxxz.HelloItxxz">
        <constructor-arg>
            <value>Hello! 这是singletonBean!value>
        </constructor-arg>
   </ bean>
    <bean id="itxxzBean" class="com.itxxz.HelloItxxz" singleton="false">
        <constructor-arg>
            <value>Hello! 这是itxxzBean! value>
        </constructor-arg>
    </bean>
</beans>
~~~

第二种：工厂方法（Factory Method）

通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。

一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。

就以工厂方法中的静态方法为例讲解一下：

import java.util.Random;

public class StaticFactoryBean {
      public static Integer createRandom() {
           return new Integer(new Random().nextInt());
       }
}
建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称

<bean id="random" class="example.chapter3.StaticFactoryBean" factory-method="createRandom" />
      //createRandom方法必须是static的,才能找到 scope="prototype"
测试:

public static void main(String[] args) {
      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例       XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource("config.xml"));       System.out.println("我是IT学习者创建的实例:"+factory.getBean("random").toString());
}
第三种：单例模式（Singleton）
保证一个类仅有一个实例，并提供一个访问它的全局访问点。 
spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 
核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定

第四种：适配器（Adapter）
在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。

Adapter类接口：Target

public interface AdvisorAdapter {
    boolean supportsAdvice(Advice advice);
    MethodInterceptor getInterceptor(Advisor advisor);
} 
MethodBeforeAdviceAdapter类，Adapter

class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {
      public boolean supportsAdvice(Advice advice) {
            return (advice instanceof MethodBeforeAdvice);
      }
    
      public MethodInterceptor getInterceptor(Advisor advisor) {
            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
      		return new MethodBeforeAdviceInterceptor(advice);
      }
}
第五种：包装器（Decorator）
在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ 

首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。
spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 

第六种：代理（Proxy）
为其他对象提供一种代理以控制对这个对象的访问。  从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 
spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 

第七种：观察者（Observer）
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 

第八种：策略（Strategy）
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 
spring中在实例化对象的时候用到Strategy模式
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： 

第九种：模板方法（Template Method）
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 

以下是一个具体的例子： 
JdbcTemplate中的execute方法 

JdbcTemplate执行execute方法 

为什么要用spring,不用spring的话要怎么办

什么是AOP，举个例子

Spring的bean的生命周期

Spring的bean的加载过程，越具体越好，答了bean的生命周期，bean获取那一块的确不太熟没敢答。

为什么用 Spring, SpringMVC

AOP 的原生 API 有没有了解

AOP 动态代理有哪几种实现方式，有什么区别

bean 的生命周期

 ioc 含义和原理

aop 含义和原理

spring事务

IOC、DI原理

Spring怎么注入一个私有成员变量？（反射，设置可见性true）

Spring MVC
除了@ResponseBody，controller层如何标准返回给前端所要的数据类型？你会怎么实现？

Spring MVC的原理和流程
https://www.jianshu.com/p/8a20c547e245（《SpringMVC执行流程及工作原理》）

SpringMVC执行流程:
1.用户发送请求至前端控制器DispatcherServlet

2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。

3.处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。

4.DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作

5.执行处理器Handler(Controller，也叫页面控制器)。

6.Handler执行完成返回ModelAndView

7.HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet

8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9.ViewReslover解析后返回具体View

10.DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。

11.DispatcherServlet响应用户。

组件说明：
1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现

2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现

3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。

4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。

5.ModelAndView是springmvc的封装对象，将model和view封装在一起。

6.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。

7.View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。

SpringMVC

      和struct的区别      

      你一般是怎么对mvc项目进行分层的      

      dispatch-servlet的工作原理      

      ***怎么配置，工作原理      

      为什么有了springmvc还要在项目中使用spring？      

      springmvc的运行机制，dispatch -》 hanldermapping-—》handler -》handlerAdapter-》执行handler-》modelandview -》 返回mv -》 视图解析器-》返回view -》 渲染响应

SpringMVC 有几个IOC容器？由什么决定？有点懵，特意反复跟面试官确认这个问题，在IOC概念饶了一圈又一圈，回答不好。

SpringMVC的 dispatcher-servlet的请求解析过程

SpringMVC 的请求过程，客户端的查询请求到渲染页面返回给用户的流程

spring mvc流程

springmvc流程讲一下

SpringMVC执行流程

MyBatis
mybatis

配置

怎么防止依赖注入

和hibernate相比，为什么选择mybatis

怎么让mapper 和xml对应

如何自动包装对象

逆向工程

mybatis如何进行类型转换

mybatis的xml有什么标签

Mybatis是如何做到动态sql解析

Mybatis是如何实现xml文件与实体类的映射

Mybatis优点

mybatis防止sql注入怎么实现

Spring Boot
SpringBoot Starter原理

SpringBoot

      和spring相比，做了什么改变      

      starter你知道哪些      

      如何部署springmvc项目 以及如何部署springboot项目      

      springboot的插件，你使用过哪些

问 Springboot 和 Spring 区别

springboot怎么启动的？遇到过什么问题吗？是放到tomcat吗？启动的时候加载的信息是什么东西？

为什么要用springboot+mybatis

SpringBoot 有什么好处，答一个好处就问是怎么实现这个好处的（这谁记这个，服）

Spring Cloud
降级处理hystrix了解过么

限流算法

eureka 2.0已经停止更新了，替换？ Consul、Nacos、Etcd

介绍服务降级和熔断
服务限流和降级有什么区别
服务降级原理
服务限流原理（算法）
怎么实现令牌桶
令牌桶中令牌用对象还是计数器，各有什么优缺点（生命周期）
令牌生产和消费策略
令牌生产和消费在一个桶和两个桶怎么控制

Eureka的服务注册发现原理，服务剔除原理（顺便说了Eureka集群）

配置中心怎么用的（没做，架构图上画了，说了GitHub）

Shiro
shiro

怎么做权限控制

为什么使用shiro，你直接使用aop不也是一样的吗，shiro还有标签~各种扯

shiro的两个最重要的函数

认证和授权是怎么做的

Redis
Redis的缓存淘汰策略有哪些？

redis的热点key问题

redis的更新策略（先操作数据库还是先操作缓存）

为什么选择redis，有什么好处，基于内存，抗压     

redis集群怎么进行数据分配，hash槽
https://www.jianshu.com/p/6ad87a1f070e（《redis 一致性哈希和哈希槽》）

1、集群分片模式
如果 redis 只用复制功能做主从，那么当数据量巨大的情况下，单机情况下可能已经承受不下一份数据，更不用说是主从都要各自保存一份完整的数据。在这种情况下，数据分片是一个非常好的解决办法。

redis 的 custer 正是用于解决该问题。它主要提供两个功能：

1、自动对数据分片，落到各个节点上

2、即使集群部分节点失效或者连接不上，依然可以继续处理命令

对于第二点，它的功能有点类似于 sentienl 的故障转移，在这里不细说。下面详细了解下 redis 的槽位分片原理，在此之前，先了解下分布式简单哈希算法和一致性哈希算法，以帮助理解槽位的作用。

2、简单哈希算法
假设有三台机，数据落在哪台机的算法为：

c = Hash(key) % 3

例如 key A 的哈希值为4，4 % 3 = 1，则落在第二台机。Key ABC 哈希值为11，11 % 3 = 2，则落在第三台机上。

利用这样的算法，假设现在数据量太大了，需要增加一台机器。A 原本落在第二台上，现在根据算法4 % 4 = 0，落到了第一台机器上了，但是第一台机器上根本没有 A 的值。这样的算法会导致增加机器或减少机器的时候，引起大量的缓存穿透，造成雪崩。

3、一致性哈希算法
在1997年，麻省理工学院的 Karger 等人提出了一致性哈希算法，为的就是解决分布式缓存的问题。

在一致性哈希算法中，整个哈希空间是一个虚拟圆环。

假设有四个节点 Node A、B、C、D，经过 ip 地址的哈希计算，它们的位置如下：

有4个存储对象 Object A、B、C、D，经过对 Key 的哈希计算后，它们的位置如下：

对于各个 Object，它所真正的存储位置是按顺时针找到的第一个存储节点。例如 Object A 顺时针找到的第一个节点是 Node A，所以 Node A 负责存储 Object A，Object B 存储在 Node B。

一致性哈希算法大概如此，那么它的容错性和扩展性如何呢？

假设 Node C 节点挂掉了，Object C 的存储丢失，那么它顺时针找到的最新节点是 Node D。也就是说 Node C 挂掉了，受影响仅仅包括 Node B 到 Node C 区间的数据，并且这些数据会转移到 Node D 进行存储。

同理，假设现在数据量大了，需要增加一台节点 Node X。Node X 的位置在 Node B 到 Node C 直接，那么受到影响的仅仅是 Node B 到 Node X 间的数据，它们要重新落到 Node X 上。

所以一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是数据倾斜。

如果在分片的集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少。也就是说无法控制节点存储数据的分配。如下图，大部分数据都在 A 上了，B 的数据比较少。

4、哈希槽
redis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。

首先哈希槽其实是两个概念，第一个是哈希算法。redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。

redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。

另外在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。

但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。

      redis的主从复制是怎么实现的      

      redis的数据结构 最常问 hash是什么， sorted set怎么实现的      

      因为项目的原因，问我redis是怎么保证高可用的，主从和集群怎么加在一起      

      redis 和memcache的区别      

      redis 分布式锁的实现原理  setNX 啥的      

      redis模拟session，除了redis你还考虑过别的吗      

      redis的缓存击穿，怎么处理这个问题      

      redis是基于内存的，那么它有持久化吗，aof  rdb      

      aof和rdb的优缺点，你在项目中使用的哪一个      

      redis 的淘汰算法，你在哪配置淘汰算法

Redis中数据倾斜问题

Redis的哈希环最多有16384个槽，为什么是16384？ 当哈希环出现“数据倾斜” 该如何解决？

说一下Redis Cloud的设计与实现

描述一下Redis中的哨兵机制，主从切换具体是如何实现的？

Redis里面使用到了Raft协议，你有了解么？

Redis有哪些数据结构

Redis和LevelDB的区别

Redis中的基本数据类型

Redis中的IO模型

Redis中消息模型中消费线程数和生产线程数框架中设置的为多少

Redis中的命令

set和zset区别

zset底层排序是如何实现的

zset排序是通过什么顺序进行排序的

Redis 源码读过吗？直接说源码

谈谈你对redis的理解。提到一个redis热启动，没听过，一脸懵逼。

秒杀过程中怎么保证redis缓存和数据库的一致性？

多个用户请求同时第一次访问空的redis，怎么样不使redis崩溃？

来，谈一谈你的redis理解，为什么使用prostuff，不用传统的序列化？

多个线程同时访问为空的redis，怎么解决（这两个问题跟网易一模一样）

使用redis来实现单点登录，那么当单个redis节点内存不够的时候，怎么办？ 集群化，redis-Cluster

redis，主从，哨兵，集群，分布式锁。

redis的对象类型， 每种对象类型对应的底层的数据结构，参考redis设计与实现。

string, list, hash, set, sortedset. 						

每种对象都至少有2中数据结构， SDS, linkedlist, ziplist, intset, ziplist, skiplist

redis，分布式锁， redlock算法

redis介绍， 系统中的角色，作为缓存， 分布式session服务器

redis的 性能，可用性，主从复制+哨兵， redis缓存访问有网络上的消耗。

redis事务， 分布式事务， 2PC， 本地消息表等， 3PC

分布式锁（项目）， redlock，持久化机制，主从复制过程， redis知道的都说出来

redis解决分布式Session问题， 单点登录， Session一致性问题，描述，如何实现

讲一讲Redis的特性，redis为什么快，redis你用了哪些数据结构，粉丝列表可以用redis存储吗，redis集群会配置吗，redis宕机后数据会消失吗，redis可以持久化吗，怎么持久化。

Redis 数据结构，底层实现、ZSET 底层实现

一致性 Hash（我从余数 Hash 讲到 一致性 Hash 再到一致性 Hash 实现再到一致性 Hash 缺点再引出 Redis 原生集群实现去中心化的哈希槽实现）讲了十分钟吧，讲完面试官都笑了，然后问我 Redis 看过哪些书，自己说了两本 + 掘金小册一个  

Redis 持久化实现方式，优缺点

Redis 分布式锁实现，Redis 集群选举

Redis 集群选举，心跳检测

项目中用到了Redis，介绍一下Redis数据类型

你们怎么保证Redis缓存和数据库的数据一致性？缓存雪崩？击穿？穿透？

Redis线程安全吗，事务支持一致性吗

redis特点？和Mysql区别？缺点？数据存储在哪的

怎么想到要用redis缓存数据的

问Redis为什么快，我答内存数据库、单线程、IO多路复用的epoll。

问Redis,问了持久化，RDB和AOF，然后问了AOF的具体过程，问了AOF文件重写是怎么做的，问了Redis为什么单线程，Redis底层的数据结构，SDS

说一下Redis的使用场景

说一下基于Redis实现的分布式锁，问的比较细，比如线程阻塞导致，导致锁过期，其他线程获取了锁然后前一个线程又释放了第二个线程的锁这种，还问了一个线程等待Redis的分布式锁，整体等待时间的是怎么样的（这个答得不太好，主要没理解他这么问的意图）  

为什么用 redis，有什么优势

Redis 的数据结构

Redis 的槽分配，如果一个集群节点挂了怎样重新分配对应的槽 

Redis 集群的哈希算法和渐进式 rehash 的过程 

Redis 主从架构，如何保持数据一致性 

Resdis 节点间如何通信，用了什么协议，具体流程

如何解决缓存雪崩和缓存击穿

Redis 的容灾，单机和分布式环境分别说一下

Redis 的两种持久化，各自的优缺点

Redis 的 IO 多路复用模型

缓存击穿，穿透，雪崩怎么处理，怎么预防

redis锁机制，怎么处理并发（我说这个不太熟，mysql的锁机制比较熟，小哥哥说那你讲一下）

MySQL
MySQL锁机制

myql间歇锁的实现原理

Java和mysql的锁介绍，乐观锁和悲观锁

MySQL

      引擎，区别是什么      

      索引，有哪些索引，怎么用      

      索引为什么要用B+树，B+树和B-树的区别是什么      

      mysql的默认事务级别，一共有哪些事务级别      

      mysql的一些语句，这些肯定需要掌握的      

      mysql事务是怎么实现的      

      mysql锁，行锁，表锁 ，什么时候发生锁，怎么锁，原理      

      数据库优化，最左原则啊，水平分表，垂直分表

mysql索引失效场景

Innodb的索引实现

MySQL索引类型， 底层的数据结构

SQL 索引，存储引擎对比，B+、B-、红黑树对比，Hash 索引和联合索引

MySQL 和 Redis 对比，我把能知道的都说了，还是没答到点上

MySQL 索引，存储引擎，查询优化

数据库表A有m条数据，B有n条数据， left join一下， 有多少条数据。

MySQL外键删除策略？

如何做的MySQL优化？

MySQL索引结构？介绍一下B树和B+树？MyISAM和InnoDB索引的区别？

MySQL分库分表的方案？
（我介绍了我们使用的三种方式，hash法、range法以及当前正在使用的hash+range法）

事务隔离级别，MySQL默认级别，（可重复读），为啥使用可重复读？（可重复读+MVCC达到了序列化要求）

mysql存储引擎

mysql数据存到哪的？

主从复制流程

InnoDB索引用的什么数据结构？B+树是怎么存储数据的？

Mysql:怎么找出表中重复的数字

oracle--mysql数据库迁移，不停止业务的前提下怎么迁移（双写？？缓存一致性？？）

MySQL和Redis区别，原理

sql找出每个班级成绩排名第二的学生

mysql事务的隔离级别

mysql的事务、隔离级别

说一下mysql的事务隔离级别，然后讲了四个隔离级别，以及对应产生的问题（脏读不可重复读幻读），以及InnoDB对应的2 3级别的实现，MVVC的实现，两个隔离级别产生Review的时间点和次数的区别，还有Next-Key Lock ，行锁加间隙锁。  

问了mysql的引擎，索引，有哪些索引，然后问了主键索引和非主键索引的区别，讲了聚集索引，然后问了索引访问的过程，问了用聚集索引和不用的磁盘io访问次数的不同。

存储引擎，InnoDB

MySQL 中的索引为什么用 B+ Tree 而不用 B Tree

MySQL 中如何强制走指定的索引

存储引擎，B+ Tree 的结构，最左匹配原则

MySQL 的默认隔离级别能否解决幻读的问题

InnoDB 引擎的特点，支不支持事务

mysql 有几种数据库引擎。（面试官一开始说成了 mybatis 的存储引擎。）

mysql索引

Innodb和MyISAM区别 稀疏索引和密集索引

mysql最左匹配原则

mysql事务隔离级别 事务并发产生的问题

mysql的锁 mysql的死锁

MVCC

三大范式

MySQL索引的机制，我说的是B+，不知道是不是他的意思
为什么要用索引，好处是？坏处是？
简单介绍一下MySQL的事务。这里我又好难了，又不知道回答的方向是什么。于是就说了事务的隔离，MySQL的引擎
数据库回滚的原理，这个我还真不怎么会

mysql和redis怎么保证数据一致

Mysql表A中a字段有重复值，在重复数据中删除掉id小的，只留id最大的值，该怎么写执行句？
https://zhidao.baidu.com/question/648459508185442085.html

DELETE FROM NAMES
 WHERE id NOT IN (SELECT * 
                    FROM (SELECT MAX(n.id)
                            FROM NAMES n
                        GROUP BY n.name) x)
数据库
你会怎么设计数据库表结构

数据库有哪些索引？

如何防止sql注入

缓存和数据一致性，怎么处理。流式计算

把乐观锁加在数据库上面，怎么实现

数据库原理，数据库中间件，索引优化

讨论了一下数据库表设计

数据库了解多少，索引说一下，存储引擎比较，热备份、冷备份

数据库select查询优化问题。

数据库的隔离性问题，acid，脏读，不可重复读、幻读。

一个实时通讯软件怎么设计他的数据库表

数据库引擎MyISAM和InnoDB的区别

那如果数据量很大，并且我要保证实时数据和历史数据有交集有历史沉淀，你会怎么设计?

数据库事务隔离级别

事务的特性 ACID ， 数据库的死锁发生的情景

数据库索引有了解吗，你这个项目用了索引吗，用在了哪张表，为什么要用索引，索引快在哪里，事务隔离级别，传播方式这些介绍下。

用户量增多了怎么办，服务器压力太大了你会用什么方式，数据库呢，遇到高并发呢，你会改变表结构吗。

数据库：索引、Join、Left Join、Right Join、Union 区别、数据库三范式，设计表时是如何考虑的

数据库：索引、存储引擎对比、查询优化

分库分表，数据库事务，分布式事务

有没有用过数据库 ， 怎么去连 。 哪几个步骤？ 说一下。 数据库连接池了解吗， 有什么好处？有没有写过复杂sql  游标了解吗

数据库用吗？ 平时写sql吗？ 写过复杂的sql吗？ 多少数据量

数据库查询慢是什么原因。

索引了解吗？ 哪些字段要加索引？加了索引为什么就快了? 底层数据结构说一下，红黑树了解吗？ 为什么不用红黑树？ B+树说一下？B+树在增加数据的时候， 会碰到什么样的问题？

什么是事务？事务隔离级别和MVCC？
（我对于这里比较了解，在征得面试官同意后，展开说了InnoDB底层对于各个隔离级别以及MVCC的实现，包括各种锁、ReadView机制和版本链机制）

看你数据库用的不错，数据库三范式+BCNF范式？

说一下数据库范式

乐观锁和悲观锁，数据库是怎么实现的，数据库语句？

数据库锁按照锁的粒度分为哪几种？用过哪种？为什么会出现死锁？

索引实现?什么时候用索引？

主从复制，为什么要用主从复制？一个数据库同时读和写不行吗？磁盘角度分析？（硬盘、寻址、随机读写...）

数据库查询慢怎么办

索引为什么快，底层是怎么实现的

讲一下索引

讲一下存储引擎

什么时候不走索引

给例子判断什么时候触发行级锁和表级锁

数据库，事务，隔离级别，存储引擎

数据库的存储引擎应用场景，索引结构

大数据量的优化

实现过分库分表吗，有哪些分库分表的组件

数据库，三大范式

数据库的连表查询和嵌套查询，分页查询

数据库增删查改语句重复应该考虑什么

数据库索引，存储引擎

联合索引，举例子什么时候不走

讲讲二级索引
（我当时就蒙蔽了，我索引都准备那么长时间的聚簇索引，其他的东西，上来问我一个 没听过的，我只能扯我知道的索引是什么，索引的结构是用B和B+做的等等等，但是面试官不满意我扯开话题）

那你讲讲B+树存储什么数据
（叶子结点存储数据库中的数据项）

数据库事务的特点，隔离性对应哪几种隔离级别

MVCC 是什么，核心问题是什么，为什么会有 MVCC

数据库的隔离级别，怎么实现可重复读    我回答了MVCC，然后开始讲MVCC的原理，我快讲完的时候他突然说你是在回答我的问题吗？我问的是怎么实现可重复读，两者有关系吗？我后面还解释了一下

数据量大了，数据库怎么处理（扯了分库分表，RedisCluster做缓存）

索引那块怎么优化的，索引底层数据结构？

XML
XML的解析怎么用什么解析的？

Servlet
讲一讲Servlet， web.xml 配置路径到servlet的映射， init， service， destroy

Tomcat
可以看一看Tomcat容器的过程 ，Connector和 Context容器两大部分。 完成从socket到 request和Response对象的构造

Socket
socket通信怎么建立的

socket  websocket 会从tcp里面引出来  

前端
两次点击，怎么防止重复下订单

怎样防止表单重复提交

一个n层嵌套的json字符串怎么解析

cookie和session区别

get和post区别

网址中输入URL，一系列过程

状态码，知道的讲一下

get和post区别，post一定是安全的么？怎么解决登录信息被截取？

淘宝的登录就是get方式，怎么保证安全？

项目的JS和AJAX也是自己写的吗，介绍下你是如何开发前后端的

怎么不用经过很多层直接接收前端传阿里的东西；A用户登录，怎么保证他不读到B用户的信息？（拦截器，threadlocal类）

问我session那块，我的session共享是怎么做的，为什么这么做（面试官觉得我这么做没必要，跪），然后问session使用的过程，和cookie的关系

问了一个页面重定向的问题，问我一个页面自动跳转另一个页面怎么实现，我说了前端和后端都可以做跳转，然后问我各自的具体是怎么做的，这部分我没答好，没了解过这部分，然后问了301和302的区别，我只知道都是重定向，也没答好，（一个是临时的一个是永久的，我连这个都没答出来）

如果不用这个单点登录，怎么管理 session  

cookie 和 session 的区别

post 和 get 的区别

转发和重定向的区别

请求在服务器端的过程

controller 和 service 和 dao 怎么关联起来的

restful

前端语言与 Java 性能对比

不使用 Spring 框架 或者 JSP & Servlet 如何实现浏览器和服务器之间的通信

输入 URL 到前端渲染的过程

网络概述
七层模型

tcp的五层

常见的每层的代表协议

IOS7层变成为什么变成5层，为什么要分层？

有网络层的存在，为什么还要传输层

OSI七层网络模型，常见协议作用于哪层，交换机和路由器区别，ping指令原理

TCP
三次握手，四次挥手 

如果2次握手会怎么样，四次回收如果服务端直接把ack和fin一起返回做三次挥手会怎么样

窗口机制，你了解吗

如果用TCP进行服务器某端口的探测，你要怎么改tcp使得其消耗最少，面试官提示过我，tcp先发syn包，然后收到ack之后，直接回一个reset

如果有一台机器B，去模拟机器A，向C发送syn包，这个时候会怎么样，讲真的，我一脸懵逼。

TCP的原生API用过没

tcp如何解决丢包问题

tcp和ip区别。说下ip的包头和tcp的包头。

TCP可靠性保证怎么实现

三次握手中为什么不是两次？为什么不是四次？

tcp滑动窗口和阻塞避免

TCP 中 time-wait 状态

TCP 四次挥手，如果不等 2MSL 的话整个网络会出现什么情况

TCP 三次握手，标志位怎么设，TIME_WAIT 发生在哪儿

TCP与UDP区别 TCP的流量控制和拥塞机制 三次握手和四次挥手

UDP
和TCP的区别

应用场景

ftp 怎么实现的，，，

HTTP
简述下http，状态码

HTTP状态码

Http怎么实现长链接的？http2.0的特点

加密
加密方式

非对称传输秘钥，对称传输数据

常见的加密算法~~

密码采用哪种加密方式（MD5），你为什么要用这种方法，这种方式又不安全的地方，你会怎么解决它。

计算机网络
DNS寻址过程，递归~

长连接实现

mac地址和ip地址，瞎扯了写

网站输入一网址过程，具体讲一下DNS解析过程。

hosts文件

五层模型

arp协议和ip协议

访问百度的过程

浏览器从输入URL到返回结果中间经历了什么？

七层模型，每层用的协议

计网的ARP协议

端口的实现

浏览器输入URL，流程

负载均衡
负载均衡反向代理，这个时候，访问后台的那个ip到底是客户还是反向代理，还怎么统计ip？

负载均衡了解吗，如果让你实现负载均衡你会使用哪种方法，为什么要用这种方法，其他方式又了解过吗，各自方式的特点。

负载均衡的策略

Nginx
nginx

怎么配置负载均衡

怎么限流

怎么使用nginx缓存

为什么使用nginx，有别的替代品吗

nginx的压力测试，你测试过吗，能抗住多少压力

nginx是如何实现反向代理的，哪一层的方向代理？ 应用层

如何向外提供HTTPS协议的服务， 在内网使用http协议， 通过nginx配置来进行实现

nginx可承受的压力

Linux
如何修改linux的文件权限

命令

常见的命令

sed 和 awk 感觉linux必考。。

linux的使用场景，你什么时候会用linux -- 》 布置服务器

怎么查看进程和杀死进程

打印一个文件夹中的所有文件

linux指令：观察端口netstat、内存top、磁盘df、进程打开多少文件夹怎么看（我说了ps…不对，应该lsof ）

linux中数据怎么存储，关于数据块怎么优化存储。随机读和顺序读。

linux内存管理，以及其中的算法。

Linux平台：查看文件指令（tail/sed）、进程启动方式（命令行直接运行可执行文件）

Linux中epoll和select区别

Linux进程间的通信方式， 管道，有名管道，socket，共享内存，消息队列

Linux常见的操作指令

Linux系统下的常用指令

Linux常用指令，如何查看某个ip被哪个进程占用

操作系统
进程、线程、协程区别。用过协程吗？

虚拟内存和物理内存之间如何联系的？什么时候进行交换。

了解线程与协程的区别嘛？协程有哪些优势？把所有多线程都替换成协程实现可以嘛？

进程通信方式

锁在操作系统层面实现原理（回答那么多，其实面试官的意思是想让我回答原子性三个字。。。）

进程中文件写怎么保证安全？我操作系统那块不熟，就提了JAVA中的ReadWritelock底层实现。

如何实现进程间特定场景下的高效通信， 问了存储相关的问题。

死锁的四个必要特性， 非共享， 持有并等待， 非抢占， 循环等待

死锁避免 死锁预防

操作系统了解说，说一下你设计操作系统要几个模块。
（磁盘管理  线程管理  IO管理  文件管理）

OS进程间通信的方式？Java使用的哪种方式？

进程与线程的区别

进程和线程

进程通信的几种方式

死锁，死锁避免，预防

计算机组成原理
常见计算机原理的知识点

      float在计算机中是怎么存储的，当时被问到的时候，我也在问自己，怎么存的~~~ 佛了      

      线程和进程的区别      

      线程的通信方式，进程的通信方式      

      系统线程的数量上限是多少      

      页式存储的概念      

      内存碎片，你有了解过吗，有想过解决方案吗~

磁盘的寻址方法

一个CPU单核，同时只能处理一个指令，是或否？

一个CPU 8核，最多同时只能处理8条指令，是或否？

JVM虚拟机
jvm的回收算法

 full gc怎么触发

gc算法

高吞吐量的话用哪种gc算法

full gc问题，怎么排查

jvm的回收策略

ClassLoader原理和应用

jvm分区模型

首先是模型分成哪几块，堆 栈等等。。

哪些是线程私有的哪些是共有的

1.6之前和现在1.8哪些地方做了改动(主要是静态区的变化)

垃圾回收

三种回收算法

常见的垃圾回收器

root引用和引用计数

频繁GC的原因和解决方案

高并发后台怎么优化GC，我主要是说了调整eden和surival的比例啥啥啥的

类加载器

双亲委任

如果发生了冲突，会出现什么情况-- 编译不报错，运行调用bootstrapclassloader加载rt.jar中的类

jvm调优

加分项，美团面试的时候一面和面试官讨论了调优的一些细节 --xmns啥的

jvm工具，jstack jconsole 这些，还是看一丢丢，留个印象

说下java里面的OOM

JVM Server模式与client模式启动的差别？

GC优化，程序中应该如何优化？

JVM内存管理和垃圾回收。哪些操作会导致OOM？循环引用怎么解决？

JVM虚拟机启动有哪些线程？

你平时用的JVM版本是什么？最新版本是什么？

在JDK8中移除永久代，并把方法区移至元空间，这么设计的原因是什么

元空间需要进行GC么？需要的话，元空间的GC是young gc还是full gc

G1的适用场景和实现原理

详细说一下Remembered Set的作用，什么时候会往里面写、更新等

还有一个Collection Set，你知道C Set的作用是什么吗？

再到jvm怎么回收垃圾，说到引用计数和根可达分析，jvm怎么确定根元素

如果一个系统要进行调优你会考虑哪些方面；答:jvm(非常详细的展开），如果有数据库查询可以用索引等等。。。

说一说jvm的分区

JVM内存结构

JVM回收机制，从判断对象死亡、GC Roots、Stop the World、回收算法优缺点讲起，提到引用计数弊端。

JVM中给对象赋值为null，一定会被回收么？举个case，讲到了内存泄露。

JVM的回收算法，当我背到一半后，打断了，说我知道你是为了面试背背而已，过几天忘了

major gc和full gc的区别，我脑抽，说反了，被鄙视了

聊了这么久虚拟机，你调过优吗？怎么调的。。。一脸懵逼

JVM 内存划分， 堆内存分代

JVM中的内存区域划分，堆的分代，为什么分代， 垃圾回收算法，垃圾回收器

JVM堆划分，方法区

执行了 system.gc(）触发的GC机制，FGC， 如何进行回收的， 分代回收

系统周期性卡顿，如何定位问题，结合GC日志， YGC,FGC， 调整分代的大小， 减小FGC时间

产生FGC的原因

服务器CPU使用率很高，如何排查， top 定位进程， 如果是Java，通过jstack进行线程快照分析，jmap，jhat 等等，

有没有jvm调优经验（没有）

讲下 JVM。这块主要我自己在说，一口气说下来说了有二十多分钟吧，面试官一直没说话，我就一直说，从运行时数据区，讲到一个类具体是如何存储的，再讲到垃圾回收机制和垃圾收集算法，再讲到各个版本的 JDK 的垃圾收集器，再讲到 YoungGC 和 FullGC，再讲 YoungGC 的具体过程，对象是如何分配的，出现 OOM 时如何排查，已经自己在项目的一个 GC 调优做的具体工作  

JVM 运行时数据区，Synchronized 和 ReentrantLock 区别

JVM 运行时数据区

GC 调优

JVM了解吗，说说所知道的
（？？我讲了内存区域、垃圾回收、类加载，然后，面试官说可以了）

Java的垃圾回收机制

Full GC

Java内存模型

内存泄漏，out of memory

FullGC什么时候会发生

outofmemory，内存泄漏

垃圾回收，怎么判断对象需要回收，垃圾回收机制

堆空间怎么分的

jvm内存分区？常量在哪？变量在哪？堆怎么划分的？

怎么判断需要垃圾回收？GC Root？

常见的垃圾回收期

outofmemory遇到过没，设置jvm参数吗？

Java垃圾回收，需要程序员自己回收吗？

jvm内存分区，gc发生在哪？

数组长度不确定，能在栈上分配内存吗？

垃圾回收机制

GC，新生代为什么要采用复制算法

G1

 问我a=2,b=1,c=a+b底层具体是一个什么样的过程，答了java内存的分布，具体在哪个位置，比如常量池在方法区，然后栈存对常量的应用之类的。
问底层呢我答内存拷贝，问有多少次内存拷贝，然后又问在多核cpu和多线程下，然后也是这种情况，cpu和底层又具体是什么样的过程，互相之间怎么影响，怎么不影响。

讲一讲java的内存模型

jvm的内存布局和gc过程

jvm怎么调优，什么看gc的日志之类的

问我对jvm的垃圾回收了解吗，说了从新生代到老年代的整体的过程，用什么垃圾回收算法，举了几个垃圾回收器的例子，说来空间分配担保和可能产生full gc的原因，反正尽可能细的去说自己知道的，越细越好。

JVM 是怎么判断两个类相等

类加载器

类加载过程

双亲委派模型

JVM,，哪些对象需要回收，垃圾收集算法

GC 的过程，引用计数法还有在使用吗

GC 的过程，为什么要分代

CPU 占用率达到 100% 可能由什么造成

那你说说java泄露，可以写一个程序吗？
（我当初一听第一反应就是终于我这个会了，就回答说： 这个问题很好解决，就说 只要写一个程序 无限创建一个new对象，这个对象是强引用，就可以保证堆被撑破，他说不行，我最后又加了一句，在这个基础上，循环引用，不会被GC，面试官最后说还是不行，其实当初也是慌了，就真的不知道该怎么办了，因为以前看过OOM怎么解决，但是没想过怎么产生OOM，觉得能产生OOM的还被面试官一直否决，最后面试完在网上查才知道，其实应该再加一个条件，就是循环引用的同时，保证一个对象必须是GC root，我当初面试也没尝试再说这一句，只能说紧张加学艺不精）
评论：是不是问的是内存泄露，而你好像理解成内存溢出惹…？

发生 FULL GC 的条件

CMS 垃圾收集器的特性，工作的四个流程，哪几个流程 stop the world

项目中关于 FULL GC 调优的细节

JVM 的内存结构，哪些是线程私有，哪些是线程公有

JVM 的结构，垃圾收集算法

JVM 的类加载过程。谈到了双亲委派模型。

怎么打破双亲委派模型。自己实现一个类加载器，怎么打破类加载器？问具体的实现细节。

类加载器都有哪些 双亲委派机制

JAVA内存区域（堆 栈等） JAVA内存模型（工作内存 主内存等）

垃圾回收：年轻代老年代 回收算法 垃圾回收器等

内存溢出的原因 如何排查

强引用 弱引用 软引用 虚引用

cpu标高100%什么原因？为什么会出现死循环？

介绍垃圾回收算法
介绍复制回收算法
哪种垃圾回收算法效率最低
详细介绍标记算法，标记清除流程

RPC远程过程调用
rpc原理

RPC框架，同步异步，响应时间，这些都被问到过，还让设计过

如果你自己设计一个rpc框架，怎么设计？

服务调用超时可能由什么造成

后端服务出现了大量超时，怎么排查？（支支吾吾答了一通，答得不好。）

分布式
多个服务端上下线怎么感知

分布式一致性讲一讲

分布式锁的实现方式，zk实现和redis实现哪个比较好

分布式数据一致性

一致性哈希

分布式事务

降级策略和降级框架

分布式协议PAXOS/zab/raft都说下原理和区别；

CAP理论以及典型运用

分布式协议有哪些，Raft协议

说一下Raft和Paxos协议的区别

一次性hash，大致是想说如何最小的代价，实现在hash分发请求到服务器时，出现该台服务器不能存放的情形(雪花算法)

事务，分布式事务， 如何实现分布式事务， 两阶段提交，（过程）

分布式系统又了解吗，分布式的特点，你会怎么搭建分布式系统，集群了解吗，集群的优点讲讲，你会怎么用集群。

CAP 和 BASE 理论，以及个人的理解

2PC 和 3PC

CAP 和 BASE

 2PC 和 3PC、一致性 Hash

CAP知道吗？ 说一下。

分布式结构，怎么保证数据一致性？如果从服务器出问题了怎么办？

分布式缓存

分布式，分布式锁的实现

讲一讲一致性哈希

分布式系统需要一个唯一的 ID 生成器，怎么设计？（没了解过分布式的内容，答得也不好，自己想的。）又扯到了数据库的读写分离以及怎么实现。

Dubbo
 dubbo、netty介绍原理

dubbo

原理，怎么用

和eureka有什么区别

为什么要用dubbo，不用行不行？

跨域请求的一些知识点

Dubbo 源码读过吗？

讲 Dubbo SPI 的源码？

Dubbo 服务暴露源码 + Dubbo 服务注册 

讲一下 Dubbo 服务引用底层？开始一直以为是动态代理调用 invoker 模型，结果说不够底层原理问 RPC 协议。

讲一下 Dubbo RPC 协议调用过程，使用哪些协议？  

Dubbo 的连接（这里问的贼细，全靠推理推出来的。。）

Dubbo 的负载均衡

dubbo了解吗？（。。不了解）

Netty
Netty原理

Netty解决了rpc 、 分布式调度系统哪一些共性问题？

Netty怎么使用少线程解决并发请求的问题的

ZooKeeper
 zk挂了怎么办

zookeeper原理大概讲下。以及你用到的实际案例，比如HA

zookeeper分布式锁

说下自己对  Zookeeper 的理解已经在项目中是如何应用的，自己扯 ZAB，已经 ZK 在 Dubbo 做注册中心，在 Kafka 中做集群管理，还有分布式锁实现，集群选举 Raft 和 Paxos 区别已经具体的流程  

Zookeeper了解吗？（。不了解）

Docker
Docker的原理

docker

和vmware的区别

你一般是怎么部署的 IDEA，直接把项目部署到docker并打包到云服务器

docker的好处，小，快

消息队列
消息队列原理介绍（不太会）
https://www.cnblogs.com/ifindu-san/p/7832598.html（《消息队列MQ技术的介绍和原理》）

消息中间件概述
消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行--它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。

在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。

设计分布式应用的方法主要有：

远程过程调用(PRC)--分布式计算环境(DCE)的基础标准成分之一；
对象事务监控(OTM)--基于CORBA的面向对象工业标准与事务处理(TP)监控技术的组合；
消息队列(MessageQueue)--构造分布式应用的松耦合方法。

(a) 分布计算环境/远程过程调用 (DCE/RPC)
RPC是DCE的成分，是一个由开放软件基金会(OSF)发布的应用集成的软件标准。RPC模仿一个程序用函数引用来引用另一程序的传统程序设计方法，此引用是过程调用的形式，一旦被调用，程序的控制则转向被调用程序。

在RPC实现时，被调用过程可在本地或远地的另一系统中驻留并在执行。当被调用程序完成处理输入数据，结果放在过程调用的返回变量中返回到调用程序。RPC完成后程序控制则立即返回到调用程序。因此RPC模仿子程序的调用/返回结构，它仅提供了Client(调用程序)和Server(被调用过程)间的同步数据交换。

(b) 对象事务监控 (OTM)
基于CORBA的面向对象工业标准与事务处理(TP)监控技术的组合，在CORBA规范中定义了：使用面向对象技术和方法的体系结构；公共的Client/Server程序设计接口；多平台间传输和翻译数据的指导方针；开发分布式应用接口的语言(IDL)等，并为构造分布的Client/Server应用提供了广泛及一致的模式。

(c) 消息队列 (Message Queue)
消息队列为构造以同步或异步方式实现的分布式应用提供了松耦合方法。消息队列的API调用被嵌入到新的或现存的应用中，通过消息发送到内存或基于磁盘的队列或从它读出而提供信息交换。消息队列可用在应用中以执行多种功能，比如要求服务、交换信息或异步处理等。

中间件是一种独立的系统软件或服务程序，分布式应用系统借助这种软件在不同的技术之间共享资源，管理计算资源和网络通讯。它在计算机系统中是一个关键软件，它能实现应用的互连和互操作性，能保证系统的安全、可靠、高效的运行。中间件位于用户应用和操作系统及网络软件之间，它为应用提供了公用的通信手段，并且独立于网络和操作系统。中间件为开发者提供了公用于所有环境的应用程序接口，当应用程序中嵌入其函数调用，它便可利用其运行的特定操作系统和网络环境的功能，为应用执行通信功能。

如果没有消息中间件完成信息交换，应用开发者为了传输数据，必须要学会如何用网络和操作系统软件的功能，编写相应的应用程序来发送和接收信息，且交换信息没有标准方法，每个应用必须进行特定的编程从而和多平台、不同环境下的一个或多个应用通信。例如，为了实现网络上不同主机系统间的通信，将要求具备在网络上如何交换信息的知识（比如用TCP/IP的socket程序设计）；为了实现同一主机内不同进程之间的通讯，将要求具备操作系统的消息队列或命名管道(Pipes)等知识。

目前中间件的种类很多，如交易管理中间件(如IBM的CICS)、面向Java应用的Web应用服务器中间件(如IBM的WebSphere Application Server)等，而消息传输中间件(MOM)是其中的一种。它简化了应用之间数据的传输，屏蔽底层异构操作系统和网络平台，提供一致的通讯标准和应用开发，确保分布式计算网络环境下可靠的、跨平台的信息传输和数据交换。它基于消息队列的存储-转发机制，并提供特有的异步传输机制，能够基于消息传输和异步事务处理实现应用整合与数据交换。

IBM 消息中间件MQ以其独特的安全机制、简便快速的编程风格、卓越不凡的稳定性、可扩展性和跨平台性，以及强大的事务处理能力和消息通讯能力，成为业界市场占有率最高的消息中间件产品。

MQ具有强大的跨平台性，它支持的平台数多达35种。它支持各种主流Unix操作系统平台,如：HP-UX、AIX、SUN Solaris、Digital UNIX、Open VMX、SUNOS、NCR UNIX；支持各种主机平台，如：OS/390、MVS/ESA、VSE/ESA；同样支持Windows NT服务器。在PC平台上支持Windows9X/Windows NT/Windows 2000和UNIX (UnixWare、Solaris)以及主要的Linux版本(Redhat、TurboLinux等)。此外，MQ还支持其他各种操作系统平台，如：OS/2、AS/400、Sequent DYNIX、SCO OpenServer、SCO UnixWare、Tandem等。

 

MQ的基本概念：
1) 队列管理器
队列管理器是MQ系统中最上层的一个概念，由它为我们提供基于队列的消息服务。

2) 消息
在MQ中，我们把应用程序交由MQ传输的数据定义为消息，我们可以定义消息的内容并对消息进行广义的理解，比如：用户的各种类型的数据文件，某个应用向其它应用发出的处理请求等都可以作为消息。消息有两部分组成：

消息描述符(Message Discription或Message Header)，描述消息的特征，如：消息的优先级、生命周期、消息Id等；

消息体(Message Body)，即用户数据部分。在MQ中，消息分为两种类型，非永久性(non-persistent)消息和永久性(persistent)消息，非永久性消息是存储在内存中的，它是为了提高性能而设计的，当系统掉电或MQ队列管理器重新启动时，将不可恢复。当用户对消息的可靠性要求不高，而侧重系统的性能表现时，可以采用该种类型的消息，如：当发布股票信息时，由于股票信息是不断更新的，我们可能每若干秒就会发布一次，新的消息会不断覆盖旧的消息。永久性消息是存储在硬盘上，并且纪录数据日志的，它具有高可靠性，在网络和系统发生故障等情况下都能确保消息不丢、不重。

此外，在MQ中，还有逻辑消息和物理消息的概念。利用逻辑消息和物理消息，我们可以将大消息进行分段处理，也可以将若干个本身完整的消息在应用逻辑上归为一组进行处理。

 

3) 队列
队列是消息的安全存放地，队列存储消息直到它被应用程序处理。

消息队列以下述方式工作：

a) 程序A形成对消息队列系统的调用，此调用告知消息队列系统，消息准备好了投向程序B；

b) 消息队列系统发送此消息到程序B驻留处的系统，并将它放到程序B的队列中；

c) 适当时间后，程序B从它的队列中读此消息，并处理此信息。

 

由于采用了先进的程序设计思想以及内部工作机制，MQ能够在各种网络条件下保证消息的可靠传递，可以克服网络线路质量差或不稳定的现状，在传输过程中，如果通信线路出现故障或远端的主机发生故障，本地的应用程序都不会受到影响，可以继续发送数据，而无需等待网络故障恢复或远端主机正常后再重新运行。

在MQ中，队列分为很多种类型，其中包括：本地队列、远程队列、模板队列、动态队列、别名队列等。

本地队列又分为普通本地队列和传输队列，普通本地队列是应用程序通过API对其进行读写操作的队列；传输队列可以理解为存储-转发队列，比如：我们将某个消息交给MQ系统发送到远程主机，而此时网络发生故障，MQ将把消息放在传输队列中暂存，当网络恢复时，再发往远端目的地。

远程队列是目的队列在本地的定义，它类似一个地址指针，指向远程主机上的某个目的队列，它仅仅是个定义，不真正占用磁盘存储空间。

模板队列和动态队列是MQ的一个特色，它的一个典型用途是用作系统的可扩展性考虑。我们可以创建一个模板队列，当今后需要新增队列时，每打开一个模板队列，MQ便会自动生成一个动态队列，我们还可以指定该动态队列为临时队列或者是永久队列，若为临时队列我们可以在关闭它的同时将它删除，相反，若为永久队列，我们可以将它永久保留，为我所用。

4) 通道
通道是MQ系统中队列管理器之间传递消息的管道，它是建立在物理的网络连接之上的一个逻辑概念，也是MQ产品的精华。

在MQ中，主要有三大类通道类型，即消息通道，MQI通道和Cluster通道。消息通道是用于在MQ的服务器和服务器之间传输消息的，需要强调指出的是，该通道是单向的，它又有发送(sender), 接收(receive), 请求者(requestor), 服务者(server)等不同类型，供用户在不同情况下使用。MQI通道是MQ Client和MQI通道是MQ Client和MQ Server之间通讯和传输消息用的，与消息通道不同，它的传输是双向的。群集(Cluster)通道是位于同一个MQ 群集内部的队列管理器之间通讯使用的。

MQ的工作原理(图见附件)
首先来看本地通讯的情况，应用程序A和应用程序B运行于同一系统A，它们之间可以借助消息队列技术进行彼此的通讯：应用程序A向队列1发送一条信息，而当应用程序B需要时就可以得到该信息。

其次是远程通讯的情况，如果信息传输的目标改为在系统B上的应用程序C，这种变化不会对应用程序A产生影响，应用程序A向队列2发送一条信息，系统A的MQ发现Q2所指向的目的队列实际上位于系统B，它将信息放到本地的一个特殊队列－传输队列(Transmission Queue)。我们建立一条从系统A到系统B的消息通道，消息通道代理将从传输队列中读取消息，并传递这条信息到系统B，然后等待确认。只有MQ接到系统B成功收到信息的确认之后，它才从传输队列中真正将该信息删除。如果通讯线路不通，或系统B不在运行，信息会留在传输队列中，直到被成功地传送到目的地。这是MQ最基本而最重要的技术--确保信息传输，并且是一次且仅一次(once-and-only-once)的传递。

MQ提供了用于应用集成的松耦合的连接方法，因为共享信息的应用不需要知道彼此物理位置（网络地址）；不需要知道彼此间怎样建立通信；不需要同时处于运行状态；不需要在同样的操作系统或网络环境下运行。

MQ的基本配置举例
在上图中，要实现网络上两台主机上的通讯，若采用点对点的通讯方式，我们至少要建立如下MQ的对象：
在发送方A:
1） 建立队列管理器QMA: crtmqm -q QMA
2） 定义本地传输队列: define qlocal (QMB) usage (xmitq) defpsist(yes)
3） 创建远程队列: define qremote (QR.TOB) rname (LQB) rqmname (QMB) xmitq (QMB)
4） 定义发送通道: define channel (A.TO.B) chltype (sdr) conname ('IP of B') xmitq (QMB) + trptype (tcp)

在接收方B：
1） 建立队列管理器QMB: crtmqm -q QMB
2） 定义本地队列QLB: define qlocal (LQB)
3） 创建接收通道: define channel (A.TO.B) chltype (rcvr) trptype (tcp)
经过上述配置，我们就可以实现从主机A到B的单向通讯，若要实现二者之间的双向通讯，可参考此例创建所需要的MQ对象。

MQ的通讯模式
1) 点对点通讯：点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。

2) 多点广播：MQ适用于不同类型的应用。其中重要的，也是正在发展中的是"多点广播"应用，即能够将消息发送到多个目标站点(Destination List)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。

3) 发布/订阅(Publish/Subscribe)模式：发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQ Event Broker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。

4) 群集(Cluster)：为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。

死信队列

MQ

      为什么选择rabbitMQ， 社区活跃，高并发      

      别的MQ也要了解，比如RocketMQ(阿里的，java开发，再次开发，并发高，分布式，出错少)      

      ActiveMQ， kafka       

      topic 和 block       

      MQ的作用，同步转异步，消除峰值      

      如何保证数据一致性，即原子性，ack      

      消息队列在项目中的应用

如果让你自己设计一个消息队列，怎么设计，消息队列底层最核心的技术是什么？  个人观点：消息存储+通信  其他就是高可用和高可靠的保障了，比如注册中心、负载均衡、确认应答

Kafka 架构原理，消费异常处理，重复消费处理，Kafak 可靠性，Kafak 副本机制，还一个什么高位低位，我不会

聊项目，消息队列怎么用的？ 策略是什么？

kafka怎么保证消息不丢失

mq怎么用的，有什么好处，还了解过哪些mq（扯了RocketMQ和Kafka）？
https://blog.csdn.net/songfeihu0810232/article/details/78648706 （《Java常用消息队列原理介绍及性能对比》）

为什么使用消息队列
解耦
在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

冗余
有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

扩展性
因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。

灵活性 & 峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

顺序保证
在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。

缓冲
在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。

异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

消息队列（MQ）常用的使用场景
进程间通讯和系统间的消息通知，比如在分布式系统中。

解耦，比如像我们公司有许多开发团队，每个团队负责业务的不同模块，各个开发团队可以使用MQ来通信。

在一些高并发场景下，使用MQ的异步特性。

消息队列性能对比及选型

登录
多点登陆怎么实现

登录功能考虑过安全问题吗，你怎么解决的。

单点登录

秒杀
 秒杀场景设计，应付突然的爆发流量

具体的秒杀细节怎么做的？秒杀的核心技术在哪儿？你怎么保证的？

超卖怎么解决？

秒杀商品的库存放在哪里，如何保证redis和DB的一致性

不使用缓存设计一个秒杀系统如何优化（说了下主从架构、读写分离 + MQ）

秒杀系统？十个东西是十一个人抢，怎么保证不出问题？？

秒杀平台怎样预减库存，MQ 有什么作用

怎样防止超卖现象

MQ 实现了异步但订单仍然有可能出现超卖，怎么解决

秒杀平台的优化，如何实现更高并发量、高可用性

如何解决超卖现象

设计模式
静态代理和动态代理的区别

单例模式，饿汉式，懒汉式，线程安全的做法，两次判断instance是否为空，每次判断的作用是什么。

面试中设计模式其实也是挺重要的

观察者模式

适配模式

工厂模式 等等

单例模式的六种实现及优缺点

静态单例实现的优势

什么情况使用枚举单例和容器单例

讲一讲建造者模式

解释下装饰器模式，回答不会，以前这个的确没准备

动态代理原理和实现，画出代理模式UML，我说不会画，然后面试官挺好的，说你是非计算机专业的，那就不用画了，那就在纸上写一个过程吧

动态代理实现，说一下过程

写了单例，具体解释了volatile禁止指令排序机制和对象new过程。

写了个单例模式。好久没写了有点忘了，双重锁检查写错了两个地方，被指出来了，尴尬

工厂模式的三种，以及个人的理解

代理模式，JDK 和 CGLIB，问我有没有用过，我没用过，不过看过 Dubbo 的源码，扯了下代理模式和单例模式在 Dubbo 中的应用，不过面试官应该不会 Dubbo，就没细问

说一下你知道的设计模式， 说一下单例的经典问题。设计模式的六大准则了解吗？、

依旧单例 以及单例的经典问题。说一下单例的使用场景吧

什么是动态代理

设计模式，单例模式，适配器模式

开闭原则

单例模式，实现方法，应用场景

生产者和消费者模式应用场景

mvc模式是什么
（这里确定了面试官看我简历了，因为在简历上的项目有写到根据mvc模式做项目，具体介绍了下各自的工作）

你用过什么设计模式
（介绍了单例，工厂，装饰器，观察者就被打断了）

讲一讲装饰者模式
（直接介绍了使用它的原因，也说了说 设计原则）

你用过装饰者模式做过什么东西

那你了解装饰者模式的应用场景是什么
（还是在死磕我这个问题，我只能说是增加一个类型的功能，但保证不修改类的内部结构，但是就是要问我具体是什么,我只能说我知道单例，还有其他模式的应用场景，这个我真的想不起来了，当时没意识到，从这个问题没答好开始，已经步入绝望了）

写一个单例模式

说说你熟悉的设计模式 在哪里使用过

单元测试
单元测试介绍一下，多模块依赖怎么单元测试。Mockito

有没有做过单元测试，不能连数据库， 你怎么做的单元测试。

大数据
大数据相关，MapReduce

机器学习
机器学习有了解么？

Git
git中是如何解决冲突的(自己根据实际使用随便答了一些)

开放题/项目
项目中的可用性，性能，扩展性 如何提升

设计一个网络的时候，需要考虑的因素

如何去提升系统的可用性，性能，扩展性，伸缩性，等等， LVS，反向代理，集群，异步，缓存等等

收获最大的一个项目， 着重介绍， 项目的演进过程， 从提高系统可用性的来进行演进，例如redis的可用性

开放性的系统设计，一个车票查询系统，对最短时间，最短开销进行求解，类似于12306的火车票购票系统

说说你项目的一些功能特点已经实现方式还有实现难点等。

画下项目的构成图

项目中的难点，如何解决的，（GitHub 上找别人的代码、博客上找答案）

线上的问题，如何去排查， 怎么去看到当前程序运行的状态。平时怎么调试的？

项目中数据安全性如何保证的？
（我答对于请求使用 session+token+时间戳 校验，对于传输的数据进行非对称加密，使用HTTPS，面试官不是很满意）

画一下项目的后端架构图

项目中遇到的最大的问题？

项目中如何处理终端之间的信息交互？
（Web网页之间使用的WebSocket, 与手机的交互使用的自己用Netty实现的IM框架）

项目中的并发临界资源是怎么处理的？

项目中用的哪种垃圾回收机制？

项目中用的垃圾回收机制。设置JVM参数

项目涉及缓存，所以问了蛮久基于业务方面缓存怎么做，比如缓存时间怎么设置，缓存哪部分数据，要取到很久之前的数据该怎么做之类的。（用Redis做的缓存）

场景题：设计一个权限系统

生成订单号的实现

项目架构的优化

你所了解的所有安全性问题以及解决思路

项目中 Redis 和 RabbitMQ 的作用是什么

假设你现在有一个高并发的服务，你要从那些地方去考虑。（楼主不咋会，又从高并发扯到了架构的学习。）

实现一个秒杀系统

实现一个优先级队列

自己实现spring 的ioc怎么做

如何用udp保证可靠性

让你设计一个高性能的购物网站，你怎么设计，从前端到后台，到数据库